<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src\hotspot\os\windows\os_windows.cpp</title>
    <link rel="stylesheet" href="..\..\..\..\style.css" />
  </head>
<body>
<center><a href="osThread_windows.hpp.udiff.html" target="_top">&lt; prev</a> <a href="..\..\..\..\index.html" target="_top">index</a> <a href="os_windows.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src\hotspot\os\windows\os_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,10 +29,11 @@</span>
  #include &quot;jvm.h&quot;
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/icBuffer.hpp&quot;
<span class="udiff-line-added">+ #include &quot;code/nativeInst.hpp&quot;</span>
  #include &quot;code/vtableStubs.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120,18 +121,17 @@</span>
  static FILETIME process_user_time;
  static FILETIME process_kernel_time;
  
  #ifdef _M_AMD64
    #define __CPU__ amd64
<span class="udiff-line-added">+ #elif defined _M_ARM64</span>
<span class="udiff-line-added">+   #define __CPU__ aarch64</span>
  #else
    #define __CPU__ i486
  #endif
  
<span class="udiff-line-removed">- #if INCLUDE_AOT</span>
  PVOID  topLevelVectoredExceptionHandler = NULL;
<span class="udiff-line-removed">- LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);</span>
<span class="udiff-line-removed">- #endif</span>
  
  // save DLL module handle, used by GetModuleFileName
  
  HINSTANCE vm_lib_handle;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -147,16 +147,14 @@</span>
      break;
    case DLL_PROCESS_DETACH:
      if (ForceTimeHighResolution) {
        timeEndPeriod(1L);
      }
<span class="udiff-line-removed">- #if INCLUDE_AOT</span>
      if (topLevelVectoredExceptionHandler != NULL) {
        RemoveVectoredExceptionHandler(topLevelVectoredExceptionHandler);
        topLevelVectoredExceptionHandler = NULL;
      }
<span class="udiff-line-removed">- #endif</span>
      break;
    default:
      break;
    }
    return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -420,12 +418,10 @@</span>
      return res;
    }
    return NULL;
  }
  
<span class="udiff-line-removed">- LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);</span>
<span class="udiff-line-removed">- </span>
  // Thread start routine for all newly created threads
  static unsigned __stdcall thread_native_entry(Thread* thread) {
  
    thread-&gt;record_stack_base_and_size();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -456,19 +452,14 @@</span>
      res = 20115;    // java thread
    }
  
    log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
  
<span class="udiff-line-modified-removed">-   // Install a win32 structured exception handler around every thread created</span>
<span class="udiff-line-modified-removed">-   // by VM, so VM can generate error dump when an exception occurred in non-</span>
<span class="udiff-line-modified-removed">-   // Java thread (e.g. VM thread).</span>
<span class="udiff-line-modified-removed">-   __try {</span>
<span class="udiff-line-removed">-     thread-&gt;call_run();</span>
<span class="udiff-line-removed">-   } __except(topLevelExceptionFilter(</span>
<span class="udiff-line-removed">-                                      (_EXCEPTION_POINTERS*)_exception_info())) {</span>
<span class="udiff-line-removed">-     // Nothing to do.</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   // Any exception is caught by the Vectored Exception Handler, so VM can</span>
<span class="udiff-line-modified-added">+   // generate error dump when an exception occurred in non-Java thread</span>
<span class="udiff-line-modified-added">+   // (e.g. VM thread).</span>
<span class="udiff-line-modified-added">+   thread-&gt;call_run();</span>
  
    // Note: at this point the thread object may already have deleted itself.
    // Do not dereference it from here on out.
  
    log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1427,19 +1418,22 @@</span>
      char* arch_name;
    } arch_t;
  
    static const arch_t arch_array[] = {
      {IMAGE_FILE_MACHINE_I386,      (char*)&quot;IA 32&quot;},
<span class="udiff-line-modified-removed">-     {IMAGE_FILE_MACHINE_AMD64,     (char*)&quot;AMD 64&quot;}</span>
<span class="udiff-line-modified-added">+     {IMAGE_FILE_MACHINE_AMD64,     (char*)&quot;AMD 64&quot;},</span>
<span class="udiff-line-added">+     {IMAGE_FILE_MACHINE_ARM64,	   (char*)&quot;ARM 64&quot;}</span>
    };
  #if (defined _M_AMD64)
    static const uint16_t running_arch = IMAGE_FILE_MACHINE_AMD64;
  #elif (defined _M_IX86)
    static const uint16_t running_arch = IMAGE_FILE_MACHINE_I386;
<span class="udiff-line-added">+ #elif (defined _M_ARM64)</span>
<span class="udiff-line-added">+   static const uint16_t running_arch = IMAGE_FILE_MACHINE_ARM64;</span>
  #else
    #error Method os::dll_load requires that one of following \
<span class="udiff-line-modified-removed">-          is defined :_M_AMD64 or _M_IX86</span>
<span class="udiff-line-modified-added">+          is defined :_M_AMD64 or _M_IX86 or _M_ARM64</span>
  #endif
  
  
    // Obtain a string for printf operation
    // lib_arch_str shall contain string what platform this .dll was built for
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1732,11 +1726,12 @@</span>
    // Retrieve SYSTEM_INFO from GetNativeSystemInfo call so that we could
    // find out whether we are running on 64 bit processor or not
    SYSTEM_INFO si;
    ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
    GetNativeSystemInfo(&amp;si);
<span class="udiff-line-modified-removed">-   if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {</span>
<span class="udiff-line-modified-added">+   if ((si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) ||</span>
<span class="udiff-line-added">+       (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ARM64)) {</span>
      st-&gt;print(&quot; , 64 bit&quot;);
    }
  
    st-&gt;print(&quot; Build %d&quot;, build_number);
    st-&gt;print(&quot; (%d.%d.%d.%d)&quot;, major_version, minor_version, build_number, build_minor);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2147,10 +2142,17 @@</span>
    if (thread) {
      thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Rip);
    }
    // Set pc to handler
    exceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)handler;
<span class="udiff-line-added">+ #elif defined(_M_ARM64)</span>
<span class="udiff-line-added">+   // Do not blow up if no thread info available.</span>
<span class="udiff-line-added">+   if (thread) {</span>
<span class="udiff-line-added">+     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Pc);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Set pc to handler</span>
<span class="udiff-line-added">+   exceptionInfo-&gt;ContextRecord-&gt;Pc = (DWORD64)handler;</span>
  #else
    // Do not blow up if no thread info available.
    if (thread) {
      thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Eip);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2254,10 +2256,20 @@</span>
    // Do not set ctx-&gt;Rax as it already contains the correct value (either 32 or 64 bit, depending on the operation)
    // this is the case because the exception only happens for -MinValue/-1 and -MinValue is always in rax because of the
    // idiv opcode (0xF7).
    ctx-&gt;Rdx = (DWORD)0;             // remainder
    // Continue the execution
<span class="udiff-line-added">+ #elif defined(_M_ARM64)</span>
<span class="udiff-line-added">+   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;</span>
<span class="udiff-line-added">+   address pc = (address)ctx-&gt;Sp;</span>
<span class="udiff-line-added">+   assert(pc[0] == 0x83, &quot;not an sdiv opcode&quot;); //Fixme did i get the right opcode?</span>
<span class="udiff-line-added">+   assert(ctx-&gt;X4 == min_jint, &quot;unexpected idiv exception&quot;);</span>
<span class="udiff-line-added">+   // set correct result values and continue after idiv instruction</span>
<span class="udiff-line-added">+   ctx-&gt;Pc = (uint64_t)pc + 4;        // idiv reg, reg, reg  is 4 bytes</span>
<span class="udiff-line-added">+   ctx-&gt;X4 = (uint64_t)min_jint;      // result</span>
<span class="udiff-line-added">+   ctx-&gt;X5 = (uint64_t)0;             // remainder</span>
<span class="udiff-line-added">+   // Continue the execution</span>
  #else
    PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
    address pc = (address)ctx-&gt;Eip;
    assert(pc[0] == 0xF7, &quot;not an idiv opcode&quot;);
    assert((pc[1] &amp; ~0x7) == 0xF8, &quot;cannot handle non-register operands&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2269,10 +2281,11 @@</span>
    // Continue the execution
  #endif
    return EXCEPTION_CONTINUE_EXECUTION;
  }
  
<span class="udiff-line-added">+ #if defined(_M_AMD64) || defined(_M_IX86)</span>
  //-----------------------------------------------------------------------------
  LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
    PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
  #ifndef  _WIN64
    // handle exception caused by native method modifying control word
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2314,78 +2327,31 @@</span>
    }
  #endif // !_WIN64
  
    return EXCEPTION_CONTINUE_SEARCH;
  }
<span class="udiff-line-added">+ #endif</span>
  
<span class="udiff-line-modified-removed">- static inline void report_error(Thread* t, DWORD exception_code,</span>
<span class="udiff-line-modified-added">+ void report_error(Thread* t, DWORD exception_code,</span>
<span class="udiff-line-added">+                                 address addr, void* siginfo, void* context);</span>
<span class="udiff-line-added">+ void report_error(Thread* t, DWORD exception_code,</span>
                                  address addr, void* siginfo, void* context) {
    VMError::report_and_die(t, exception_code, addr, siginfo, context);
  
    // If UseOsErrorReporting, this will return here and save the error file
    // somewhere where we can find it in the minidump.
  }
  
<span class="udiff-line-removed">- bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,</span>
<span class="udiff-line-removed">-         struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {</span>
<span class="udiff-line-removed">-   PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="udiff-line-removed">-   address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
<span class="udiff-line-removed">-   if (Interpreter::contains(pc)) {</span>
<span class="udiff-line-removed">-     *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);</span>
<span class="udiff-line-removed">-     if (!fr-&gt;is_first_java_frame()) {</span>
<span class="udiff-line-removed">-       // get_frame_at_stack_banging_point() is only called when we</span>
<span class="udiff-line-removed">-       // have well defined stacks so java_sender() calls do not need</span>
<span class="udiff-line-removed">-       // to assert safe_for_sender() first.</span>
<span class="udiff-line-removed">-       *fr = fr-&gt;java_sender();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // more complex code with compiled code</span>
<span class="udiff-line-removed">-     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);</span>
<span class="udiff-line-removed">-     CodeBlob* cb = CodeCache::find_blob(pc);</span>
<span class="udiff-line-removed">-     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {</span>
<span class="udiff-line-removed">-       // Not sure where the pc points to, fallback to default</span>
<span class="udiff-line-removed">-       // stack overflow handling</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);</span>
<span class="udiff-line-removed">-       // in compiled code, the stack banging is performed just after the return pc</span>
<span class="udiff-line-removed">-       // has been pushed on the stack</span>
<span class="udiff-line-removed">-       *fr = frame(fr-&gt;sp() + 1, fr-&gt;fp(), (address)*(fr-&gt;sp()));</span>
<span class="udiff-line-removed">-       if (!fr-&gt;is_java_frame()) {</span>
<span class="udiff-line-removed">-         // See java_sender() comment above.</span>
<span class="udiff-line-removed">-         *fr = fr-&gt;java_sender();</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if INCLUDE_AOT</span>
<span class="udiff-line-removed">- LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {</span>
<span class="udiff-line-removed">-   PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="udiff-line-removed">-   address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
<span class="udiff-line-removed">-   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Handle the case where we get an implicit exception in AOT generated</span>
<span class="udiff-line-removed">-   // code.  AOT DLL&#39;s loaded are not registered for structured exceptions.</span>
<span class="udiff-line-removed">-   // If the exception occurred in the codeCache or AOT code, pass control</span>
<span class="udiff-line-removed">-   // to our normal exception handler.</span>
<span class="udiff-line-removed">-   CodeBlob* cb = CodeCache::find_blob(pc);</span>
<span class="udiff-line-removed">-   if (cb != NULL) {</span>
<span class="udiff-line-removed">-     return topLevelExceptionFilter(exceptionInfo);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return EXCEPTION_CONTINUE_SEARCH;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  //-----------------------------------------------------------------------------
  LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
    if (InterceptOSException) return EXCEPTION_CONTINUE_SEARCH;
    DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
<span class="udiff-line-modified-removed">- #ifdef _M_AMD64</span>
<span class="udiff-line-modified-added">+   PEXCEPTION_RECORD exception_record = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="udiff-line-added">+   address addr = (address) exception_record-&gt;ExceptionInformation[1];</span>
<span class="udiff-line-added">+ #if defined(_M_ARM64)</span>
<span class="udiff-line-added">+   address pc = (address)exceptionInfo-&gt;ContextRecord-&gt;Pc;</span>
<span class="udiff-line-added">+ #elif defined(_M_AMD64)</span>
    address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;
  #else
    address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
  #endif
    Thread* t = Thread::current_or_null_safe();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2399,13 +2365,11 @@</span>
    // Execution protection violation - win32 running on AMD64 only
    // Handled first to avoid misdiagnosis as a &quot;normal&quot; access violation;
    // This is safe to do because we have a new/unique ExceptionInformation
    // code for this condition.
    if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
<span class="udiff-line-modified-removed">-     PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="udiff-line-removed">-     int exception_subcode = (int) exceptionRecord-&gt;ExceptionInformation[0];</span>
<span class="udiff-line-removed">-     address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
<span class="udiff-line-modified-added">+     int exception_subcode = (int) exception_record-&gt;ExceptionInformation[0];</span>
  
      if (exception_subcode == EXCEPTION_INFO_EXEC_VIOLATION) {
        int page_size = os::vm_page_size();
  
        // Make sure the pc and the faulting address are sane.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2472,36 +2436,39 @@</span>
        return EXCEPTION_CONTINUE_SEARCH;
      }
    }
  #endif // _WIN64
  
<span class="udiff-line-added">+ #if defined(_M_AMD64) || defined(_M_IX86)</span>
    if ((exception_code == EXCEPTION_ACCESS_VIOLATION) &amp;&amp;
        VM_Version::is_cpuinfo_segv_addr(pc)) {
      // Verify that OS save/restore AVX registers.
      return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr());
    }
<span class="udiff-line-added">+ #endif</span>
  
    if (t != NULL &amp;&amp; t-&gt;is_Java_thread()) {
      JavaThread* thread = (JavaThread*) t;
      bool in_java = thread-&gt;thread_state() == _thread_in_Java;
<span class="udiff-line-added">+     bool in_native = thread-&gt;thread_state() == _thread_in_native;</span>
<span class="udiff-line-added">+     bool in_vm = thread-&gt;thread_state() == _thread_in_vm;</span>
<span class="udiff-line-added">+     CodeBlob* cb = in_java ? CodeCache::find_blob_unsafe(pc) : NULL;</span>
  
      // Handle potential stack overflows up front.
      if (exception_code == EXCEPTION_STACK_OVERFLOW) {
        if (thread-&gt;stack_guards_enabled()) {
          if (in_java) {
            frame fr;
<span class="udiff-line-removed">-           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="udiff-line-removed">-           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
            if (os::win32::get_frame_at_stack_banging_point(thread, exceptionInfo, pc, &amp;fr)) {
              assert(fr.is_java_frame(), &quot;Must be a Java frame&quot;);
              SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
            }
          }
          // Yellow zone violation.  The o/s has unprotected the first yellow
          // zone page for us.  Note:  must call disable_stack_yellow_zone to
          // update the enabled status, even if the zone contains only one page.
<span class="udiff-line-modified-removed">-         assert(thread-&gt;thread_state() != _thread_in_vm, &quot;Undersized StackShadowPages&quot;);</span>
<span class="udiff-line-modified-added">+         assert(!in_vm, &quot;Undersized StackShadowPages&quot;);</span>
          thread-&gt;disable_stack_yellow_reserved_zone();
          // If not in java code, return and hope for the best.
          return in_java
              ? Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW))
              :  EXCEPTION_CONTINUE_EXECUTION;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2512,14 +2479,12 @@</span>
          report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
                        exceptionInfo-&gt;ContextRecord);
          return EXCEPTION_CONTINUE_SEARCH;
        }
      } else if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
<span class="udiff-line-removed">-       // Either stack overflow or null pointer exception.</span>
        if (in_java) {
<span class="udiff-line-modified-removed">-         PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="udiff-line-removed">-         address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
<span class="udiff-line-modified-added">+         // Either stack overflow or null pointer exception.</span>
          address stack_end = thread-&gt;stack_end();
          if (addr &lt; stack_end &amp;&amp; addr &gt;= stack_end - os::vm_page_size()) {
            // Stack overflow.
            assert(!os::uses_stack_guard_pages(),
                   &quot;should be caught by red zone code above.&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2527,101 +2492,104 @@</span>
                                    SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW));
          }
          // Check for safepoint polling and implicit null
          // We only expect null pointers in the stubs (vtable)
          // the rest are checked explicitly now.
<span class="udiff-line-removed">-         CodeBlob* cb = CodeCache::find_blob(pc);</span>
          if (cb != NULL) {
            if (os::is_poll_address(addr)) {
              address stub = SharedRuntime::get_poll_stub(pc);
              return Handle_Exception(exceptionInfo, stub);
            }
          }
<span class="udiff-line-removed">-         {</span>
  #ifdef _WIN64
<span class="udiff-line-modified-removed">-           // If it&#39;s a legal stack address map the entire region in</span>
<span class="udiff-line-modified-removed">-           //</span>
<span class="udiff-line-modified-removed">-           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="udiff-line-modified-removed">-           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
<span class="udiff-line-modified-removed">-           if (addr &gt; thread-&gt;stack_reserved_zone_base() &amp;&amp; addr &lt; thread-&gt;stack_base()) {</span>
<span class="udiff-line-modified-removed">-             addr = (address)((uintptr_t)addr &amp;</span>
<span class="udiff-line-modified-removed">-                              (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));</span>
<span class="udiff-line-removed">-             os::commit_memory((char *)addr, thread-&gt;stack_base() - addr,</span>
<span class="udiff-line-removed">-                               !ExecMem);</span>
<span class="udiff-line-removed">-             return EXCEPTION_CONTINUE_EXECUTION;</span>
<span class="udiff-line-removed">-           } else</span>
<span class="udiff-line-modified-added">+         // If it&#39;s a legal stack address map the entire region in</span>
<span class="udiff-line-modified-added">+         //</span>
<span class="udiff-line-modified-added">+         if (addr &gt; thread-&gt;stack_reserved_zone_base() &amp;&amp; addr &lt; thread-&gt;stack_base()) {</span>
<span class="udiff-line-modified-added">+           addr = (address)((uintptr_t)addr &amp; (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));</span>
<span class="udiff-line-modified-added">+           os::commit_memory((char *)addr, thread-&gt;stack_base() - addr, !ExecMem);</span>
<span class="udiff-line-modified-added">+           return EXCEPTION_CONTINUE_EXECUTION;</span>
<span class="udiff-line-modified-added">+         }</span>
  #endif
<span class="udiff-line-modified-removed">-           {</span>
<span class="udiff-line-modified-removed">-             // Null pointer exception.</span>
<span class="udiff-line-modified-removed">-             if (MacroAssembler::uses_implicit_null_check((void*)addr)) {</span>
<span class="udiff-line-modified-removed">-               address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);</span>
<span class="udiff-line-modified-removed">-               if (stub != NULL) return Handle_Exception(exceptionInfo, stub);</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,</span>
<span class="udiff-line-modified-removed">-                          exceptionInfo-&gt;ContextRecord);</span>
<span class="udiff-line-modified-removed">-             return EXCEPTION_CONTINUE_SEARCH;</span>
<span class="udiff-line-modified-removed">-           }</span>
<span class="udiff-line-modified-added">+         // Null pointer exception.</span>
<span class="udiff-line-modified-added">+         if (MacroAssembler::uses_implicit_null_check((void*)addr)) {</span>
<span class="udiff-line-modified-added">+           address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);</span>
<span class="udiff-line-modified-added">+           if (stub != NULL) return Handle_Exception(exceptionInfo, stub);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Unsafe memory access</span>
<span class="udiff-line-modified-added">+       CompiledMethod* nm = cb != NULL ? cb-&gt;as_compiled_method_or_null() : NULL;</span>
<span class="udiff-line-modified-added">+       bool is_unsafe_arraycopy = (in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);</span>
<span class="udiff-line-added">+       if (is_unsafe_arraycopy ||</span>
<span class="udiff-line-added">+           ((in_native || in_vm) &amp;&amp; thread-&gt;doing_unsafe_access()) ||</span>
<span class="udiff-line-added">+           (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {</span>
<span class="udiff-line-added">+         address next_pc =  Assembler::locate_next_instruction(pc);</span>
<span class="udiff-line-added">+         if (is_unsafe_arraycopy) {</span>
<span class="udiff-line-added">+           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
          }
<span class="udiff-line-added">+         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, next_pc));</span>
        }
  
  #ifdef _WIN64
        // Special care for fast JNI field accessors.
        // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks
        // in and the heap gets shrunk before the field access.
<span class="udiff-line-modified-removed">-       if (exception_code == EXCEPTION_ACCESS_VIOLATION) {</span>
<span class="udiff-line-modified-removed">-         address addr = JNI_FastGetField::find_slowcase_pc(pc);</span>
<span class="udiff-line-modified-removed">-         if (addr != (address)-1) {</span>
<span class="udiff-line-removed">-           return Handle_Exception(exceptionInfo, addr);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+       address slowcase_pc = JNI_FastGetField::find_slowcase_pc(pc);</span>
<span class="udiff-line-modified-added">+       if (slowcase_pc != (address)-1) {</span>
<span class="udiff-line-modified-added">+         return Handle_Exception(exceptionInfo, slowcase_pc);</span>
        }
  #endif
  
        // Stack overflow or null pointer exception in native code.
        report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
                     exceptionInfo-&gt;ContextRecord);
        return EXCEPTION_CONTINUE_SEARCH;
<span class="udiff-line-modified-removed">-     } // /EXCEPTION_ACCESS_VIOLATION</span>
<span class="udiff-line-modified-removed">-     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (exception_code == EXCEPTION_IN_PAGE_ERROR) {</span>
<span class="udiff-line-removed">-       CompiledMethod* nm = NULL;</span>
<span class="udiff-line-removed">-       JavaThread* thread = (JavaThread*)t;</span>
<span class="udiff-line-removed">-       if (in_java) {</span>
<span class="udiff-line-removed">-         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);</span>
<span class="udiff-line-removed">-         nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       bool is_unsafe_arraycopy = (thread-&gt;thread_state() == _thread_in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);</span>
<span class="udiff-line-removed">-       if (((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="udiff-line-removed">-            thread-&gt;thread_state() == _thread_in_native ||</span>
<span class="udiff-line-removed">-            is_unsafe_arraycopy) &amp;&amp;</span>
<span class="udiff-line-removed">-           thread-&gt;doing_unsafe_access()) ||</span>
<span class="udiff-line-modified-added">+     } else if (exception_code == EXCEPTION_IN_PAGE_ERROR) {</span>
<span class="udiff-line-modified-added">+       CompiledMethod* nm = cb != NULL ? cb-&gt;as_compiled_method_or_null() : NULL;</span>
<span class="udiff-line-modified-added">+       bool is_unsafe_arraycopy = (in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);</span>
<span class="udiff-line-modified-added">+       if (((in_vm || in_native || is_unsafe_arraycopy) &amp;&amp; thread-&gt;doing_unsafe_access()) ||</span>
            (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {
          address next_pc =  Assembler::locate_next_instruction(pc);
          if (is_unsafe_arraycopy) {
            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
          }
          return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, next_pc));
        }
      }
  
<span class="udiff-line-added">+ #ifdef _M_ARM64</span>
<span class="udiff-line-added">+     if (in_java &amp;&amp;</span>
<span class="udiff-line-added">+         (exception_code == EXCEPTION_ILLEGAL_INSTRUCTION ||</span>
<span class="udiff-line-added">+           exception_code == EXCEPTION_ILLEGAL_INSTRUCTION_2)) {</span>
<span class="udiff-line-added">+       if (nativeInstruction_at(pc)-&gt;is_sigill_zombie_not_entrant()) {</span>
<span class="udiff-line-added">+         if (TraceTraps) {</span>
<span class="udiff-line-added">+           tty-&gt;print_cr(&quot;trap: zombie_not_entrant&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return Handle_Exception(exceptionInfo, SharedRuntime::get_handle_wrong_method_stub());</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      if (in_java) {
        switch (exception_code) {
        case EXCEPTION_INT_DIVIDE_BY_ZERO:
          return Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO));
  
        case EXCEPTION_INT_OVERFLOW:
          return Handle_IDiv_Exception(exceptionInfo);
  
        } // switch
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(_M_AMD64) || defined(_M_IX86)</span>
      if (((thread-&gt;thread_state() == _thread_in_Java) ||
           (thread-&gt;thread_state() == _thread_in_native)) &amp;&amp;
           exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
        LONG result=Handle_FLT_Exception(exceptionInfo);
        if (result==EXCEPTION_CONTINUE_EXECUTION) return result;
      }
<span class="udiff-line-added">+ #endif</span>
    }
  
    if (exception_code != EXCEPTION_BREAKPOINT) {
      report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
                   exceptionInfo-&gt;ContextRecord);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3469,11 +3437,16 @@</span>
  
  char* os::non_memory_address_word() {
    // Must never look like an address returned by reserve_memory,
    // even in its subfields (as defined by the CPU immediate fields,
    // if the CPU splits constants across multiple instructions).
<span class="udiff-line-added">+ #ifdef _M_ARM64</span>
<span class="udiff-line-added">+   // AArch64 has a maximum addressable space of 48-bits</span>
<span class="udiff-line-added">+   return (char*)((1ull &lt;&lt; 48) - 1);</span>
<span class="udiff-line-added">+ #else</span>
    return (char*)-1;
<span class="udiff-line-added">+ #endif</span>
  }
  
  #define MAX_ERROR_COUNT 100
  #define SYS_THREAD_ERROR 0xffffffffUL
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3665,10 +3638,38 @@</span>
           &quot;stack size not a multiple of page size&quot;);
  
    initialize_performance_counter();
  }
  
<span class="udiff-line-added">+ int os::win32::get_cacheline_size() {</span>
<span class="udiff-line-added">+   PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;</span>
<span class="udiff-line-added">+   DWORD returnLength = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // See https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GetLogicalProcessorInformation(NULL, &amp;returnLength);</span>
<span class="udiff-line-added">+   assert(GetLastError() == ERROR_INSUFFICIENT_BUFFER, &quot;Unexpected return from GetLogicalProcessorInformation&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)os::malloc(returnLength, mtInternal);</span>
<span class="udiff-line-added">+   BOOL rc = GetLogicalProcessorInformation(buffer, &amp;returnLength);</span>
<span class="udiff-line-added">+   assert(rc, &quot;Unexpected return from GetLogicalProcessorInformation&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int line_sz = -1;</span>
<span class="udiff-line-added">+   for (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = buffer; ptr &lt; buffer + returnLength / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); ptr++) {</span>
<span class="udiff-line-added">+     switch (ptr-&gt;Relationship) {</span>
<span class="udiff-line-added">+     case RelationCache:</span>
<span class="udiff-line-added">+       // Cache data is in ptr-&gt;Cache, one CACHE_DESCRIPTOR structure for each cache.</span>
<span class="udiff-line-added">+       PCACHE_DESCRIPTOR Cache = &amp;ptr-&gt;Cache;</span>
<span class="udiff-line-added">+       if (Cache-&gt;Level == 1) {</span>
<span class="udiff-line-added">+         line_sz = Cache-&gt;LineSize;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   os::free(buffer);</span>
<span class="udiff-line-added">+   return line_sz;</span>
<span class="udiff-line-added">+ }</span>
  
  HINSTANCE os::win32::load_Windows_dll(const char* name, char *ebuf,
                                        int ebuflen) {
    char path[MAX_PATH];
    DWORD size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3992,20 +3993,11 @@</span>
    // This could be set any time but all platforms
    // have to set it the same so we have to mirror Solaris.
    DEBUG_ONLY(os::set_mutex_init_done();)
  
    // Setup Windows Exceptions
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- #if INCLUDE_AOT</span>
<span class="udiff-line-removed">-   // If AOT is enabled we need to install a vectored exception handler</span>
<span class="udiff-line-removed">-   // in order to forward implicit exceptions from code in AOT</span>
<span class="udiff-line-removed">-   // generated DLLs.  This is necessary since these DLLs are not</span>
<span class="udiff-line-removed">-   // registered for structured exceptions like codecache methods are.</span>
<span class="udiff-line-removed">-   if (AOTLibrary != NULL &amp;&amp; (UseAOT || FLAG_IS_DEFAULT(UseAOT))) {</span>
<span class="udiff-line-removed">-     topLevelVectoredExceptionHandler = AddVectoredExceptionHandler( 1, topLevelVectoredExceptionFilter);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   topLevelVectoredExceptionHandler = AddVectoredExceptionHandler(1, topLevelExceptionFilter);</span>
  
    // for debugging float code generation bugs
    if (ForceFloatExceptions) {
  #ifndef  _WIN64
      static long fp_control_word = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4096,11 +4088,11 @@</span>
  
    if (UseNUMA &amp;&amp; !ForceNUMA) {
      UseNUMA = false; // We don&#39;t fully support this yet
    }
  
<span class="udiff-line-modified-removed">-   if (UseNUMAInterleaving) {</span>
<span class="udiff-line-modified-added">+   if (UseNUMA) {</span>
      // first check whether this Windows OS supports VirtualAllocExNuma, if not ignore this flag
      bool success = numa_interleaving_init();
      if (!success) UseNUMAInterleaving = false;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5444,11 +5436,11 @@</span>
  }
  
  // WINDOWS CONTEXT Flags for THREAD_SAMPLING
  #if defined(IA32)
    #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS)
<span class="udiff-line-modified-removed">- #elif defined (AMD64)</span>
<span class="udiff-line-modified-added">+ #elif defined(AMD64) || defined(_M_ARM64)</span>
    #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
  #endif
  
  // returns true if thread could be suspended,
  // false otherwise
</pre>
<center><a href="osThread_windows.hpp.udiff.html" target="_top">&lt; prev</a> <a href="..\..\..\..\index.html" target="_top">index</a> <a href="os_windows.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>