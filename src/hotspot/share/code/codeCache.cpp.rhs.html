<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src\hotspot\share\code\codeCache.cpp</title>
    <link rel="stylesheet" href="..\..\..\..\style.css" />
    <script type="text/javascript" src="..\..\..\..\navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;code/codeBlob.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/codeHeapState.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;code/dependencies.hpp&quot;
  32 #include &quot;code/dependencyContext.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/nmethod.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;compiler/compilationPolicy.hpp&quot;
  37 #include &quot;compiler/compileBroker.hpp&quot;
  38 #include &quot;jfr/jfrEvents.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;logging/logStream.hpp&quot;
  41 #include &quot;memory/allocation.inline.hpp&quot;
  42 #include &quot;memory/iterator.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/method.inline.hpp&quot;
  46 #include &quot;oops/objArrayOop.hpp&quot;
  47 #include &quot;oops/oop.inline.hpp&quot;
  48 #include &quot;oops/verifyOopClosure.hpp&quot;
  49 #include &quot;runtime/arguments.hpp&quot;
  50 #include &quot;runtime/atomic.hpp&quot;
  51 #include &quot;runtime/deoptimization.hpp&quot;
  52 #include &quot;runtime/handles.inline.hpp&quot;
  53 #include &quot;runtime/icache.hpp&quot;
  54 #include &quot;runtime/java.hpp&quot;
  55 #include &quot;runtime/mutexLocker.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/sweeper.hpp&quot;
  58 #include &quot;runtime/vmThread.hpp&quot;
  59 #include &quot;services/memoryService.hpp&quot;
  60 #include &quot;utilities/align.hpp&quot;
  61 #include &quot;utilities/vmError.hpp&quot;
  62 #include &quot;utilities/xmlstream.hpp&quot;
  63 #ifdef COMPILER1
  64 #include &quot;c1/c1_Compilation.hpp&quot;
  65 #include &quot;c1/c1_Compiler.hpp&quot;
  66 #endif
  67 #ifdef COMPILER2
  68 #include &quot;opto/c2compiler.hpp&quot;
  69 #include &quot;opto/compile.hpp&quot;
  70 #include &quot;opto/node.hpp&quot;
  71 #endif
  72 
  73 // Helper class for printing in CodeCache
  74 class CodeBlob_sizes {
  75  private:
  76   int count;
  77   int total_size;
  78   int header_size;
  79   int code_size;
  80   int stub_size;
  81   int relocation_size;
  82   int scopes_oop_size;
  83   int scopes_metadata_size;
  84   int scopes_data_size;
  85   int scopes_pcs_size;
  86 
  87  public:
  88   CodeBlob_sizes() {
  89     count            = 0;
  90     total_size       = 0;
  91     header_size      = 0;
  92     code_size        = 0;
  93     stub_size        = 0;
  94     relocation_size  = 0;
  95     scopes_oop_size  = 0;
  96     scopes_metadata_size  = 0;
  97     scopes_data_size = 0;
  98     scopes_pcs_size  = 0;
  99   }
 100 
 101   int total()                                    { return total_size; }
 102   bool is_empty()                                { return count == 0; }
 103 
 104   void print(const char* title) {
 105     tty-&gt;print_cr(&quot; #%d %s = %dK (hdr %d%%,  loc %d%%, code %d%%, stub %d%%, [oops %d%%, metadata %d%%, data %d%%, pcs %d%%])&quot;,
 106                   count,
 107                   title,
 108                   (int)(total() / K),
 109                   header_size             * 100 / total_size,
 110                   relocation_size         * 100 / total_size,
 111                   code_size               * 100 / total_size,
 112                   stub_size               * 100 / total_size,
 113                   scopes_oop_size         * 100 / total_size,
 114                   scopes_metadata_size    * 100 / total_size,
 115                   scopes_data_size        * 100 / total_size,
 116                   scopes_pcs_size         * 100 / total_size);
 117   }
 118 
 119   void add(CodeBlob* cb) {
 120     count++;
 121     total_size       += cb-&gt;size();
 122     header_size      += cb-&gt;header_size();
 123     relocation_size  += cb-&gt;relocation_size();
 124     if (cb-&gt;is_nmethod()) {
 125       nmethod* nm = cb-&gt;as_nmethod_or_null();
 126       code_size        += nm-&gt;insts_size();
 127       stub_size        += nm-&gt;stub_size();
 128 
 129       scopes_oop_size  += nm-&gt;oops_size();
 130       scopes_metadata_size  += nm-&gt;metadata_size();
 131       scopes_data_size += nm-&gt;scopes_data_size();
 132       scopes_pcs_size  += nm-&gt;scopes_pcs_size();
 133     } else {
 134       code_size        += cb-&gt;code_size();
 135     }
 136   }
 137 };
 138 
 139 // Iterate over all CodeHeaps
 140 #define FOR_ALL_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _heaps-&gt;begin(); heap != _heaps-&gt;end(); ++heap)
 141 #define FOR_ALL_NMETHOD_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _nmethod_heaps-&gt;begin(); heap != _nmethod_heaps-&gt;end(); ++heap)
 142 #define FOR_ALL_ALLOCABLE_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _allocable_heaps-&gt;begin(); heap != _allocable_heaps-&gt;end(); ++heap)
 143 
 144 // Iterate over all CodeBlobs (cb) on the given CodeHeap
 145 #define FOR_ALL_BLOBS(cb, heap) for (CodeBlob* cb = first_blob(heap); cb != NULL; cb = next_blob(heap, cb))
 146 
 147 address CodeCache::_low_bound = 0;
 148 address CodeCache::_high_bound = 0;
 149 int CodeCache::_number_of_nmethods_with_dependencies = 0;
 150 ExceptionCache* volatile CodeCache::_exception_cache_purge_list = NULL;
 151 
 152 // Initialize arrays of CodeHeap subsets
 153 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);
 154 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_compiled_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);
 155 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_nmethod_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);
 156 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_allocable_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);
 157 
 158 void CodeCache::check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set) {
 159   size_t total_size = non_nmethod_size + profiled_size + non_profiled_size;
 160   // Prepare error message
 161   const char* error = &quot;Invalid code heap sizes&quot;;
 162   err_msg message(&quot;NonNMethodCodeHeapSize (&quot; SIZE_FORMAT &quot;K) + ProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K)&quot;
 163                   &quot; + NonProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K) = &quot; SIZE_FORMAT &quot;K&quot;,
 164           non_nmethod_size/K, profiled_size/K, non_profiled_size/K, total_size/K);
 165 
 166   if (total_size &gt; cache_size) {
 167     // Some code heap sizes were explicitly set: total_size must be &lt;= cache_size
 168     message.append(&quot; is greater than ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 169     vm_exit_during_initialization(error, message);
 170   } else if (all_set &amp;&amp; total_size != cache_size) {
 171     // All code heap sizes were explicitly set: total_size must equal cache_size
 172     message.append(&quot; is not equal to ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 173     vm_exit_during_initialization(error, message);
 174   }
 175 }
 176 
 177 void CodeCache::initialize_heaps() {
 178   bool non_nmethod_set      = FLAG_IS_CMDLINE(NonNMethodCodeHeapSize);
 179   bool profiled_set         = FLAG_IS_CMDLINE(ProfiledCodeHeapSize);
 180   bool non_profiled_set     = FLAG_IS_CMDLINE(NonProfiledCodeHeapSize);
 181   size_t min_size           = os::vm_page_size();
 182   size_t cache_size         = ReservedCodeCacheSize;
 183   size_t non_nmethod_size   = NonNMethodCodeHeapSize;
 184   size_t profiled_size      = ProfiledCodeHeapSize;
 185   size_t non_profiled_size  = NonProfiledCodeHeapSize;
 186   // Check if total size set via command line flags exceeds the reserved size
 187   check_heap_sizes((non_nmethod_set  ? non_nmethod_size  : min_size),
 188                    (profiled_set     ? profiled_size     : min_size),
 189                    (non_profiled_set ? non_profiled_size : min_size),
 190                    cache_size,
 191                    non_nmethod_set &amp;&amp; profiled_set &amp;&amp; non_profiled_set);
 192 
 193   // Determine size of compiler buffers
 194   size_t code_buffers_size = 0;
 195 #ifdef COMPILER1
 196   // C1 temporary code buffers (see Compiler::init_buffer_blob())
 197   const int c1_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_simple);
 198   code_buffers_size += c1_count * Compiler::code_buffer_size();
 199 #endif
 200 #ifdef COMPILER2
 201   // C2 scratch buffers (see Compile::init_scratch_buffer_blob())
 202   const int c2_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_full_optimization);
 203   // Initial size of constant table (this may be increased if a compiled method needs more space)
 204   code_buffers_size += c2_count * C2Compiler::initial_code_buffer_size();
 205 #endif
 206 
 207   // Increase default non_nmethod_size to account for compiler buffers
 208   if (!non_nmethod_set) {
 209     non_nmethod_size += code_buffers_size;
 210   }
 211   // Calculate default CodeHeap sizes if not set by user
 212   if (!non_nmethod_set &amp;&amp; !profiled_set &amp;&amp; !non_profiled_set) {
 213     // Check if we have enough space for the non-nmethod code heap
 214     if (cache_size &gt; non_nmethod_size) {
 215       // Use the default value for non_nmethod_size and one half of the
 216       // remaining size for non-profiled and one half for profiled methods
 217       size_t remaining_size = cache_size - non_nmethod_size;
 218       profiled_size = remaining_size / 2;
 219       non_profiled_size = remaining_size - profiled_size;
 220     } else {
 221       // Use all space for the non-nmethod heap and set other heaps to minimal size
 222       non_nmethod_size = cache_size - 2 * min_size;
 223       profiled_size = min_size;
 224       non_profiled_size = min_size;
 225     }
 226   } else if (!non_nmethod_set || !profiled_set || !non_profiled_set) {
 227     // The user explicitly set some code heap sizes. Increase or decrease the (default)
 228     // sizes of the other code heaps accordingly. First adapt non-profiled and profiled
 229     // code heap sizes and then only change non-nmethod code heap size if still necessary.
 230     intx diff_size = cache_size - (non_nmethod_size + profiled_size + non_profiled_size);
 231     if (non_profiled_set) {
 232       if (!profiled_set) {
 233         // Adapt size of profiled code heap
 234         if (diff_size &lt; 0 &amp;&amp; ((intx)profiled_size + diff_size) &lt;= 0) {
 235           // Not enough space available, set to minimum size
 236           diff_size += profiled_size - min_size;
 237           profiled_size = min_size;
 238         } else {
 239           profiled_size += diff_size;
 240           diff_size = 0;
 241         }
 242       }
 243     } else if (profiled_set) {
 244       // Adapt size of non-profiled code heap
 245       if (diff_size &lt; 0 &amp;&amp; ((intx)non_profiled_size + diff_size) &lt;= 0) {
 246         // Not enough space available, set to minimum size
 247         diff_size += non_profiled_size - min_size;
 248         non_profiled_size = min_size;
 249       } else {
 250         non_profiled_size += diff_size;
 251         diff_size = 0;
 252       }
 253     } else if (non_nmethod_set) {
 254       // Distribute remaining size between profiled and non-profiled code heaps
 255       diff_size = cache_size - non_nmethod_size;
 256       profiled_size = diff_size / 2;
 257       non_profiled_size = diff_size - profiled_size;
 258       diff_size = 0;
 259     }
 260     if (diff_size != 0) {
 261       // Use non-nmethod code heap for remaining space requirements
 262       assert(!non_nmethod_set &amp;&amp; ((intx)non_nmethod_size + diff_size) &gt; 0, &quot;sanity&quot;);
 263       non_nmethod_size += diff_size;
 264     }
 265   }
 266 
 267   // We do not need the profiled CodeHeap, use all space for the non-profiled CodeHeap
 268   if (!heap_available(CodeBlobType::MethodProfiled)) {
 269     non_profiled_size += profiled_size;
 270     profiled_size = 0;
 271   }
 272   // We do not need the non-profiled CodeHeap, use all space for the non-nmethod CodeHeap
 273   if (!heap_available(CodeBlobType::MethodNonProfiled)) {
 274     non_nmethod_size += non_profiled_size;
 275     non_profiled_size = 0;
 276   }
 277   // Make sure we have enough space for VM internal code
 278   uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);
 279   if (non_nmethod_size &lt; min_code_cache_size) {
 280     vm_exit_during_initialization(err_msg(
 281         &quot;Not enough space in non-nmethod code heap to run VM: &quot; SIZE_FORMAT &quot;K &lt; &quot; SIZE_FORMAT &quot;K&quot;,
 282         non_nmethod_size/K, min_code_cache_size/K));
 283   }
 284 
 285   // Verify sizes and update flag values
 286   assert(non_profiled_size + profiled_size + non_nmethod_size == cache_size, &quot;Invalid code heap sizes&quot;);
 287   FLAG_SET_ERGO(NonNMethodCodeHeapSize, non_nmethod_size);
 288   FLAG_SET_ERGO(ProfiledCodeHeapSize, profiled_size);
 289   FLAG_SET_ERGO(NonProfiledCodeHeapSize, non_profiled_size);
 290 
 291   // If large page support is enabled, align code heaps according to large
 292   // page size to make sure that code cache is covered by large pages.
 293   const size_t alignment = MAX2(page_size(false, 8), (size_t) os::vm_allocation_granularity());
 294   non_nmethod_size = align_up(non_nmethod_size, alignment);
 295   profiled_size    = align_down(profiled_size, alignment);
 296 
 297   // Reserve one continuous chunk of memory for CodeHeaps and split it into
 298   // parts for the individual heaps. The memory layout looks like this:
 299   // ---------- high -----------
 300   //    Non-profiled nmethods
 301   //      Profiled nmethods
 302   //         Non-nmethods
 303   // ---------- low ------------
 304   ReservedCodeSpace rs = reserve_heap_memory(cache_size);
 305   ReservedSpace non_method_space    = rs.first_part(non_nmethod_size);
 306   ReservedSpace rest                = rs.last_part(non_nmethod_size);
 307   ReservedSpace profiled_space      = rest.first_part(profiled_size);
 308   ReservedSpace non_profiled_space  = rest.last_part(profiled_size);
 309 
 310   // Non-nmethods (stubs, adapters, ...)
 311   add_heap(non_method_space, &quot;CodeHeap &#39;non-nmethods&#39;&quot;, CodeBlobType::NonNMethod);
 312   // Tier 2 and tier 3 (profiled) methods
 313   add_heap(profiled_space, &quot;CodeHeap &#39;profiled nmethods&#39;&quot;, CodeBlobType::MethodProfiled);
 314   // Tier 1 and tier 4 (non-profiled) methods and native methods
 315   add_heap(non_profiled_space, &quot;CodeHeap &#39;non-profiled nmethods&#39;&quot;, CodeBlobType::MethodNonProfiled);
 316 }
 317 
 318 size_t CodeCache::page_size(bool aligned, size_t min_pages) {
 319   if (os::can_execute_large_page_memory()) {
 320     if (InitialCodeCacheSize &lt; ReservedCodeCacheSize) {
 321       // Make sure that the page size allows for an incremental commit of the reserved space
 322       min_pages = MAX2(min_pages, (size_t)8);
 323     }
 324     return aligned ? os::page_size_for_region_aligned(ReservedCodeCacheSize, min_pages) :
 325                      os::page_size_for_region_unaligned(ReservedCodeCacheSize, min_pages);
 326   } else {
 327     return os::vm_page_size();
 328   }
 329 }
 330 
 331 ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size) {
 332   // Align and reserve space for code cache
 333   const size_t rs_ps = page_size();
 334   const size_t rs_align = MAX2(rs_ps, (size_t) os::vm_allocation_granularity());
 335   const size_t rs_size = align_up(size, rs_align);
 336   ReservedCodeSpace rs(rs_size, rs_align, rs_ps &gt; (size_t) os::vm_page_size());
 337   if (!rs.is_reserved()) {
 338     vm_exit_during_initialization(err_msg(&quot;Could not reserve enough space for code cache (&quot; SIZE_FORMAT &quot;K)&quot;,
 339                                           rs_size/K));
 340   }
 341 
 342   // Initialize bounds
 343   _low_bound = (address)rs.base();
 344   _high_bound = _low_bound + rs.size();
 345   return rs;
 346 }
 347 
 348 // Heaps available for allocation
 349 bool CodeCache::heap_available(int code_blob_type) {
 350   if (!SegmentedCodeCache) {
 351     // No segmentation: use a single code heap
 352     return (code_blob_type == CodeBlobType::All);
 353   } else if (Arguments::is_interpreter_only()) {
 354     // Interpreter only: we don&#39;t need any method code heaps
 355     return (code_blob_type == CodeBlobType::NonNMethod);
 356   } else if (TieredCompilation &amp;&amp; (TieredStopAtLevel &gt; CompLevel_simple)) {
 357     // Tiered compilation: use all code heaps
 358     return (code_blob_type &lt; CodeBlobType::All);
 359   } else {
 360     // No TieredCompilation: we only need the non-nmethod and non-profiled code heap
 361     return (code_blob_type == CodeBlobType::NonNMethod) ||
 362            (code_blob_type == CodeBlobType::MethodNonProfiled);
 363   }
 364 }
 365 
 366 const char* CodeCache::get_code_heap_flag_name(int code_blob_type) {
 367   switch(code_blob_type) {
 368   case CodeBlobType::NonNMethod:
 369     return &quot;NonNMethodCodeHeapSize&quot;;
 370     break;
 371   case CodeBlobType::MethodNonProfiled:
 372     return &quot;NonProfiledCodeHeapSize&quot;;
 373     break;
 374   case CodeBlobType::MethodProfiled:
 375     return &quot;ProfiledCodeHeapSize&quot;;
 376     break;
 377   }
 378   ShouldNotReachHere();
 379   return NULL;
 380 }
 381 
 382 int CodeCache::code_heap_compare(CodeHeap* const &amp;lhs, CodeHeap* const &amp;rhs) {
 383   if (lhs-&gt;code_blob_type() == rhs-&gt;code_blob_type()) {
 384     return (lhs &gt; rhs) ? 1 : ((lhs &lt; rhs) ? -1 : 0);
 385   } else {
 386     return lhs-&gt;code_blob_type() - rhs-&gt;code_blob_type();
 387   }
 388 }
 389 
 390 void CodeCache::add_heap(CodeHeap* heap) {
 391   assert(!Universe::is_fully_initialized(), &quot;late heap addition?&quot;);
 392 
 393   _heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 394 
 395   int type = heap-&gt;code_blob_type();
 396   if (code_blob_type_accepts_compiled(type)) {
 397     _compiled_heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 398   }
 399   if (code_blob_type_accepts_nmethod(type)) {
 400     _nmethod_heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 401   }
 402   if (code_blob_type_accepts_allocable(type)) {
 403     _allocable_heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 404   }
 405 }
 406 
 407 void CodeCache::add_heap(ReservedSpace rs, const char* name, int code_blob_type) {
 408   // Check if heap is needed
 409   if (!heap_available(code_blob_type)) {
 410     return;
 411   }
 412 
 413   // Create CodeHeap
 414   CodeHeap* heap = new CodeHeap(name, code_blob_type);
 415   add_heap(heap);
 416 
 417   // Reserve Space
 418   size_t size_initial = MIN2((size_t)InitialCodeCacheSize, rs.size());
 419   size_initial = align_up(size_initial, os::vm_page_size());
 420   if (!heap-&gt;reserve(rs, size_initial, CodeCacheSegmentSize)) {
 421     vm_exit_during_initialization(err_msg(&quot;Could not reserve enough space in %s (&quot; SIZE_FORMAT &quot;K)&quot;,
 422                                           heap-&gt;name(), size_initial/K));
 423   }
 424 
 425   // Register the CodeHeap
 426   MemoryService::add_code_heap_memory_pool(heap, name);
 427 }
 428 
 429 CodeHeap* CodeCache::get_code_heap_containing(void* start) {
 430   FOR_ALL_HEAPS(heap) {
 431     if ((*heap)-&gt;contains(start)) {
 432       return *heap;
 433     }
 434   }
 435   return NULL;
 436 }
 437 
 438 CodeHeap* CodeCache::get_code_heap(const CodeBlob* cb) {
 439   assert(cb != NULL, &quot;CodeBlob is null&quot;);
 440   FOR_ALL_HEAPS(heap) {
 441     if ((*heap)-&gt;contains_blob(cb)) {
 442       return *heap;
 443     }
 444   }
 445   ShouldNotReachHere();
 446   return NULL;
 447 }
 448 
 449 CodeHeap* CodeCache::get_code_heap(int code_blob_type) {
 450   FOR_ALL_HEAPS(heap) {
 451     if ((*heap)-&gt;accepts(code_blob_type)) {
 452       return *heap;
 453     }
 454   }
 455   return NULL;
 456 }
 457 
 458 CodeBlob* CodeCache::first_blob(CodeHeap* heap) {
 459   assert_locked_or_safepoint(CodeCache_lock);
 460   assert(heap != NULL, &quot;heap is null&quot;);
 461   return (CodeBlob*)heap-&gt;first();
 462 }
 463 
 464 CodeBlob* CodeCache::first_blob(int code_blob_type) {
 465   if (heap_available(code_blob_type)) {
 466     return first_blob(get_code_heap(code_blob_type));
 467   } else {
 468     return NULL;
 469   }
 470 }
 471 
 472 CodeBlob* CodeCache::next_blob(CodeHeap* heap, CodeBlob* cb) {
 473   assert_locked_or_safepoint(CodeCache_lock);
 474   assert(heap != NULL, &quot;heap is null&quot;);
 475   return (CodeBlob*)heap-&gt;next(cb);
 476 }
 477 
 478 /**
 479  * Do not seize the CodeCache lock here--if the caller has not
 480  * already done so, we are going to lose bigtime, since the code
 481  * cache will contain a garbage CodeBlob until the caller can
 482  * run the constructor for the CodeBlob subclass he is busy
 483  * instantiating.
 484  */
 485 CodeBlob* CodeCache::allocate(int size, int code_blob_type, int orig_code_blob_type) {
 486   // Possibly wakes up the sweeper thread.
 487   NMethodSweeper::notify(code_blob_type);
 488   assert_locked_or_safepoint(CodeCache_lock);
 489   assert(size &gt; 0, &quot;Code cache allocation request must be &gt; 0 but is %d&quot;, size);
 490   if (size &lt;= 0) {
 491     return NULL;
 492   }
 493   CodeBlob* cb = NULL;
 494 
 495   // Get CodeHeap for the given CodeBlobType
 496   CodeHeap* heap = get_code_heap(code_blob_type);
 497   assert(heap != NULL, &quot;heap is null&quot;);
 498 
 499   while (true) {
 500     cb = (CodeBlob*)heap-&gt;allocate(size);
 501     if (cb != NULL) break;
 502     if (!heap-&gt;expand_by(CodeCacheExpansionSize)) {
 503       // Save original type for error reporting
 504       if (orig_code_blob_type == CodeBlobType::All) {
 505         orig_code_blob_type = code_blob_type;
 506       }
 507       // Expansion failed
 508       if (SegmentedCodeCache) {
 509         // Fallback solution: Try to store code in another code heap.
 510         // NonNMethod -&gt; MethodNonProfiled -&gt; MethodProfiled (-&gt; MethodNonProfiled)
 511         // Note that in the sweeper, we check the reverse_free_ratio of the code heap
 512         // and force stack scanning if less than 10% of the code heap are free.
 513         int type = code_blob_type;
 514         switch (type) {
 515         case CodeBlobType::NonNMethod:
 516           type = CodeBlobType::MethodNonProfiled;
 517           break;
 518         case CodeBlobType::MethodNonProfiled:
 519           type = CodeBlobType::MethodProfiled;
 520           break;
 521         case CodeBlobType::MethodProfiled:
 522           // Avoid loop if we already tried that code heap
 523           if (type == orig_code_blob_type) {
 524             type = CodeBlobType::MethodNonProfiled;
 525           }
 526           break;
 527         }
 528         if (type != code_blob_type &amp;&amp; type != orig_code_blob_type &amp;&amp; heap_available(type)) {
 529           if (PrintCodeCacheExtension) {
 530             tty-&gt;print_cr(&quot;Extension of %s failed. Trying to allocate in %s.&quot;,
 531                           heap-&gt;name(), get_code_heap(type)-&gt;name());
 532           }
 533           return allocate(size, type, orig_code_blob_type);
 534         }
 535       }
 536       MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 537       CompileBroker::handle_full_code_cache(orig_code_blob_type);
 538       return NULL;
 539     }
 540     if (PrintCodeCacheExtension) {
 541       ResourceMark rm;
 542       if (_nmethod_heaps-&gt;length() &gt;= 1) {
 543         tty-&gt;print(&quot;%s&quot;, heap-&gt;name());
 544       } else {
 545         tty-&gt;print(&quot;CodeCache&quot;);
 546       }
 547       tty-&gt;print_cr(&quot; extended to [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;] (&quot; SSIZE_FORMAT &quot; bytes)&quot;,
 548                     (intptr_t)heap-&gt;low_boundary(), (intptr_t)heap-&gt;high(),
 549                     (address)heap-&gt;high() - (address)heap-&gt;low_boundary());
 550     }
 551   }
 552   print_trace(&quot;allocation&quot;, cb, size);
 553   return cb;
 554 }
 555 
 556 void CodeCache::free(CodeBlob* cb) {
 557   assert_locked_or_safepoint(CodeCache_lock);
 558   CodeHeap* heap = get_code_heap(cb);
 559   print_trace(&quot;free&quot;, cb);
 560   if (cb-&gt;is_nmethod()) {
 561     heap-&gt;set_nmethod_count(heap-&gt;nmethod_count() - 1);
 562     if (((nmethod *)cb)-&gt;has_dependencies()) {
 563       _number_of_nmethods_with_dependencies--;
 564     }
 565   }
 566   if (cb-&gt;is_adapter_blob()) {
 567     heap-&gt;set_adapter_count(heap-&gt;adapter_count() - 1);
 568   }
 569 
 570   // Get heap for given CodeBlob and deallocate
 571   get_code_heap(cb)-&gt;deallocate(cb);
 572 
 573   assert(heap-&gt;blob_count() &gt;= 0, &quot;sanity check&quot;);
 574 }
 575 
 576 void CodeCache::free_unused_tail(CodeBlob* cb, size_t used) {
 577   assert_locked_or_safepoint(CodeCache_lock);
 578   guarantee(cb-&gt;is_buffer_blob() &amp;&amp; strncmp(&quot;Interpreter&quot;, cb-&gt;name(), 11) == 0, &quot;Only possible for interpreter!&quot;);
 579   print_trace(&quot;free_unused_tail&quot;, cb);
 580 
 581   // We also have to account for the extra space (i.e. header) used by the CodeBlob
 582   // which provides the memory (see BufferBlob::create() in codeBlob.cpp).
 583   used += CodeBlob::align_code_offset(cb-&gt;header_size());
 584 
 585   // Get heap for given CodeBlob and deallocate its unused tail
 586   get_code_heap(cb)-&gt;deallocate_tail(cb, used);
 587   // Adjust the sizes of the CodeBlob
 588   cb-&gt;adjust_size(used);
 589 }
 590 
 591 void CodeCache::commit(CodeBlob* cb) {
 592   // this is called by nmethod::nmethod, which must already own CodeCache_lock
 593   assert_locked_or_safepoint(CodeCache_lock);
 594   CodeHeap* heap = get_code_heap(cb);
 595   if (cb-&gt;is_nmethod()) {
 596     heap-&gt;set_nmethod_count(heap-&gt;nmethod_count() + 1);
 597     if (((nmethod *)cb)-&gt;has_dependencies()) {
 598       _number_of_nmethods_with_dependencies++;
 599     }
 600   }
 601   if (cb-&gt;is_adapter_blob()) {
 602     heap-&gt;set_adapter_count(heap-&gt;adapter_count() + 1);
 603   }
 604 
 605   // flush the hardware I-cache
 606   ICache::invalidate_range(cb-&gt;content_begin(), cb-&gt;content_size());
 607 }
 608 
 609 bool CodeCache::contains(void *p) {
 610   // S390 uses contains() in current_frame(), which is used before
 611   // code cache initialization if NativeMemoryTracking=detail is set.
 612   S390_ONLY(if (_heaps == NULL) return false;)
 613   // It should be ok to call contains without holding a lock.
 614   FOR_ALL_HEAPS(heap) {
 615     if ((*heap)-&gt;contains(p)) {
 616       return true;
 617     }
 618   }
 619   return false;
 620 }
 621 
 622 bool CodeCache::contains(nmethod *nm) {
 623   return contains((void *)nm);
 624 }
 625 
 626 // This method is safe to call without holding the CodeCache_lock, as long as a dead CodeBlob is not
 627 // looked up (i.e., one that has been marked for deletion). It only depends on the _segmap to contain
 628 // valid indices, which it will always do, as long as the CodeBlob is not in the process of being recycled.
 629 CodeBlob* CodeCache::find_blob(void* start) {
 630   CodeBlob* result = find_blob_unsafe(start);
 631   // We could potentially look up non_entrant methods
 632   guarantee(result == NULL || !result-&gt;is_zombie() || result-&gt;is_locked_by_vm() || VMError::is_error_reported(), &quot;unsafe access to zombie method&quot;);
 633   return result;
 634 }
 635 
 636 // Lookup that does not fail if you lookup a zombie method (if you call this, be sure to know
 637 // what you are doing)
 638 CodeBlob* CodeCache::find_blob_unsafe(void* start) {
 639   // NMT can walk the stack before code cache is created
 640   if (_heaps != NULL) {
 641     CodeHeap* heap = get_code_heap_containing(start);
 642     if (heap != NULL) {
 643       return heap-&gt;find_blob_unsafe(start);
 644     }
 645   }
 646   return NULL;
 647 }
 648 
 649 nmethod* CodeCache::find_nmethod(void* start) {
 650   CodeBlob* cb = find_blob(start);
 651   assert(cb-&gt;is_nmethod(), &quot;did not find an nmethod&quot;);
 652   return (nmethod*)cb;
 653 }
 654 
 655 void CodeCache::blobs_do(void f(CodeBlob* nm)) {
 656   assert_locked_or_safepoint(CodeCache_lock);
 657   FOR_ALL_HEAPS(heap) {
 658     FOR_ALL_BLOBS(cb, *heap) {
 659       f(cb);
 660     }
 661   }
 662 }
 663 
 664 void CodeCache::nmethods_do(void f(nmethod* nm)) {
 665   assert_locked_or_safepoint(CodeCache_lock);
 666   NMethodIterator iter(NMethodIterator::all_blobs);
 667   while(iter.next()) {
 668     f(iter.method());
 669   }
 670 }
 671 
 672 void CodeCache::metadata_do(MetadataClosure* f) {
 673   assert_locked_or_safepoint(CodeCache_lock);
 674   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 675   while(iter.next()) {
 676     iter.method()-&gt;metadata_do(f);
 677   }
 678   AOTLoader::metadata_do(f);
 679 }
 680 
 681 int CodeCache::alignment_unit() {
 682   return (int)_heaps-&gt;first()-&gt;alignment_unit();
 683 }
 684 
 685 int CodeCache::alignment_offset() {
 686   return (int)_heaps-&gt;first()-&gt;alignment_offset();
 687 }
 688 
 689 // Mark nmethods for unloading if they contain otherwise unreachable oops.
 690 void CodeCache::do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred) {
 691   assert_locked_or_safepoint(CodeCache_lock);
 692   UnloadingScope scope(is_alive);
 693   CompiledMethodIterator iter(CompiledMethodIterator::only_alive);
 694   while(iter.next()) {
 695     iter.method()-&gt;do_unloading(unloading_occurred);
 696   }
 697 }
 698 
 699 void CodeCache::blobs_do(CodeBlobClosure* f) {
 700   assert_locked_or_safepoint(CodeCache_lock);
 701   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 702     FOR_ALL_BLOBS(cb, *heap) {
 703       if (cb-&gt;is_alive()) {
 704         f-&gt;do_code_blob(cb);
 705 #ifdef ASSERT
 706         if (cb-&gt;is_nmethod()) {
 707           Universe::heap()-&gt;verify_nmethod((nmethod*)cb);
 708         }
 709 #endif //ASSERT
 710       }
 711     }
 712   }
 713 }
 714 
 715 void CodeCache::verify_clean_inline_caches() {
 716 #ifdef ASSERT
 717   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 718   while(iter.next()) {
 719     nmethod* nm = iter.method();
 720     assert(!nm-&gt;is_unloaded(), &quot;Tautology&quot;);
 721     nm-&gt;verify_clean_inline_caches();
 722     nm-&gt;verify();
 723   }
 724 #endif
 725 }
 726 
 727 void CodeCache::verify_icholder_relocations() {
 728 #ifdef ASSERT
 729   // make sure that we aren&#39;t leaking icholders
 730   int count = 0;
 731   FOR_ALL_HEAPS(heap) {
 732     FOR_ALL_BLOBS(cb, *heap) {
 733       CompiledMethod *nm = cb-&gt;as_compiled_method_or_null();
 734       if (nm != NULL) {
 735         count += nm-&gt;verify_icholder_relocations();
 736       }
 737     }
 738   }
 739   assert(count + InlineCacheBuffer::pending_icholder_count() + CompiledICHolder::live_not_claimed_count() ==
 740          CompiledICHolder::live_count(), &quot;must agree&quot;);
 741 #endif
 742 }
 743 
 744 // Defer freeing of concurrently cleaned ExceptionCache entries until
 745 // after a global handshake operation.
 746 void CodeCache::release_exception_cache(ExceptionCache* entry) {
 747   if (SafepointSynchronize::is_at_safepoint()) {
 748     delete entry;
 749   } else {
 750     for (;;) {
 751       ExceptionCache* purge_list_head = Atomic::load(&amp;_exception_cache_purge_list);
 752       entry-&gt;set_purge_list_next(purge_list_head);
 753       if (Atomic::cmpxchg(&amp;_exception_cache_purge_list, purge_list_head, entry) == purge_list_head) {
 754         break;
 755       }
 756     }
 757   }
 758 }
 759 
 760 // Delete exception caches that have been concurrently unlinked,
 761 // followed by a global handshake operation.
 762 void CodeCache::purge_exception_caches() {
 763   ExceptionCache* curr = _exception_cache_purge_list;
 764   while (curr != NULL) {
 765     ExceptionCache* next = curr-&gt;purge_list_next();
 766     delete curr;
 767     curr = next;
 768   }
 769   _exception_cache_purge_list = NULL;
 770 }
 771 
 772 uint8_t CodeCache::_unloading_cycle = 1;
 773 
 774 void CodeCache::increment_unloading_cycle() {
 775   // 2-bit value (see IsUnloadingState in nmethod.cpp for details)
 776   // 0 is reserved for new methods.
 777   _unloading_cycle = (_unloading_cycle + 1) % 4;
 778   if (_unloading_cycle == 0) {
 779     _unloading_cycle = 1;
 780   }
 781 }
 782 
 783 CodeCache::UnloadingScope::UnloadingScope(BoolObjectClosure* is_alive)
 784   : _is_unloading_behaviour(is_alive)
 785 {
 786   _saved_behaviour = IsUnloadingBehaviour::current();
 787   IsUnloadingBehaviour::set_current(&amp;_is_unloading_behaviour);
 788   increment_unloading_cycle();
 789   DependencyContext::cleaning_start();
 790 }
 791 
 792 CodeCache::UnloadingScope::~UnloadingScope() {
 793   IsUnloadingBehaviour::set_current(_saved_behaviour);
 794   DependencyContext::cleaning_end();
 795 }
 796 
 797 void CodeCache::verify_oops() {
 798   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 799   VerifyOopClosure voc;
 800   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 801   while(iter.next()) {
 802     nmethod* nm = iter.method();
 803     nm-&gt;oops_do(&amp;voc);
 804     nm-&gt;verify_oop_relocations();
 805   }
 806 }
 807 
 808 int CodeCache::blob_count(int code_blob_type) {
 809   CodeHeap* heap = get_code_heap(code_blob_type);
 810   return (heap != NULL) ? heap-&gt;blob_count() : 0;
 811 }
 812 
 813 int CodeCache::blob_count() {
 814   int count = 0;
 815   FOR_ALL_HEAPS(heap) {
 816     count += (*heap)-&gt;blob_count();
 817   }
 818   return count;
 819 }
 820 
 821 int CodeCache::nmethod_count(int code_blob_type) {
 822   CodeHeap* heap = get_code_heap(code_blob_type);
 823   return (heap != NULL) ? heap-&gt;nmethod_count() : 0;
 824 }
 825 
 826 int CodeCache::nmethod_count() {
 827   int count = 0;
 828   FOR_ALL_NMETHOD_HEAPS(heap) {
 829     count += (*heap)-&gt;nmethod_count();
 830   }
 831   return count;
 832 }
 833 
 834 int CodeCache::adapter_count(int code_blob_type) {
 835   CodeHeap* heap = get_code_heap(code_blob_type);
 836   return (heap != NULL) ? heap-&gt;adapter_count() : 0;
 837 }
 838 
 839 int CodeCache::adapter_count() {
 840   int count = 0;
 841   FOR_ALL_HEAPS(heap) {
 842     count += (*heap)-&gt;adapter_count();
 843   }
 844   return count;
 845 }
 846 
 847 address CodeCache::low_bound(int code_blob_type) {
 848   CodeHeap* heap = get_code_heap(code_blob_type);
 849   return (heap != NULL) ? (address)heap-&gt;low_boundary() : NULL;
 850 }
 851 
 852 address CodeCache::high_bound(int code_blob_type) {
 853   CodeHeap* heap = get_code_heap(code_blob_type);
 854   return (heap != NULL) ? (address)heap-&gt;high_boundary() : NULL;
 855 }
 856 
 857 size_t CodeCache::capacity() {
 858   size_t cap = 0;
 859   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 860     cap += (*heap)-&gt;capacity();
 861   }
 862   return cap;
 863 }
 864 
 865 size_t CodeCache::unallocated_capacity(int code_blob_type) {
 866   CodeHeap* heap = get_code_heap(code_blob_type);
 867   return (heap != NULL) ? heap-&gt;unallocated_capacity() : 0;
 868 }
 869 
 870 size_t CodeCache::unallocated_capacity() {
 871   size_t unallocated_cap = 0;
 872   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 873     unallocated_cap += (*heap)-&gt;unallocated_capacity();
 874   }
 875   return unallocated_cap;
 876 }
 877 
 878 size_t CodeCache::max_capacity() {
 879   size_t max_cap = 0;
 880   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 881     max_cap += (*heap)-&gt;max_capacity();
 882   }
 883   return max_cap;
 884 }
 885 
 886 /**
 887  * Returns the reverse free ratio. E.g., if 25% (1/4) of the code heap
 888  * is free, reverse_free_ratio() returns 4.
 889  */
 890 double CodeCache::reverse_free_ratio(int code_blob_type) {
 891   CodeHeap* heap = get_code_heap(code_blob_type);
 892   if (heap == NULL) {
 893     return 0;
 894   }
 895 
 896   double unallocated_capacity = MAX2((double)heap-&gt;unallocated_capacity(), 1.0); // Avoid division by 0;
 897   double max_capacity = (double)heap-&gt;max_capacity();
 898   double result = max_capacity / unallocated_capacity;
 899   assert (max_capacity &gt;= unallocated_capacity, &quot;Must be&quot;);
 900   assert (result &gt;= 1.0, &quot;reverse_free_ratio must be at least 1. It is %f&quot;, result);
 901   return result;
 902 }
 903 
 904 size_t CodeCache::bytes_allocated_in_freelists() {
 905   size_t allocated_bytes = 0;
 906   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 907     allocated_bytes += (*heap)-&gt;allocated_in_freelist();
 908   }
 909   return allocated_bytes;
 910 }
 911 
 912 int CodeCache::allocated_segments() {
 913   int number_of_segments = 0;
 914   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 915     number_of_segments += (*heap)-&gt;allocated_segments();
 916   }
 917   return number_of_segments;
 918 }
 919 
 920 size_t CodeCache::freelists_length() {
 921   size_t length = 0;
 922   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 923     length += (*heap)-&gt;freelist_length();
 924   }
 925   return length;
 926 }
 927 
 928 void icache_init();
 929 
 930 void CodeCache::initialize() {
 931   assert(CodeCacheSegmentSize &gt;= (uintx)CodeEntryAlignment, &quot;CodeCacheSegmentSize must be large enough to align entry points&quot;);
 932 #ifdef COMPILER2
 933   assert(CodeCacheSegmentSize &gt;= (uintx)OptoLoopAlignment,  &quot;CodeCacheSegmentSize must be large enough to align inner loops&quot;);
 934 #endif
 935   assert(CodeCacheSegmentSize &gt;= sizeof(jdouble),    &quot;CodeCacheSegmentSize must be large enough to align constants&quot;);
 936   // This was originally just a check of the alignment, causing failure, instead, round
 937   // the code cache to the page size.  In particular, Solaris is moving to a larger
 938   // default page size.
 939   CodeCacheExpansionSize = align_up(CodeCacheExpansionSize, os::vm_page_size());
 940 
 941   if (SegmentedCodeCache) {
 942     // Use multiple code heaps
 943     initialize_heaps();
 944   } else {
 945     // Use a single code heap
 946     FLAG_SET_ERGO(NonNMethodCodeHeapSize, 0);
 947     FLAG_SET_ERGO(ProfiledCodeHeapSize, 0);
 948     FLAG_SET_ERGO(NonProfiledCodeHeapSize, 0);
 949     ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize);
 950     add_heap(rs, &quot;CodeCache&quot;, CodeBlobType::All);
 951   }
 952 
 953   // Initialize ICache flush mechanism
<a name="1" id="anc1"></a>
 954   icache_init();
<a name="2" id="anc2"></a>




 955 }
 956 
 957 void codeCache_init() {
 958   CodeCache::initialize();
 959   // Load AOT libraries and add AOT code heaps.
 960   AOTLoader::initialize();
 961 }
 962 
 963 //------------------------------------------------------------------------------------------------
 964 
 965 int CodeCache::number_of_nmethods_with_dependencies() {
 966   return _number_of_nmethods_with_dependencies;
 967 }
 968 
 969 void CodeCache::clear_inline_caches() {
 970   assert_locked_or_safepoint(CodeCache_lock);
 971   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
 972   while(iter.next()) {
 973     iter.method()-&gt;clear_inline_caches();
 974   }
 975 }
 976 
 977 void CodeCache::cleanup_inline_caches() {
 978   assert_locked_or_safepoint(CodeCache_lock);
 979   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 980   while(iter.next()) {
 981     iter.method()-&gt;cleanup_inline_caches(/*clean_all=*/true);
 982   }
 983 }
 984 
 985 // Keeps track of time spent for checking dependencies
 986 NOT_PRODUCT(static elapsedTimer dependentCheckTime;)
 987 
 988 int CodeCache::mark_for_deoptimization(KlassDepChange&amp; changes) {
 989   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 990   int number_of_marked_CodeBlobs = 0;
 991 
 992   // search the hierarchy looking for nmethods which are affected by the loading of this class
 993 
 994   // then search the interfaces this class implements looking for nmethods
 995   // which might be dependent of the fact that an interface only had one
 996   // implementor.
 997   // nmethod::check_all_dependencies works only correctly, if no safepoint
 998   // can happen
 999   NoSafepointVerifier nsv;
1000   for (DepChange::ContextStream str(changes, nsv); str.next(); ) {
1001     Klass* d = str.klass();
1002     number_of_marked_CodeBlobs += InstanceKlass::cast(d)-&gt;mark_dependent_nmethods(changes);
1003   }
1004 
1005 #ifndef PRODUCT
1006   if (VerifyDependencies) {
1007     // Object pointers are used as unique identifiers for dependency arguments. This
1008     // is only possible if no safepoint, i.e., GC occurs during the verification code.
1009     dependentCheckTime.start();
1010     nmethod::check_all_dependencies(changes);
1011     dependentCheckTime.stop();
1012   }
1013 #endif
1014 
1015   return number_of_marked_CodeBlobs;
1016 }
1017 
1018 CompiledMethod* CodeCache::find_compiled(void* start) {
1019   CodeBlob *cb = find_blob(start);
1020   assert(cb == NULL || cb-&gt;is_compiled(), &quot;did not find an compiled_method&quot;);
1021   return (CompiledMethod*)cb;
1022 }
1023 
1024 bool CodeCache::is_far_target(address target) {
1025 #if INCLUDE_AOT
1026   return NativeCall::is_far_call(_low_bound,  target) ||
1027          NativeCall::is_far_call(_high_bound, target);
1028 #else
1029   return false;
1030 #endif
1031 }
1032 
1033 #ifdef INCLUDE_JVMTI
1034 // RedefineClasses support for unloading nmethods that are dependent on &quot;old&quot; methods.
1035 // We don&#39;t really expect this table to grow very large.  If it does, it can become a hashtable.
1036 static GrowableArray&lt;CompiledMethod*&gt;* old_compiled_method_table = NULL;
1037 
1038 static void add_to_old_table(CompiledMethod* c) {
1039   if (old_compiled_method_table == NULL) {
1040     old_compiled_method_table = new (ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CompiledMethod*&gt;(100, true);
1041   }
1042   old_compiled_method_table-&gt;push(c);
1043 }
1044 
1045 static void reset_old_method_table() {
1046   if (old_compiled_method_table != NULL) {
1047     delete old_compiled_method_table;
1048     old_compiled_method_table = NULL;
1049   }
1050 }
1051 
1052 // Remove this method when zombied or unloaded.
1053 void CodeCache::unregister_old_nmethod(CompiledMethod* c) {
1054   assert_lock_strong(CodeCache_lock);
1055   if (old_compiled_method_table != NULL) {
1056     int index = old_compiled_method_table-&gt;find(c);
1057     if (index != -1) {
1058       old_compiled_method_table-&gt;delete_at(index);
1059     }
1060   }
1061 }
1062 
1063 void CodeCache::old_nmethods_do(MetadataClosure* f) {
1064   // Walk old method table and mark those on stack.
1065   int length = 0;
1066   if (old_compiled_method_table != NULL) {
1067     length = old_compiled_method_table-&gt;length();
1068     for (int i = 0; i &lt; length; i++) {
1069       CompiledMethod* cm = old_compiled_method_table-&gt;at(i);
1070       // Only walk alive nmethods, the dead ones will get removed by the sweeper.
1071       if (cm-&gt;is_alive()) {
1072         old_compiled_method_table-&gt;at(i)-&gt;metadata_do(f);
1073       }
1074     }
1075   }
1076   log_debug(redefine, class, nmethod)(&quot;Walked %d nmethods for mark_on_stack&quot;, length);
1077 }
1078 
1079 // Just marks the methods in this class as needing deoptimization
1080 void CodeCache::mark_for_evol_deoptimization(InstanceKlass* dependee) {
1081   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);
1082 
1083   // Mark dependent AOT nmethods, which are only found via the class redefined.
1084   // TODO: add dependencies to aotCompiledMethod&#39;s metadata section so this isn&#39;t
1085   // needed.
1086   AOTLoader::mark_evol_dependent_methods(dependee);
1087 }
1088 
1089 
1090 // Walk compiled methods and mark dependent methods for deoptimization.
1091 int CodeCache::mark_dependents_for_evol_deoptimization() {
1092   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);
1093   // Each redefinition creates a new set of nmethods that have references to &quot;old&quot; Methods
1094   // So delete old method table and create a new one.
1095   reset_old_method_table();
1096 
1097   int number_of_marked_CodeBlobs = 0;
1098   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1099   while(iter.next()) {
1100     CompiledMethod* nm = iter.method();
1101     // Walk all alive nmethods to check for old Methods.
1102     // This includes methods whose inline caches point to old methods, so
1103     // inline cache clearing is unnecessary.
1104     if (nm-&gt;has_evol_metadata()) {
1105       nm-&gt;mark_for_deoptimization();
1106       add_to_old_table(nm);
1107       number_of_marked_CodeBlobs++;
1108     }
1109   }
1110 
1111   // return total count of nmethods marked for deoptimization, if zero the caller
1112   // can skip deoptimization
1113   return number_of_marked_CodeBlobs;
1114 }
1115 
1116 void CodeCache::mark_all_nmethods_for_evol_deoptimization() {
1117   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);
1118   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1119   while(iter.next()) {
1120     CompiledMethod* nm = iter.method();
1121     if (!nm-&gt;method()-&gt;is_method_handle_intrinsic()) {
1122       nm-&gt;mark_for_deoptimization();
1123       if (nm-&gt;has_evol_metadata()) {
1124         add_to_old_table(nm);
1125       }
1126     }
1127   }
1128 }
1129 
1130 // Flushes compiled methods dependent on redefined classes, that have already been
1131 // marked for deoptimization.
1132 void CodeCache::flush_evol_dependents() {
1133   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);
1134 
1135   // CodeCache can only be updated by a thread_in_VM and they will all be
1136   // stopped during the safepoint so CodeCache will be safe to update without
1137   // holding the CodeCache_lock.
1138 
1139   // At least one nmethod has been marked for deoptimization
1140 
1141   Deoptimization::deoptimize_all_marked();
1142 }
1143 #endif // INCLUDE_JVMTI
1144 
1145 // Mark methods for deopt (if safe or possible).
1146 void CodeCache::mark_all_nmethods_for_deoptimization() {
1147   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1148   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1149   while(iter.next()) {
1150     CompiledMethod* nm = iter.method();
1151     if (!nm-&gt;is_native_method()) {
1152       nm-&gt;mark_for_deoptimization();
1153     }
1154   }
1155 }
1156 
1157 int CodeCache::mark_for_deoptimization(Method* dependee) {
1158   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1159   int number_of_marked_CodeBlobs = 0;
1160 
1161   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1162   while(iter.next()) {
1163     CompiledMethod* nm = iter.method();
1164     if (nm-&gt;is_dependent_on_method(dependee)) {
1165       ResourceMark rm;
1166       nm-&gt;mark_for_deoptimization();
1167       number_of_marked_CodeBlobs++;
1168     }
1169   }
1170 
1171   return number_of_marked_CodeBlobs;
1172 }
1173 
1174 void CodeCache::make_marked_nmethods_not_entrant() {
1175   assert_locked_or_safepoint(CodeCache_lock);
1176   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1177   while(iter.next()) {
1178     CompiledMethod* nm = iter.method();
1179     if (nm-&gt;is_marked_for_deoptimization()) {
1180       nm-&gt;make_not_entrant();
1181     }
1182   }
1183 }
1184 
1185 // Flushes compiled methods dependent on dependee.
1186 void CodeCache::flush_dependents_on(InstanceKlass* dependee) {
1187   assert_lock_strong(Compile_lock);
1188 
1189   if (number_of_nmethods_with_dependencies() == 0) return;
1190 
1191   KlassDepChange changes(dependee);
1192 
1193   // Compute the dependent nmethods
1194   if (mark_for_deoptimization(changes) &gt; 0) {
1195     // At least one nmethod has been marked for deoptimization
1196     Deoptimization::deoptimize_all_marked();
1197   }
1198 }
1199 
1200 // Flushes compiled methods dependent on dependee
1201 void CodeCache::flush_dependents_on_method(const methodHandle&amp; m_h) {
1202   // --- Compile_lock is not held. However we are at a safepoint.
1203   assert_locked_or_safepoint(Compile_lock);
1204 
1205   // Compute the dependent nmethods
1206   if (mark_for_deoptimization(m_h()) &gt; 0) {
1207     Deoptimization::deoptimize_all_marked();
1208   }
1209 }
1210 
1211 void CodeCache::verify() {
1212   assert_locked_or_safepoint(CodeCache_lock);
1213   FOR_ALL_HEAPS(heap) {
1214     (*heap)-&gt;verify();
1215     FOR_ALL_BLOBS(cb, *heap) {
1216       if (cb-&gt;is_alive()) {
1217         cb-&gt;verify();
1218       }
1219     }
1220   }
1221 }
1222 
1223 // A CodeHeap is full. Print out warning and report event.
1224 PRAGMA_DIAG_PUSH
1225 PRAGMA_FORMAT_NONLITERAL_IGNORED
1226 void CodeCache::report_codemem_full(int code_blob_type, bool print) {
1227   // Get nmethod heap for the given CodeBlobType and build CodeCacheFull event
1228   CodeHeap* heap = get_code_heap(code_blob_type);
1229   assert(heap != NULL, &quot;heap is null&quot;);
1230 
1231   if ((heap-&gt;full_count() == 0) || print) {
1232     // Not yet reported for this heap, report
1233     if (SegmentedCodeCache) {
1234       ResourceMark rm;
1235       stringStream msg1_stream, msg2_stream;
1236       msg1_stream.print(&quot;%s is full. Compiler has been disabled.&quot;,
1237                         get_code_heap_name(code_blob_type));
1238       msg2_stream.print(&quot;Try increasing the code heap size using -XX:%s=&quot;,
1239                  get_code_heap_flag_name(code_blob_type));
1240       const char *msg1 = msg1_stream.as_string();
1241       const char *msg2 = msg2_stream.as_string();
1242 
1243       log_warning(codecache)(&quot;%s&quot;, msg1);
1244       log_warning(codecache)(&quot;%s&quot;, msg2);
1245       warning(&quot;%s&quot;, msg1);
1246       warning(&quot;%s&quot;, msg2);
1247     } else {
1248       const char *msg1 = &quot;CodeCache is full. Compiler has been disabled.&quot;;
1249       const char *msg2 = &quot;Try increasing the code cache size using -XX:ReservedCodeCacheSize=&quot;;
1250 
1251       log_warning(codecache)(&quot;%s&quot;, msg1);
1252       log_warning(codecache)(&quot;%s&quot;, msg2);
1253       warning(&quot;%s&quot;, msg1);
1254       warning(&quot;%s&quot;, msg2);
1255     }
1256     ResourceMark rm;
1257     stringStream s;
1258     // Dump code cache into a buffer before locking the tty.
1259     {
1260       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1261       print_summary(&amp;s);
1262     }
1263     {
1264       ttyLocker ttyl;
1265       tty-&gt;print(&quot;%s&quot;, s.as_string());
1266     }
1267 
1268     if (heap-&gt;full_count() == 0) {
1269       if (PrintCodeHeapAnalytics) {
1270         CompileBroker::print_heapinfo(tty, &quot;all&quot;, 4096); // details, may be a lot!
1271       }
1272     }
1273   }
1274 
1275   heap-&gt;report_full();
1276 
1277   EventCodeCacheFull event;
1278   if (event.should_commit()) {
1279     event.set_codeBlobType((u1)code_blob_type);
1280     event.set_startAddress((u8)heap-&gt;low_boundary());
1281     event.set_commitedTopAddress((u8)heap-&gt;high());
1282     event.set_reservedTopAddress((u8)heap-&gt;high_boundary());
1283     event.set_entryCount(heap-&gt;blob_count());
1284     event.set_methodCount(heap-&gt;nmethod_count());
1285     event.set_adaptorCount(heap-&gt;adapter_count());
1286     event.set_unallocatedCapacity(heap-&gt;unallocated_capacity());
1287     event.set_fullCount(heap-&gt;full_count());
1288     event.commit();
1289   }
1290 }
1291 PRAGMA_DIAG_POP
1292 
1293 void CodeCache::print_memory_overhead() {
1294   size_t wasted_bytes = 0;
1295   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1296       CodeHeap* curr_heap = *heap;
1297       for (CodeBlob* cb = (CodeBlob*)curr_heap-&gt;first(); cb != NULL; cb = (CodeBlob*)curr_heap-&gt;next(cb)) {
1298         HeapBlock* heap_block = ((HeapBlock*)cb) - 1;
1299         wasted_bytes += heap_block-&gt;length() * CodeCacheSegmentSize - cb-&gt;size();
1300       }
1301   }
1302   // Print bytes that are allocated in the freelist
1303   ttyLocker ttl;
1304   tty-&gt;print_cr(&quot;Number of elements in freelist: &quot; SSIZE_FORMAT,       freelists_length());
1305   tty-&gt;print_cr(&quot;Allocated in freelist:          &quot; SSIZE_FORMAT &quot;kB&quot;,  bytes_allocated_in_freelists()/K);
1306   tty-&gt;print_cr(&quot;Unused bytes in CodeBlobs:      &quot; SSIZE_FORMAT &quot;kB&quot;,  (wasted_bytes/K));
1307   tty-&gt;print_cr(&quot;Segment map size:               &quot; SSIZE_FORMAT &quot;kB&quot;,  allocated_segments()/K); // 1 byte per segment
1308 }
1309 
1310 //------------------------------------------------------------------------------------------------
1311 // Non-product version
1312 
1313 #ifndef PRODUCT
1314 
1315 void CodeCache::print_trace(const char* event, CodeBlob* cb, int size) {
1316   if (PrintCodeCache2) {  // Need to add a new flag
1317     ResourceMark rm;
1318     if (size == 0)  size = cb-&gt;size();
1319     tty-&gt;print_cr(&quot;CodeCache %s:  addr: &quot; INTPTR_FORMAT &quot;, size: 0x%x&quot;, event, p2i(cb), size);
1320   }
1321 }
1322 
1323 void CodeCache::print_internals() {
1324   int nmethodCount = 0;
1325   int runtimeStubCount = 0;
1326   int adapterCount = 0;
1327   int deoptimizationStubCount = 0;
1328   int uncommonTrapStubCount = 0;
1329   int bufferBlobCount = 0;
1330   int total = 0;
1331   int nmethodAlive = 0;
1332   int nmethodNotEntrant = 0;
1333   int nmethodZombie = 0;
1334   int nmethodUnloaded = 0;
1335   int nmethodJava = 0;
1336   int nmethodNative = 0;
1337   int max_nm_size = 0;
1338   ResourceMark rm;
1339 
1340   int i = 0;
1341   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1342     if ((_nmethod_heaps-&gt;length() &gt;= 1) &amp;&amp; Verbose) {
1343       tty-&gt;print_cr(&quot;-- %s --&quot;, (*heap)-&gt;name());
1344     }
1345     FOR_ALL_BLOBS(cb, *heap) {
1346       total++;
1347       if (cb-&gt;is_nmethod()) {
1348         nmethod* nm = (nmethod*)cb;
1349 
1350         if (Verbose &amp;&amp; nm-&gt;method() != NULL) {
1351           ResourceMark rm;
1352           char *method_name = nm-&gt;method()-&gt;name_and_sig_as_C_string();
1353           tty-&gt;print(&quot;%s&quot;, method_name);
1354           if(nm-&gt;is_alive()) { tty-&gt;print_cr(&quot; alive&quot;); }
1355           if(nm-&gt;is_not_entrant()) { tty-&gt;print_cr(&quot; not-entrant&quot;); }
1356           if(nm-&gt;is_zombie()) { tty-&gt;print_cr(&quot; zombie&quot;); }
1357         }
1358 
1359         nmethodCount++;
1360 
1361         if(nm-&gt;is_alive()) { nmethodAlive++; }
1362         if(nm-&gt;is_not_entrant()) { nmethodNotEntrant++; }
1363         if(nm-&gt;is_zombie()) { nmethodZombie++; }
1364         if(nm-&gt;is_unloaded()) { nmethodUnloaded++; }
1365         if(nm-&gt;method() != NULL &amp;&amp; nm-&gt;is_native_method()) { nmethodNative++; }
1366 
1367         if(nm-&gt;method() != NULL &amp;&amp; nm-&gt;is_java_method()) {
1368           nmethodJava++;
1369           max_nm_size = MAX2(max_nm_size, nm-&gt;size());
1370         }
1371       } else if (cb-&gt;is_runtime_stub()) {
1372         runtimeStubCount++;
1373       } else if (cb-&gt;is_deoptimization_stub()) {
1374         deoptimizationStubCount++;
1375       } else if (cb-&gt;is_uncommon_trap_stub()) {
1376         uncommonTrapStubCount++;
1377       } else if (cb-&gt;is_adapter_blob()) {
1378         adapterCount++;
1379       } else if (cb-&gt;is_buffer_blob()) {
1380         bufferBlobCount++;
1381       }
1382     }
1383   }
1384 
1385   int bucketSize = 512;
1386   int bucketLimit = max_nm_size / bucketSize + 1;
1387   int *buckets = NEW_C_HEAP_ARRAY(int, bucketLimit, mtCode);
1388   memset(buckets, 0, sizeof(int) * bucketLimit);
1389 
1390   NMethodIterator iter(NMethodIterator::all_blobs);
1391   while(iter.next()) {
1392     nmethod* nm = iter.method();
1393     if(nm-&gt;method() != NULL &amp;&amp; nm-&gt;is_java_method()) {
1394       buckets[nm-&gt;size() / bucketSize]++;
1395     }
1396   }
1397 
1398   tty-&gt;print_cr(&quot;Code Cache Entries (total of %d)&quot;,total);
1399   tty-&gt;print_cr(&quot;-------------------------------------------------&quot;);
1400   tty-&gt;print_cr(&quot;nmethods: %d&quot;,nmethodCount);
1401   tty-&gt;print_cr(&quot;\talive: %d&quot;,nmethodAlive);
1402   tty-&gt;print_cr(&quot;\tnot_entrant: %d&quot;,nmethodNotEntrant);
1403   tty-&gt;print_cr(&quot;\tzombie: %d&quot;,nmethodZombie);
1404   tty-&gt;print_cr(&quot;\tunloaded: %d&quot;,nmethodUnloaded);
1405   tty-&gt;print_cr(&quot;\tjava: %d&quot;,nmethodJava);
1406   tty-&gt;print_cr(&quot;\tnative: %d&quot;,nmethodNative);
1407   tty-&gt;print_cr(&quot;runtime_stubs: %d&quot;,runtimeStubCount);
1408   tty-&gt;print_cr(&quot;adapters: %d&quot;,adapterCount);
1409   tty-&gt;print_cr(&quot;buffer blobs: %d&quot;,bufferBlobCount);
1410   tty-&gt;print_cr(&quot;deoptimization_stubs: %d&quot;,deoptimizationStubCount);
1411   tty-&gt;print_cr(&quot;uncommon_traps: %d&quot;,uncommonTrapStubCount);
1412   tty-&gt;print_cr(&quot;\nnmethod size distribution (non-zombie java)&quot;);
1413   tty-&gt;print_cr(&quot;-------------------------------------------------&quot;);
1414 
1415   for(int i=0; i&lt;bucketLimit; i++) {
1416     if(buckets[i] != 0) {
1417       tty-&gt;print(&quot;%d - %d bytes&quot;,i*bucketSize,(i+1)*bucketSize);
1418       tty-&gt;fill_to(40);
1419       tty-&gt;print_cr(&quot;%d&quot;,buckets[i]);
1420     }
1421   }
1422 
1423   FREE_C_HEAP_ARRAY(int, buckets);
1424   print_memory_overhead();
1425 }
1426 
1427 #endif // !PRODUCT
1428 
1429 void CodeCache::print() {
1430   print_summary(tty);
1431 
1432 #ifndef PRODUCT
1433   if (!Verbose) return;
1434 
1435   CodeBlob_sizes live;
1436   CodeBlob_sizes dead;
1437 
1438   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1439     FOR_ALL_BLOBS(cb, *heap) {
1440       if (!cb-&gt;is_alive()) {
1441         dead.add(cb);
1442       } else {
1443         live.add(cb);
1444       }
1445     }
1446   }
1447 
1448   tty-&gt;print_cr(&quot;CodeCache:&quot;);
1449   tty-&gt;print_cr(&quot;nmethod dependency checking time %fs&quot;, dependentCheckTime.seconds());
1450 
1451   if (!live.is_empty()) {
1452     live.print(&quot;live&quot;);
1453   }
1454   if (!dead.is_empty()) {
1455     dead.print(&quot;dead&quot;);
1456   }
1457 
1458   if (WizardMode) {
1459      // print the oop_map usage
1460     int code_size = 0;
1461     int number_of_blobs = 0;
1462     int number_of_oop_maps = 0;
1463     int map_size = 0;
1464     FOR_ALL_ALLOCABLE_HEAPS(heap) {
1465       FOR_ALL_BLOBS(cb, *heap) {
1466         if (cb-&gt;is_alive()) {
1467           number_of_blobs++;
1468           code_size += cb-&gt;code_size();
1469           ImmutableOopMapSet* set = cb-&gt;oop_maps();
1470           if (set != NULL) {
1471             number_of_oop_maps += set-&gt;count();
1472             map_size           += set-&gt;nr_of_bytes();
1473           }
1474         }
1475       }
1476     }
1477     tty-&gt;print_cr(&quot;OopMaps&quot;);
1478     tty-&gt;print_cr(&quot;  #blobs    = %d&quot;, number_of_blobs);
1479     tty-&gt;print_cr(&quot;  code size = %d&quot;, code_size);
1480     tty-&gt;print_cr(&quot;  #oop_maps = %d&quot;, number_of_oop_maps);
1481     tty-&gt;print_cr(&quot;  map size  = %d&quot;, map_size);
1482   }
1483 
1484 #endif // !PRODUCT
1485 }
1486 
1487 void CodeCache::print_summary(outputStream* st, bool detailed) {
1488   int full_count = 0;
1489   FOR_ALL_HEAPS(heap_iterator) {
1490     CodeHeap* heap = (*heap_iterator);
1491     size_t total = (heap-&gt;high_boundary() - heap-&gt;low_boundary());
1492     if (_heaps-&gt;length() &gt;= 1) {
1493       st-&gt;print(&quot;%s:&quot;, heap-&gt;name());
1494     } else {
1495       st-&gt;print(&quot;CodeCache:&quot;);
1496     }
1497     st-&gt;print_cr(&quot; size=&quot; SIZE_FORMAT &quot;Kb used=&quot; SIZE_FORMAT
1498                  &quot;Kb max_used=&quot; SIZE_FORMAT &quot;Kb free=&quot; SIZE_FORMAT &quot;Kb&quot;,
1499                  total/K, (total - heap-&gt;unallocated_capacity())/K,
1500                  heap-&gt;max_allocated_capacity()/K, heap-&gt;unallocated_capacity()/K);
1501 
1502     if (detailed) {
1503       st-&gt;print_cr(&quot; bounds [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;]&quot;,
1504                    p2i(heap-&gt;low_boundary()),
1505                    p2i(heap-&gt;high()),
1506                    p2i(heap-&gt;high_boundary()));
1507 
1508       full_count += get_codemem_full_count(heap-&gt;code_blob_type());
1509     }
1510   }
1511 
1512   if (detailed) {
1513     st-&gt;print_cr(&quot; total_blobs=&quot; UINT32_FORMAT &quot; nmethods=&quot; UINT32_FORMAT
1514                        &quot; adapters=&quot; UINT32_FORMAT,
1515                        blob_count(), nmethod_count(), adapter_count());
1516     st-&gt;print_cr(&quot; compilation: %s&quot;, CompileBroker::should_compile_new_jobs() ?
1517                  &quot;enabled&quot; : Arguments::mode() == Arguments::_int ?
1518                  &quot;disabled (interpreter mode)&quot; :
1519                  &quot;disabled (not enough contiguous free space left)&quot;);
1520     st-&gt;print_cr(&quot;              stopped_count=%d, restarted_count=%d&quot;,
1521                  CompileBroker::get_total_compiler_stopped_count(),
1522                  CompileBroker::get_total_compiler_restarted_count());
1523     st-&gt;print_cr(&quot; full_count=%d&quot;, full_count);
1524   }
1525 }
1526 
1527 void CodeCache::print_codelist(outputStream* st) {
1528   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1529 
1530   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1531   while (iter.next()) {
1532     CompiledMethod* cm = iter.method();
1533     ResourceMark rm;
1534     char* method_name = cm-&gt;method()-&gt;name_and_sig_as_C_string();
1535     st-&gt;print_cr(&quot;%d %d %d %s [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;]&quot;,
1536                  cm-&gt;compile_id(), cm-&gt;comp_level(), cm-&gt;get_state(),
1537                  method_name,
1538                  (intptr_t)cm-&gt;header_begin(), (intptr_t)cm-&gt;code_begin(), (intptr_t)cm-&gt;code_end());
1539   }
1540 }
1541 
1542 void CodeCache::print_layout(outputStream* st) {
1543   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1544   ResourceMark rm;
1545   print_summary(st, true);
1546 }
1547 
1548 void CodeCache::log_state(outputStream* st) {
1549   st-&gt;print(&quot; total_blobs=&#39;&quot; UINT32_FORMAT &quot;&#39; nmethods=&#39;&quot; UINT32_FORMAT &quot;&#39;&quot;
1550             &quot; adapters=&#39;&quot; UINT32_FORMAT &quot;&#39; free_code_cache=&#39;&quot; SIZE_FORMAT &quot;&#39;&quot;,
1551             blob_count(), nmethod_count(), adapter_count(),
1552             unallocated_capacity());
1553 }
1554 
1555 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
1556 
1557 void CodeCache::aggregate(outputStream *out, size_t granularity) {
1558   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1559     CodeHeapState::aggregate(out, (*heap), granularity);
1560   }
1561 }
1562 
1563 void CodeCache::discard(outputStream *out) {
1564   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1565     CodeHeapState::discard(out, (*heap));
1566   }
1567 }
1568 
1569 void CodeCache::print_usedSpace(outputStream *out) {
1570   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1571     CodeHeapState::print_usedSpace(out, (*heap));
1572   }
1573 }
1574 
1575 void CodeCache::print_freeSpace(outputStream *out) {
1576   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1577     CodeHeapState::print_freeSpace(out, (*heap));
1578   }
1579 }
1580 
1581 void CodeCache::print_count(outputStream *out) {
1582   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1583     CodeHeapState::print_count(out, (*heap));
1584   }
1585 }
1586 
1587 void CodeCache::print_space(outputStream *out) {
1588   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1589     CodeHeapState::print_space(out, (*heap));
1590   }
1591 }
1592 
1593 void CodeCache::print_age(outputStream *out) {
1594   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1595     CodeHeapState::print_age(out, (*heap));
1596   }
1597 }
1598 
1599 void CodeCache::print_names(outputStream *out) {
1600   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1601     CodeHeapState::print_names(out, (*heap));
1602   }
1603 }
1604 //---&lt;  END  &gt;--- CodeHeap State Analytics.
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>