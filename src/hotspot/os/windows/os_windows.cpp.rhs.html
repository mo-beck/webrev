<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src\hotspot\os\windows\os_windows.cpp</title>
    <link rel="stylesheet" href="..\..\..\..\style.css" />
    <script type="text/javascript" src="..\..\..\..\navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // Must be at least Windows Vista or Server 2008 to use InitOnceExecuteOnce
  26 #define _WIN32_WINNT 0x0600
  27 
  28 // no precompiled headers
  29 #include &quot;jvm.h&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  34 #include &quot;code/nativeInst.hpp&quot;</span>
  35 #include &quot;code/vtableStubs.hpp&quot;
  36 #include &quot;compiler/compileBroker.hpp&quot;
  37 #include &quot;compiler/disassembler.hpp&quot;
  38 #include &quot;interpreter/interpreter.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;logging/logStream.hpp&quot;
  41 #include &quot;memory/allocation.inline.hpp&quot;
  42 #include &quot;memory/filemap.hpp&quot;
  43 #include &quot;oops/oop.inline.hpp&quot;
  44 #include &quot;os_share_windows.hpp&quot;
  45 #include &quot;os_windows.inline.hpp&quot;
  46 #include &quot;prims/jniFastGetField.hpp&quot;
  47 #include &quot;prims/jvm_misc.hpp&quot;
  48 #include &quot;runtime/arguments.hpp&quot;
  49 #include &quot;runtime/atomic.hpp&quot;
  50 #include &quot;runtime/extendedPC.hpp&quot;
  51 #include &quot;runtime/globals.hpp&quot;
  52 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  53 #include &quot;runtime/java.hpp&quot;
  54 #include &quot;runtime/javaCalls.hpp&quot;
  55 #include &quot;runtime/mutexLocker.hpp&quot;
  56 #include &quot;runtime/objectMonitor.hpp&quot;
  57 #include &quot;runtime/orderAccess.hpp&quot;
  58 #include &quot;runtime/osThread.hpp&quot;
  59 #include &quot;runtime/perfMemory.hpp&quot;
  60 #include &quot;runtime/sharedRuntime.hpp&quot;
  61 #include &quot;runtime/statSampler.hpp&quot;
  62 #include &quot;runtime/stubRoutines.hpp&quot;
  63 #include &quot;runtime/thread.inline.hpp&quot;
  64 #include &quot;runtime/threadCritical.hpp&quot;
  65 #include &quot;runtime/timer.hpp&quot;
  66 #include &quot;runtime/vm_version.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/growableArray.hpp&quot;
  75 #include &quot;utilities/macros.hpp&quot;
  76 #include &quot;utilities/vmError.hpp&quot;
  77 #include &quot;symbolengine.hpp&quot;
  78 #include &quot;windbghelp.hpp&quot;
  79 
  80 
  81 #ifdef _DEBUG
  82 #include &lt;crtdbg.h&gt;
  83 #endif
  84 
  85 
  86 #include &lt;windows.h&gt;
  87 #include &lt;sys/types.h&gt;
  88 #include &lt;sys/stat.h&gt;
  89 #include &lt;sys/timeb.h&gt;
  90 #include &lt;objidl.h&gt;
  91 #include &lt;shlobj.h&gt;
  92 
  93 #include &lt;malloc.h&gt;
  94 #include &lt;signal.h&gt;
  95 #include &lt;direct.h&gt;
  96 #include &lt;errno.h&gt;
  97 #include &lt;fcntl.h&gt;
  98 #include &lt;io.h&gt;
  99 #include &lt;process.h&gt;              // For _beginthreadex(), _endthreadex()
 100 #include &lt;imagehlp.h&gt;             // For os::dll_address_to_function_name
 101 // for enumerating dll libraries
 102 #include &lt;vdmdbg.h&gt;
 103 #include &lt;psapi.h&gt;
 104 #include &lt;mmsystem.h&gt;
 105 #include &lt;winsock2.h&gt;
 106 
 107 // for timer info max values which include all bits
 108 #define ALL_64_BITS CONST64(-1)
 109 
 110 // For DLL loading/load error detection
 111 // Values of PE COFF
 112 #define IMAGE_FILE_PTR_TO_SIGNATURE 0x3c
 113 #define IMAGE_FILE_SIGNATURE_LENGTH 4
 114 
 115 static HANDLE main_process;
 116 static HANDLE main_thread;
 117 static int    main_thread_id;
 118 
 119 static FILETIME process_creation_time;
 120 static FILETIME process_exit_time;
 121 static FILETIME process_user_time;
 122 static FILETIME process_kernel_time;
 123 
 124 #ifdef _M_AMD64
 125   #define __CPU__ amd64
<a name="2" id="anc2"></a><span class="line-added"> 126 #elif defined _M_ARM64</span>
<span class="line-added"> 127   #define __CPU__ aarch64</span>
 128 #else
 129   #define __CPU__ i486
 130 #endif
 131 
<a name="3" id="anc3"></a>
 132 PVOID  topLevelVectoredExceptionHandler = NULL;
<a name="4" id="anc4"></a>

 133 
 134 // save DLL module handle, used by GetModuleFileName
 135 
 136 HINSTANCE vm_lib_handle;
 137 
 138 BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved) {
 139   switch (reason) {
 140   case DLL_PROCESS_ATTACH:
 141     vm_lib_handle = hinst;
 142     if (ForceTimeHighResolution) {
 143       timeBeginPeriod(1L);
 144     }
 145     WindowsDbgHelp::pre_initialize();
 146     SymbolEngine::pre_initialize();
 147     break;
 148   case DLL_PROCESS_DETACH:
 149     if (ForceTimeHighResolution) {
 150       timeEndPeriod(1L);
 151     }
<a name="5" id="anc5"></a>
 152     if (topLevelVectoredExceptionHandler != NULL) {
 153       RemoveVectoredExceptionHandler(topLevelVectoredExceptionHandler);
 154       topLevelVectoredExceptionHandler = NULL;
 155     }
<a name="6" id="anc6"></a>
 156     break;
 157   default:
 158     break;
 159   }
 160   return true;
 161 }
 162 
 163 static inline double fileTimeAsDouble(FILETIME* time) {
 164   const double high  = (double) ((unsigned int) ~0);
 165   const double split = 10000000.0;
 166   double result = (time-&gt;dwLowDateTime / split) +
 167                    time-&gt;dwHighDateTime * (high/split);
 168   return result;
 169 }
 170 
 171 // Implementation of os
 172 
 173 bool os::unsetenv(const char* name) {
 174   assert(name != NULL, &quot;Null pointer&quot;);
 175   return (SetEnvironmentVariable(name, NULL) == TRUE);
 176 }
 177 
 178 // No setuid programs under Windows.
 179 bool os::have_special_privileges() {
 180   return false;
 181 }
 182 
 183 
 184 // This method is  a periodic task to check for misbehaving JNI applications
 185 // under CheckJNI, we can add any periodic checks here.
 186 // For Windows at the moment does nothing
 187 void os::run_periodic_checks() {
 188   return;
 189 }
 190 
 191 // previous UnhandledExceptionFilter, if there is one
 192 static LPTOP_LEVEL_EXCEPTION_FILTER prev_uef_handler = NULL;
 193 
 194 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo);
 195 
 196 void os::init_system_properties_values() {
 197   // sysclasspath, java_home, dll_dir
 198   {
 199     char *home_path;
 200     char *dll_path;
 201     char *pslash;
 202     const char *bin = &quot;\\bin&quot;;
 203     char home_dir[MAX_PATH + 1];
 204     char *alt_home_dir = ::getenv(&quot;_ALT_JAVA_HOME_DIR&quot;);
 205 
 206     if (alt_home_dir != NULL)  {
 207       strncpy(home_dir, alt_home_dir, MAX_PATH + 1);
 208       home_dir[MAX_PATH] = &#39;\0&#39;;
 209     } else {
 210       os::jvm_path(home_dir, sizeof(home_dir));
 211       // Found the full path to jvm.dll.
 212       // Now cut the path to &lt;java_home&gt;/jre if we can.
 213       *(strrchr(home_dir, &#39;\\&#39;)) = &#39;\0&#39;;  // get rid of \jvm.dll
 214       pslash = strrchr(home_dir, &#39;\\&#39;);
 215       if (pslash != NULL) {
 216         *pslash = &#39;\0&#39;;                   // get rid of \{client|server}
 217         pslash = strrchr(home_dir, &#39;\\&#39;);
 218         if (pslash != NULL) {
 219           *pslash = &#39;\0&#39;;                 // get rid of \bin
 220         }
 221       }
 222     }
 223 
 224     home_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + 1, mtInternal);
 225     strcpy(home_path, home_dir);
 226     Arguments::set_java_home(home_path);
 227     FREE_C_HEAP_ARRAY(char, home_path);
 228 
 229     dll_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + strlen(bin) + 1,
 230                                 mtInternal);
 231     strcpy(dll_path, home_dir);
 232     strcat(dll_path, bin);
 233     Arguments::set_dll_dir(dll_path);
 234     FREE_C_HEAP_ARRAY(char, dll_path);
 235 
 236     if (!set_boot_path(&#39;\\&#39;, &#39;;&#39;)) {
 237       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 238     }
 239   }
 240 
 241 // library_path
 242 #define EXT_DIR &quot;\\lib\\ext&quot;
 243 #define BIN_DIR &quot;\\bin&quot;
 244 #define PACKAGE_DIR &quot;\\Sun\\Java&quot;
 245   {
 246     // Win32 library search order (See the documentation for LoadLibrary):
 247     //
 248     // 1. The directory from which application is loaded.
 249     // 2. The system wide Java Extensions directory (Java only)
 250     // 3. System directory (GetSystemDirectory)
 251     // 4. Windows directory (GetWindowsDirectory)
 252     // 5. The PATH environment variable
 253     // 6. The current directory
 254 
 255     char *library_path;
 256     char tmp[MAX_PATH];
 257     char *path_str = ::getenv(&quot;PATH&quot;);
 258 
 259     library_path = NEW_C_HEAP_ARRAY(char, MAX_PATH * 5 + sizeof(PACKAGE_DIR) +
 260                                     sizeof(BIN_DIR) + (path_str ? strlen(path_str) : 0) + 10, mtInternal);
 261 
 262     library_path[0] = &#39;\0&#39;;
 263 
 264     GetModuleFileName(NULL, tmp, sizeof(tmp));
 265     *(strrchr(tmp, &#39;\\&#39;)) = &#39;\0&#39;;
 266     strcat(library_path, tmp);
 267 
 268     GetWindowsDirectory(tmp, sizeof(tmp));
 269     strcat(library_path, &quot;;&quot;);
 270     strcat(library_path, tmp);
 271     strcat(library_path, PACKAGE_DIR BIN_DIR);
 272 
 273     GetSystemDirectory(tmp, sizeof(tmp));
 274     strcat(library_path, &quot;;&quot;);
 275     strcat(library_path, tmp);
 276 
 277     GetWindowsDirectory(tmp, sizeof(tmp));
 278     strcat(library_path, &quot;;&quot;);
 279     strcat(library_path, tmp);
 280 
 281     if (path_str) {
 282       strcat(library_path, &quot;;&quot;);
 283       strcat(library_path, path_str);
 284     }
 285 
 286     strcat(library_path, &quot;;.&quot;);
 287 
 288     Arguments::set_library_path(library_path);
 289     FREE_C_HEAP_ARRAY(char, library_path);
 290   }
 291 
 292   // Default extensions directory
 293   {
 294     char path[MAX_PATH];
 295     char buf[2 * MAX_PATH + 2 * sizeof(EXT_DIR) + sizeof(PACKAGE_DIR) + 1];
 296     GetWindowsDirectory(path, MAX_PATH);
 297     sprintf(buf, &quot;%s%s;%s%s%s&quot;, Arguments::get_java_home(), EXT_DIR,
 298             path, PACKAGE_DIR, EXT_DIR);
 299     Arguments::set_ext_dirs(buf);
 300   }
 301   #undef EXT_DIR
 302   #undef BIN_DIR
 303   #undef PACKAGE_DIR
 304 
 305 #ifndef _WIN64
 306   // set our UnhandledExceptionFilter and save any previous one
 307   prev_uef_handler = SetUnhandledExceptionFilter(Handle_FLT_Exception);
 308 #endif
 309 
 310   // Done
 311   return;
 312 }
 313 
 314 void os::breakpoint() {
 315   DebugBreak();
 316 }
 317 
 318 // Invoked from the BREAKPOINT Macro
 319 extern &quot;C&quot; void breakpoint() {
 320   os::breakpoint();
 321 }
 322 
 323 // RtlCaptureStackBackTrace Windows API may not exist prior to Windows XP.
 324 // So far, this method is only used by Native Memory Tracking, which is
 325 // only supported on Windows XP or later.
 326 //
 327 int os::get_native_stack(address* stack, int frames, int toSkip) {
 328   int captured = RtlCaptureStackBackTrace(toSkip + 1, frames, (PVOID*)stack, NULL);
 329   for (int index = captured; index &lt; frames; index ++) {
 330     stack[index] = NULL;
 331   }
 332   return captured;
 333 }
 334 
 335 
 336 // os::current_stack_base()
 337 //
 338 //   Returns the base of the stack, which is the stack&#39;s
 339 //   starting address.  This function must be called
 340 //   while running on the stack of the thread being queried.
 341 
 342 address os::current_stack_base() {
 343   MEMORY_BASIC_INFORMATION minfo;
 344   address stack_bottom;
 345   size_t stack_size;
 346 
 347   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 348   stack_bottom =  (address)minfo.AllocationBase;
 349   stack_size = minfo.RegionSize;
 350 
 351   // Add up the sizes of all the regions with the same
 352   // AllocationBase.
 353   while (1) {
 354     VirtualQuery(stack_bottom+stack_size, &amp;minfo, sizeof(minfo));
 355     if (stack_bottom == (address)minfo.AllocationBase) {
 356       stack_size += minfo.RegionSize;
 357     } else {
 358       break;
 359     }
 360   }
 361   return stack_bottom + stack_size;
 362 }
 363 
 364 size_t os::current_stack_size() {
 365   size_t sz;
 366   MEMORY_BASIC_INFORMATION minfo;
 367   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 368   sz = (size_t)os::current_stack_base() - (size_t)minfo.AllocationBase;
 369   return sz;
 370 }
 371 
 372 bool os::committed_in_range(address start, size_t size, address&amp; committed_start, size_t&amp; committed_size) {
 373   MEMORY_BASIC_INFORMATION minfo;
 374   committed_start = NULL;
 375   committed_size = 0;
 376   address top = start + size;
 377   const address start_addr = start;
 378   while (start &lt; top) {
 379     VirtualQuery(start, &amp;minfo, sizeof(minfo));
 380     if ((minfo.State &amp; MEM_COMMIT) == 0) {  // not committed
 381       if (committed_start != NULL) {
 382         break;
 383       }
 384     } else {  // committed
 385       if (committed_start == NULL) {
 386         committed_start = start;
 387       }
 388       size_t offset = start - (address)minfo.BaseAddress;
 389       committed_size += minfo.RegionSize - offset;
 390     }
 391     start = (address)minfo.BaseAddress + minfo.RegionSize;
 392   }
 393 
 394   if (committed_start == NULL) {
 395     assert(committed_size == 0, &quot;Sanity&quot;);
 396     return false;
 397   } else {
 398     assert(committed_start &gt;= start_addr &amp;&amp; committed_start &lt; top, &quot;Out of range&quot;);
 399     // current region may go beyond the limit, trim to the limit
 400     committed_size = MIN2(committed_size, size_t(top - committed_start));
 401     return true;
 402   }
 403 }
 404 
 405 struct tm* os::localtime_pd(const time_t* clock, struct tm* res) {
 406   const struct tm* time_struct_ptr = localtime(clock);
 407   if (time_struct_ptr != NULL) {
 408     *res = *time_struct_ptr;
 409     return res;
 410   }
 411   return NULL;
 412 }
 413 
 414 struct tm* os::gmtime_pd(const time_t* clock, struct tm* res) {
 415   const struct tm* time_struct_ptr = gmtime(clock);
 416   if (time_struct_ptr != NULL) {
 417     *res = *time_struct_ptr;
 418     return res;
 419   }
 420   return NULL;
 421 }
 422 
<a name="7" id="anc7"></a>

 423 // Thread start routine for all newly created threads
 424 static unsigned __stdcall thread_native_entry(Thread* thread) {
 425 
 426   thread-&gt;record_stack_base_and_size();
 427 
 428   // Try to randomize the cache line index of hot stack frames.
 429   // This helps when threads of the same stack traces evict each other&#39;s
 430   // cache lines. The threads can be either from the same JVM instance, or
 431   // from different JVM instances. The benefit is especially true for
 432   // processors with hyperthreading technology.
 433   static int counter = 0;
 434   int pid = os::current_process_id();
 435   _alloca(((pid ^ counter++) &amp; 7) * 128);
 436 
 437   thread-&gt;initialize_thread_current();
 438 
 439   OSThread* osthr = thread-&gt;osthread();
 440   assert(osthr-&gt;get_state() == RUNNABLE, &quot;invalid os thread state&quot;);
 441 
 442   if (UseNUMA) {
 443     int lgrp_id = os::numa_get_group_id();
 444     if (lgrp_id != -1) {
 445       thread-&gt;set_lgrp_id(lgrp_id);
 446     }
 447   }
 448 
 449   // Diagnostic code to investigate JDK-6573254
 450   int res = 30115;  // non-java thread
 451   if (thread-&gt;is_Java_thread()) {
 452     res = 20115;    // java thread
 453   }
 454 
 455   log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 456 
<a name="8" id="anc8"></a><span class="line-modified"> 457   // Any exception is caught by the Vectored Exception Handler, so VM can</span>
<span class="line-modified"> 458   // generate error dump when an exception occurred in non-Java thread</span>
<span class="line-modified"> 459   // (e.g. VM thread).</span>
<span class="line-modified"> 460   thread-&gt;call_run();</span>





 461 
 462   // Note: at this point the thread object may already have deleted itself.
 463   // Do not dereference it from here on out.
 464 
 465   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 466 
 467   // One less thread is executing
 468   // When the VMThread gets here, the main thread may have already exited
 469   // which frees the CodeHeap containing the Atomic::add code
 470   if (thread != VMThread::vm_thread() &amp;&amp; VMThread::vm_thread() != NULL) {
 471     Atomic::dec(&amp;os::win32::_os_thread_count);
 472   }
 473 
 474   // Thread must not return from exit_process_or_thread(), but if it does,
 475   // let it proceed to exit normally
 476   return (unsigned)os::win32::exit_process_or_thread(os::win32::EPT_THREAD, res);
 477 }
 478 
 479 static OSThread* create_os_thread(Thread* thread, HANDLE thread_handle,
 480                                   int thread_id) {
 481   // Allocate the OSThread object
 482   OSThread* osthread = new OSThread(NULL, NULL);
 483   if (osthread == NULL) return NULL;
 484 
 485   // Initialize the JDK library&#39;s interrupt event.
 486   // This should really be done when OSThread is constructed,
 487   // but there is no way for a constructor to report failure to
 488   // allocate the event.
 489   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 490   if (interrupt_event == NULL) {
 491     delete osthread;
 492     return NULL;
 493   }
 494   osthread-&gt;set_interrupt_event(interrupt_event);
 495 
 496   // Store info on the Win32 thread into the OSThread
 497   osthread-&gt;set_thread_handle(thread_handle);
 498   osthread-&gt;set_thread_id(thread_id);
 499 
 500   if (UseNUMA) {
 501     int lgrp_id = os::numa_get_group_id();
 502     if (lgrp_id != -1) {
 503       thread-&gt;set_lgrp_id(lgrp_id);
 504     }
 505   }
 506 
 507   // Initial thread state is INITIALIZED, not SUSPENDED
 508   osthread-&gt;set_state(INITIALIZED);
 509 
 510   return osthread;
 511 }
 512 
 513 
 514 bool os::create_attached_thread(JavaThread* thread) {
 515 #ifdef ASSERT
 516   thread-&gt;verify_not_published();
 517 #endif
 518   HANDLE thread_h;
 519   if (!DuplicateHandle(main_process, GetCurrentThread(), GetCurrentProcess(),
 520                        &amp;thread_h, THREAD_ALL_ACCESS, false, 0)) {
 521     fatal(&quot;DuplicateHandle failed\n&quot;);
 522   }
 523   OSThread* osthread = create_os_thread(thread, thread_h,
 524                                         (int)current_thread_id());
 525   if (osthread == NULL) {
 526     return false;
 527   }
 528 
 529   // Initial thread state is RUNNABLE
 530   osthread-&gt;set_state(RUNNABLE);
 531 
 532   thread-&gt;set_osthread(osthread);
 533 
 534   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;).&quot;,
 535     os::current_thread_id());
 536 
 537   return true;
 538 }
 539 
 540 bool os::create_main_thread(JavaThread* thread) {
 541 #ifdef ASSERT
 542   thread-&gt;verify_not_published();
 543 #endif
 544   if (_starting_thread == NULL) {
 545     _starting_thread = create_os_thread(thread, main_thread, main_thread_id);
 546     if (_starting_thread == NULL) {
 547       return false;
 548     }
 549   }
 550 
 551   // The primordial thread is runnable from the start)
 552   _starting_thread-&gt;set_state(RUNNABLE);
 553 
 554   thread-&gt;set_osthread(_starting_thread);
 555   return true;
 556 }
 557 
 558 // Helper function to trace _beginthreadex attributes,
 559 //  similar to os::Posix::describe_pthread_attr()
 560 static char* describe_beginthreadex_attributes(char* buf, size_t buflen,
 561                                                size_t stacksize, unsigned initflag) {
 562   stringStream ss(buf, buflen);
 563   if (stacksize == 0) {
 564     ss.print(&quot;stacksize: default, &quot;);
 565   } else {
 566     ss.print(&quot;stacksize: &quot; SIZE_FORMAT &quot;k, &quot;, stacksize / 1024);
 567   }
 568   ss.print(&quot;flags: &quot;);
 569   #define PRINT_FLAG(f) if (initflag &amp; f) ss.print( #f &quot; &quot;);
 570   #define ALL(X) \
 571     X(CREATE_SUSPENDED) \
 572     X(STACK_SIZE_PARAM_IS_A_RESERVATION)
 573   ALL(PRINT_FLAG)
 574   #undef ALL
 575   #undef PRINT_FLAG
 576   return buf;
 577 }
 578 
 579 // Allocate and initialize a new OSThread
 580 bool os::create_thread(Thread* thread, ThreadType thr_type,
 581                        size_t stack_size) {
 582   unsigned thread_id;
 583 
 584   // Allocate the OSThread object
 585   OSThread* osthread = new OSThread(NULL, NULL);
 586   if (osthread == NULL) {
 587     return false;
 588   }
 589 
 590   // Initialize the JDK library&#39;s interrupt event.
 591   // This should really be done when OSThread is constructed,
 592   // but there is no way for a constructor to report failure to
 593   // allocate the event.
 594   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 595   if (interrupt_event == NULL) {
 596     delete osthread;
 597     return false;
 598   }
 599   osthread-&gt;set_interrupt_event(interrupt_event);
 600   // We don&#39;t call set_interrupted(false) as it will trip the assert in there
 601   // as we are not operating on the current thread. We don&#39;t need to call it
 602   // because the initial state is already correct.
 603 
 604   thread-&gt;set_osthread(osthread);
 605 
 606   if (stack_size == 0) {
 607     switch (thr_type) {
 608     case os::java_thread:
 609       // Java threads use ThreadStackSize which default value can be changed with the flag -Xss
 610       if (JavaThread::stack_size_at_create() &gt; 0) {
 611         stack_size = JavaThread::stack_size_at_create();
 612       }
 613       break;
 614     case os::compiler_thread:
 615       if (CompilerThreadStackSize &gt; 0) {
 616         stack_size = (size_t)(CompilerThreadStackSize * K);
 617         break;
 618       } // else fall through:
 619         // use VMThreadStackSize if CompilerThreadStackSize is not defined
 620     case os::vm_thread:
 621     case os::pgc_thread:
 622     case os::cgc_thread:
 623     case os::watcher_thread:
 624       if (VMThreadStackSize &gt; 0) stack_size = (size_t)(VMThreadStackSize * K);
 625       break;
 626     }
 627   }
 628 
 629   // Create the Win32 thread
 630   //
 631   // Contrary to what MSDN document says, &quot;stack_size&quot; in _beginthreadex()
 632   // does not specify stack size. Instead, it specifies the size of
 633   // initially committed space. The stack size is determined by
 634   // PE header in the executable. If the committed &quot;stack_size&quot; is larger
 635   // than default value in the PE header, the stack is rounded up to the
 636   // nearest multiple of 1MB. For example if the launcher has default
 637   // stack size of 320k, specifying any size less than 320k does not
 638   // affect the actual stack size at all, it only affects the initial
 639   // commitment. On the other hand, specifying &#39;stack_size&#39; larger than
 640   // default value may cause significant increase in memory usage, because
 641   // not only the stack space will be rounded up to MB, but also the
 642   // entire space is committed upfront.
 643   //
 644   // Finally Windows XP added a new flag &#39;STACK_SIZE_PARAM_IS_A_RESERVATION&#39;
 645   // for CreateThread() that can treat &#39;stack_size&#39; as stack size. However we
 646   // are not supposed to call CreateThread() directly according to MSDN
 647   // document because JVM uses C runtime library. The good news is that the
 648   // flag appears to work with _beginthredex() as well.
 649 
 650   const unsigned initflag = CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION;
 651   HANDLE thread_handle =
 652     (HANDLE)_beginthreadex(NULL,
 653                            (unsigned)stack_size,
 654                            (unsigned (__stdcall *)(void*)) thread_native_entry,
 655                            thread,
 656                            initflag,
 657                            &amp;thread_id);
 658 
 659   char buf[64];
 660   if (thread_handle != NULL) {
 661     log_info(os, thread)(&quot;Thread started (tid: %u, attributes: %s)&quot;,
 662       thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 663   } else {
 664     log_warning(os, thread)(&quot;Failed to start thread - _beginthreadex failed (%s) for attributes: %s.&quot;,
 665       os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 666     // Log some OS information which might explain why creating the thread failed.
 667     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());
 668     LogStream st(Log(os, thread)::info());
 669     os::print_memory_info(&amp;st);
 670   }
 671 
 672   if (thread_handle == NULL) {
 673     // Need to clean up stuff we&#39;ve allocated so far
 674     thread-&gt;set_osthread(NULL);
 675     delete osthread;
 676     return false;
 677   }
 678 
 679   Atomic::inc(&amp;os::win32::_os_thread_count);
 680 
 681   // Store info on the Win32 thread into the OSThread
 682   osthread-&gt;set_thread_handle(thread_handle);
 683   osthread-&gt;set_thread_id(thread_id);
 684 
 685   // Initial thread state is INITIALIZED, not SUSPENDED
 686   osthread-&gt;set_state(INITIALIZED);
 687 
 688   // The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain
 689   return true;
 690 }
 691 
 692 
 693 // Free Win32 resources related to the OSThread
 694 void os::free_thread(OSThread* osthread) {
 695   assert(osthread != NULL, &quot;osthread not set&quot;);
 696 
 697   // We are told to free resources of the argument thread,
 698   // but we can only really operate on the current thread.
 699   assert(Thread::current()-&gt;osthread() == osthread,
 700          &quot;os::free_thread but not current thread&quot;);
 701 
 702   CloseHandle(osthread-&gt;thread_handle());
 703   delete osthread;
 704 }
 705 
 706 static jlong first_filetime;
 707 static jlong initial_performance_count;
 708 static jlong performance_frequency;
 709 
 710 
 711 jlong as_long(LARGE_INTEGER x) {
 712   jlong result = 0; // initialization to avoid warning
 713   set_high(&amp;result, x.HighPart);
 714   set_low(&amp;result, x.LowPart);
 715   return result;
 716 }
 717 
 718 
 719 jlong os::elapsed_counter() {
 720   LARGE_INTEGER count;
 721   QueryPerformanceCounter(&amp;count);
 722   return as_long(count) - initial_performance_count;
 723 }
 724 
 725 
 726 jlong os::elapsed_frequency() {
 727   return performance_frequency;
 728 }
 729 
 730 
 731 julong os::available_memory() {
 732   return win32::available_memory();
 733 }
 734 
 735 julong os::win32::available_memory() {
 736   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
 737   // value if total memory is larger than 4GB
 738   MEMORYSTATUSEX ms;
 739   ms.dwLength = sizeof(ms);
 740   GlobalMemoryStatusEx(&amp;ms);
 741 
 742   return (julong)ms.ullAvailPhys;
 743 }
 744 
 745 julong os::physical_memory() {
 746   return win32::physical_memory();
 747 }
 748 
 749 bool os::has_allocatable_memory_limit(julong* limit) {
 750   MEMORYSTATUSEX ms;
 751   ms.dwLength = sizeof(ms);
 752   GlobalMemoryStatusEx(&amp;ms);
 753 #ifdef _LP64
 754   *limit = (julong)ms.ullAvailVirtual;
 755   return true;
 756 #else
 757   // Limit to 1400m because of the 2gb address space wall
 758   *limit = MIN2((julong)1400*M, (julong)ms.ullAvailVirtual);
 759   return true;
 760 #endif
 761 }
 762 
 763 int os::active_processor_count() {
 764   // User has overridden the number of active processors
 765   if (ActiveProcessorCount &gt; 0) {
 766     log_trace(os)(&quot;active_processor_count: &quot;
 767                   &quot;active processor count set by user : %d&quot;,
 768                   ActiveProcessorCount);
 769     return ActiveProcessorCount;
 770   }
 771 
 772   DWORD_PTR lpProcessAffinityMask = 0;
 773   DWORD_PTR lpSystemAffinityMask = 0;
 774   int proc_count = processor_count();
 775   if (proc_count &lt;= sizeof(UINT_PTR) * BitsPerByte &amp;&amp;
 776       GetProcessAffinityMask(GetCurrentProcess(), &amp;lpProcessAffinityMask, &amp;lpSystemAffinityMask)) {
 777     // Nof active processors is number of bits in process affinity mask
 778     int bitcount = 0;
 779     while (lpProcessAffinityMask != 0) {
 780       lpProcessAffinityMask = lpProcessAffinityMask &amp; (lpProcessAffinityMask-1);
 781       bitcount++;
 782     }
 783     return bitcount;
 784   } else {
 785     return proc_count;
 786   }
 787 }
 788 
 789 uint os::processor_id() {
 790   return (uint)GetCurrentProcessorNumber();
 791 }
 792 
 793 void os::set_native_thread_name(const char *name) {
 794 
 795   // See: http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
 796   //
 797   // Note that unfortunately this only works if the process
 798   // is already attached to a debugger; debugger must observe
 799   // the exception below to show the correct name.
 800 
 801   // If there is no debugger attached skip raising the exception
 802   if (!IsDebuggerPresent()) {
 803     return;
 804   }
 805 
 806   const DWORD MS_VC_EXCEPTION = 0x406D1388;
 807   struct {
 808     DWORD dwType;     // must be 0x1000
 809     LPCSTR szName;    // pointer to name (in user addr space)
 810     DWORD dwThreadID; // thread ID (-1=caller thread)
 811     DWORD dwFlags;    // reserved for future use, must be zero
 812   } info;
 813 
 814   info.dwType = 0x1000;
 815   info.szName = name;
 816   info.dwThreadID = -1;
 817   info.dwFlags = 0;
 818 
 819   __try {
 820     RaiseException (MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(DWORD), (const ULONG_PTR*)&amp;info );
 821   } __except(EXCEPTION_EXECUTE_HANDLER) {}
 822 }
 823 
 824 bool os::bind_to_processor(uint processor_id) {
 825   // Not yet implemented.
 826   return false;
 827 }
 828 
 829 void os::win32::initialize_performance_counter() {
 830   LARGE_INTEGER count;
 831   QueryPerformanceFrequency(&amp;count);
 832   performance_frequency = as_long(count);
 833   QueryPerformanceCounter(&amp;count);
 834   initial_performance_count = as_long(count);
 835 }
 836 
 837 
 838 double os::elapsedTime() {
 839   return (double) elapsed_counter() / (double) elapsed_frequency();
 840 }
 841 
 842 
 843 // Windows format:
 844 //   The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.
 845 // Java format:
 846 //   Java standards require the number of milliseconds since 1/1/1970
 847 
 848 // Constant offset - calculated using offset()
 849 static jlong  _offset   = 116444736000000000;
 850 // Fake time counter for reproducible results when debugging
 851 static jlong  fake_time = 0;
 852 
 853 #ifdef ASSERT
 854 // Just to be safe, recalculate the offset in debug mode
 855 static jlong _calculated_offset = 0;
 856 static int   _has_calculated_offset = 0;
 857 
 858 jlong offset() {
 859   if (_has_calculated_offset) return _calculated_offset;
 860   SYSTEMTIME java_origin;
 861   java_origin.wYear          = 1970;
 862   java_origin.wMonth         = 1;
 863   java_origin.wDayOfWeek     = 0; // ignored
 864   java_origin.wDay           = 1;
 865   java_origin.wHour          = 0;
 866   java_origin.wMinute        = 0;
 867   java_origin.wSecond        = 0;
 868   java_origin.wMilliseconds  = 0;
 869   FILETIME jot;
 870   if (!SystemTimeToFileTime(&amp;java_origin, &amp;jot)) {
 871     fatal(&quot;Error = %d\nWindows error&quot;, GetLastError());
 872   }
 873   _calculated_offset = jlong_from(jot.dwHighDateTime, jot.dwLowDateTime);
 874   _has_calculated_offset = 1;
 875   assert(_calculated_offset == _offset, &quot;Calculated and constant time offsets must be equal&quot;);
 876   return _calculated_offset;
 877 }
 878 #else
 879 jlong offset() {
 880   return _offset;
 881 }
 882 #endif
 883 
 884 jlong windows_to_java_time(FILETIME wt) {
 885   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 886   return (a - offset()) / 10000;
 887 }
 888 
 889 // Returns time ticks in (10th of micro seconds)
 890 jlong windows_to_time_ticks(FILETIME wt) {
 891   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 892   return (a - offset());
 893 }
 894 
 895 FILETIME java_to_windows_time(jlong l) {
 896   jlong a = (l * 10000) + offset();
 897   FILETIME result;
 898   result.dwHighDateTime = high(a);
 899   result.dwLowDateTime  = low(a);
 900   return result;
 901 }
 902 
 903 bool os::supports_vtime() { return true; }
 904 
 905 double os::elapsedVTime() {
 906   FILETIME created;
 907   FILETIME exited;
 908   FILETIME kernel;
 909   FILETIME user;
 910   if (GetThreadTimes(GetCurrentThread(), &amp;created, &amp;exited, &amp;kernel, &amp;user) != 0) {
 911     // the resolution of windows_to_java_time() should be sufficient (ms)
 912     return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) / MILLIUNITS;
 913   } else {
 914     return elapsedTime();
 915   }
 916 }
 917 
 918 jlong os::javaTimeMillis() {
 919   FILETIME wt;
 920   GetSystemTimeAsFileTime(&amp;wt);
 921   return windows_to_java_time(wt);
 922 }
 923 
 924 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
 925   FILETIME wt;
 926   GetSystemTimeAsFileTime(&amp;wt);
 927   jlong ticks = windows_to_time_ticks(wt); // 10th of micros
 928   jlong secs = jlong(ticks / 10000000); // 10000 * 1000
 929   seconds = secs;
 930   nanos = jlong(ticks - (secs*10000000)) * 100;
 931 }
 932 
 933 jlong os::javaTimeNanos() {
 934     LARGE_INTEGER current_count;
 935     QueryPerformanceCounter(&amp;current_count);
 936     double current = as_long(current_count);
 937     double freq = performance_frequency;
 938     jlong time = (jlong)((current/freq) * NANOSECS_PER_SEC);
 939     return time;
 940 }
 941 
 942 void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {
 943   jlong freq = performance_frequency;
 944   if (freq &lt; NANOSECS_PER_SEC) {
 945     // the performance counter is 64 bits and we will
 946     // be multiplying it -- so no wrap in 64 bits
 947     info_ptr-&gt;max_value = ALL_64_BITS;
 948   } else if (freq &gt; NANOSECS_PER_SEC) {
 949     // use the max value the counter can reach to
 950     // determine the max value which could be returned
 951     julong max_counter = (julong)ALL_64_BITS;
 952     info_ptr-&gt;max_value = (jlong)(max_counter / (freq / NANOSECS_PER_SEC));
 953   } else {
 954     // the performance counter is 64 bits and we will
 955     // be using it directly -- so no wrap in 64 bits
 956     info_ptr-&gt;max_value = ALL_64_BITS;
 957   }
 958 
 959   // using a counter, so no skipping
 960   info_ptr-&gt;may_skip_backward = false;
 961   info_ptr-&gt;may_skip_forward = false;
 962 
 963   info_ptr-&gt;kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time
 964 }
 965 
 966 char* os::local_time_string(char *buf, size_t buflen) {
 967   SYSTEMTIME st;
 968   GetLocalTime(&amp;st);
 969   jio_snprintf(buf, buflen, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,
 970                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
 971   return buf;
 972 }
 973 
 974 bool os::getTimesSecs(double* process_real_time,
 975                       double* process_user_time,
 976                       double* process_system_time) {
 977   HANDLE h_process = GetCurrentProcess();
 978   FILETIME create_time, exit_time, kernel_time, user_time;
 979   BOOL result = GetProcessTimes(h_process,
 980                                 &amp;create_time,
 981                                 &amp;exit_time,
 982                                 &amp;kernel_time,
 983                                 &amp;user_time);
 984   if (result != 0) {
 985     FILETIME wt;
 986     GetSystemTimeAsFileTime(&amp;wt);
 987     jlong rtc_millis = windows_to_java_time(wt);
 988     *process_real_time = ((double) rtc_millis) / ((double) MILLIUNITS);
 989     *process_user_time =
 990       (double) jlong_from(user_time.dwHighDateTime, user_time.dwLowDateTime) / (10 * MICROUNITS);
 991     *process_system_time =
 992       (double) jlong_from(kernel_time.dwHighDateTime, kernel_time.dwLowDateTime) / (10 * MICROUNITS);
 993     return true;
 994   } else {
 995     return false;
 996   }
 997 }
 998 
 999 void os::shutdown() {
1000   // allow PerfMemory to attempt cleanup of any persistent resources
1001   perfMemory_exit();
1002 
1003   // flush buffered output, finish log files
1004   ostream_abort();
1005 
1006   // Check for abort hook
1007   abort_hook_t abort_hook = Arguments::abort_hook();
1008   if (abort_hook != NULL) {
1009     abort_hook();
1010   }
1011 }
1012 
1013 
1014 static HANDLE dumpFile = NULL;
1015 
1016 // Check if dump file can be created.
1017 void os::check_dump_limit(char* buffer, size_t buffsz) {
1018   bool status = true;
1019   if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) &amp;&amp; !CreateCoredumpOnCrash) {
1020     jio_snprintf(buffer, buffsz, &quot;CreateCoredumpOnCrash is disabled from command line&quot;);
1021     status = false;
1022   }
1023 
1024 #ifndef ASSERT
1025   if (!os::win32::is_windows_server() &amp;&amp; FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {
1026     jio_snprintf(buffer, buffsz, &quot;Minidumps are not enabled by default on client versions of Windows&quot;);
1027     status = false;
1028   }
1029 #endif
1030 
1031   if (status) {
1032     const char* cwd = get_current_directory(NULL, 0);
1033     int pid = current_process_id();
1034     if (cwd != NULL) {
1035       jio_snprintf(buffer, buffsz, &quot;%s\\hs_err_pid%u.mdmp&quot;, cwd, pid);
1036     } else {
1037       jio_snprintf(buffer, buffsz, &quot;.\\hs_err_pid%u.mdmp&quot;, pid);
1038     }
1039 
1040     if (dumpFile == NULL &amp;&amp;
1041        (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
1042                  == INVALID_HANDLE_VALUE) {
1043       jio_snprintf(buffer, buffsz, &quot;Failed to create minidump file (0x%x).&quot;, GetLastError());
1044       status = false;
1045     }
1046   }
1047   VMError::record_coredump_status(buffer, status);
1048 }
1049 
1050 void os::abort(bool dump_core, void* siginfo, const void* context) {
1051   EXCEPTION_POINTERS ep;
1052   MINIDUMP_EXCEPTION_INFORMATION mei;
1053   MINIDUMP_EXCEPTION_INFORMATION* pmei;
1054 
1055   HANDLE hProcess = GetCurrentProcess();
1056   DWORD processId = GetCurrentProcessId();
1057   MINIDUMP_TYPE dumpType;
1058 
1059   shutdown();
1060   if (!dump_core || dumpFile == NULL) {
1061     if (dumpFile != NULL) {
1062       CloseHandle(dumpFile);
1063     }
1064     win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1065   }
1066 
1067   dumpType = (MINIDUMP_TYPE)(MiniDumpWithFullMemory | MiniDumpWithHandleData |
1068     MiniDumpWithFullMemoryInfo | MiniDumpWithThreadInfo | MiniDumpWithUnloadedModules);
1069 
1070   if (siginfo != NULL &amp;&amp; context != NULL) {
1071     ep.ContextRecord = (PCONTEXT) context;
1072     ep.ExceptionRecord = (PEXCEPTION_RECORD) siginfo;
1073 
1074     mei.ThreadId = GetCurrentThreadId();
1075     mei.ExceptionPointers = &amp;ep;
1076     pmei = &amp;mei;
1077   } else {
1078     pmei = NULL;
1079   }
1080 
1081   // Older versions of dbghelp.dll (the one shipped with Win2003 for example) may not support all
1082   // the dump types we really want. If first call fails, lets fall back to just use MiniDumpWithFullMemory then.
1083   if (!WindowsDbgHelp::miniDumpWriteDump(hProcess, processId, dumpFile, dumpType, pmei, NULL, NULL) &amp;&amp;
1084       !WindowsDbgHelp::miniDumpWriteDump(hProcess, processId, dumpFile, (MINIDUMP_TYPE)MiniDumpWithFullMemory, pmei, NULL, NULL)) {
1085     jio_fprintf(stderr, &quot;Call to MiniDumpWriteDump() failed (Error 0x%x)\n&quot;, GetLastError());
1086   }
1087   CloseHandle(dumpFile);
1088   win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1089 }
1090 
1091 // Die immediately, no exit hook, no abort hook, no cleanup.
1092 void os::die() {
1093   win32::exit_process_or_thread(win32::EPT_PROCESS_DIE, -1);
1094 }
1095 
1096 // Directory routines copied from src/win32/native/java/io/dirent_md.c
1097 //  * dirent_md.c       1.15 00/02/02
1098 //
1099 // The declarations for DIR and struct dirent are in jvm_win32.h.
1100 
1101 // Caller must have already run dirname through JVM_NativePath, which removes
1102 // duplicate slashes and converts all instances of &#39;/&#39; into &#39;\\&#39;.
1103 
1104 DIR * os::opendir(const char *dirname) {
1105   assert(dirname != NULL, &quot;just checking&quot;);   // hotspot change
1106   DIR *dirp = (DIR *)malloc(sizeof(DIR), mtInternal);
1107   DWORD fattr;                                // hotspot change
1108   char alt_dirname[4] = { 0, 0, 0, 0 };
1109 
1110   if (dirp == 0) {
1111     errno = ENOMEM;
1112     return 0;
1113   }
1114 
1115   // Win32 accepts &quot;\&quot; in its POSIX stat(), but refuses to treat it
1116   // as a directory in FindFirstFile().  We detect this case here and
1117   // prepend the current drive name.
1118   //
1119   if (dirname[1] == &#39;\0&#39; &amp;&amp; dirname[0] == &#39;\\&#39;) {
1120     alt_dirname[0] = _getdrive() + &#39;A&#39; - 1;
1121     alt_dirname[1] = &#39;:&#39;;
1122     alt_dirname[2] = &#39;\\&#39;;
1123     alt_dirname[3] = &#39;\0&#39;;
1124     dirname = alt_dirname;
1125   }
1126 
1127   dirp-&gt;path = (char *)malloc(strlen(dirname) + 5, mtInternal);
1128   if (dirp-&gt;path == 0) {
1129     free(dirp);
1130     errno = ENOMEM;
1131     return 0;
1132   }
1133   strcpy(dirp-&gt;path, dirname);
1134 
1135   fattr = GetFileAttributes(dirp-&gt;path);
1136   if (fattr == 0xffffffff) {
1137     free(dirp-&gt;path);
1138     free(dirp);
1139     errno = ENOENT;
1140     return 0;
1141   } else if ((fattr &amp; FILE_ATTRIBUTE_DIRECTORY) == 0) {
1142     free(dirp-&gt;path);
1143     free(dirp);
1144     errno = ENOTDIR;
1145     return 0;
1146   }
1147 
1148   // Append &quot;*.*&quot;, or possibly &quot;\\*.*&quot;, to path
1149   if (dirp-&gt;path[1] == &#39;:&#39; &amp;&amp;
1150       (dirp-&gt;path[2] == &#39;\0&#39; ||
1151       (dirp-&gt;path[2] == &#39;\\&#39; &amp;&amp; dirp-&gt;path[3] == &#39;\0&#39;))) {
1152     // No &#39;\\&#39; needed for cases like &quot;Z:&quot; or &quot;Z:\&quot;
1153     strcat(dirp-&gt;path, &quot;*.*&quot;);
1154   } else {
1155     strcat(dirp-&gt;path, &quot;\\*.*&quot;);
1156   }
1157 
1158   dirp-&gt;handle = FindFirstFile(dirp-&gt;path, &amp;dirp-&gt;find_data);
1159   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1160     if (GetLastError() != ERROR_FILE_NOT_FOUND) {
1161       free(dirp-&gt;path);
1162       free(dirp);
1163       errno = EACCES;
1164       return 0;
1165     }
1166   }
1167   return dirp;
1168 }
1169 
1170 struct dirent * os::readdir(DIR *dirp) {
1171   assert(dirp != NULL, &quot;just checking&quot;);      // hotspot change
1172   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1173     return NULL;
1174   }
1175 
1176   strcpy(dirp-&gt;dirent.d_name, dirp-&gt;find_data.cFileName);
1177 
1178   if (!FindNextFile(dirp-&gt;handle, &amp;dirp-&gt;find_data)) {
1179     if (GetLastError() == ERROR_INVALID_HANDLE) {
1180       errno = EBADF;
1181       return NULL;
1182     }
1183     FindClose(dirp-&gt;handle);
1184     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1185   }
1186 
1187   return &amp;dirp-&gt;dirent;
1188 }
1189 
1190 int os::closedir(DIR *dirp) {
1191   assert(dirp != NULL, &quot;just checking&quot;);      // hotspot change
1192   if (dirp-&gt;handle != INVALID_HANDLE_VALUE) {
1193     if (!FindClose(dirp-&gt;handle)) {
1194       errno = EBADF;
1195       return -1;
1196     }
1197     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1198   }
1199   free(dirp-&gt;path);
1200   free(dirp);
1201   return 0;
1202 }
1203 
1204 // This must be hard coded because it&#39;s the system&#39;s temporary
1205 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1206 const char* os::get_temp_directory() {
1207   static char path_buf[MAX_PATH];
1208   if (GetTempPath(MAX_PATH, path_buf) &gt; 0) {
1209     return path_buf;
1210   } else {
1211     path_buf[0] = &#39;\0&#39;;
1212     return path_buf;
1213   }
1214 }
1215 
1216 // Needs to be in os specific directory because windows requires another
1217 // header file &lt;direct.h&gt;
1218 const char* os::get_current_directory(char *buf, size_t buflen) {
1219   int n = static_cast&lt;int&gt;(buflen);
1220   if (buflen &gt; INT_MAX)  n = INT_MAX;
1221   return _getcwd(buf, n);
1222 }
1223 
1224 //-----------------------------------------------------------
1225 // Helper functions for fatal error handler
1226 #ifdef _WIN64
1227 // Helper routine which returns true if address in
1228 // within the NTDLL address space.
1229 //
1230 static bool _addr_in_ntdll(address addr) {
1231   HMODULE hmod;
1232   MODULEINFO minfo;
1233 
1234   hmod = GetModuleHandle(&quot;NTDLL.DLL&quot;);
1235   if (hmod == NULL) return false;
1236   if (!GetModuleInformation(GetCurrentProcess(), hmod,
1237                                           &amp;minfo, sizeof(MODULEINFO))) {
1238     return false;
1239   }
1240 
1241   if ((addr &gt;= minfo.lpBaseOfDll) &amp;&amp;
1242       (addr &lt; (address)((uintptr_t)minfo.lpBaseOfDll + (uintptr_t)minfo.SizeOfImage))) {
1243     return true;
1244   } else {
1245     return false;
1246   }
1247 }
1248 #endif
1249 
1250 struct _modinfo {
1251   address addr;
1252   char*   full_path;   // point to a char buffer
1253   int     buflen;      // size of the buffer
1254   address base_addr;
1255 };
1256 
1257 static int _locate_module_by_addr(const char * mod_fname, address base_addr,
1258                                   address top_address, void * param) {
1259   struct _modinfo *pmod = (struct _modinfo *)param;
1260   if (!pmod) return -1;
1261 
1262   if (base_addr   &lt;= pmod-&gt;addr &amp;&amp;
1263       top_address &gt; pmod-&gt;addr) {
1264     // if a buffer is provided, copy path name to the buffer
1265     if (pmod-&gt;full_path) {
1266       jio_snprintf(pmod-&gt;full_path, pmod-&gt;buflen, &quot;%s&quot;, mod_fname);
1267     }
1268     pmod-&gt;base_addr = base_addr;
1269     return 1;
1270   }
1271   return 0;
1272 }
1273 
1274 bool os::dll_address_to_library_name(address addr, char* buf,
1275                                      int buflen, int* offset) {
1276   // buf is not optional, but offset is optional
1277   assert(buf != NULL, &quot;sanity check&quot;);
1278 
1279 // NOTE: the reason we don&#39;t use SymGetModuleInfo() is it doesn&#39;t always
1280 //       return the full path to the DLL file, sometimes it returns path
1281 //       to the corresponding PDB file (debug info); sometimes it only
1282 //       returns partial path, which makes life painful.
1283 
1284   struct _modinfo mi;
1285   mi.addr      = addr;
1286   mi.full_path = buf;
1287   mi.buflen    = buflen;
1288   if (get_loaded_modules_info(_locate_module_by_addr, (void *)&amp;mi)) {
1289     // buf already contains path name
1290     if (offset) *offset = addr - mi.base_addr;
1291     return true;
1292   }
1293 
1294   buf[0] = &#39;\0&#39;;
1295   if (offset) *offset = -1;
1296   return false;
1297 }
1298 
1299 bool os::dll_address_to_function_name(address addr, char *buf,
1300                                       int buflen, int *offset,
1301                                       bool demangle) {
1302   // buf is not optional, but offset is optional
1303   assert(buf != NULL, &quot;sanity check&quot;);
1304 
1305   if (Decoder::decode(addr, buf, buflen, offset, demangle)) {
1306     return true;
1307   }
1308   if (offset != NULL)  *offset  = -1;
1309   buf[0] = &#39;\0&#39;;
1310   return false;
1311 }
1312 
1313 // save the start and end address of jvm.dll into param[0] and param[1]
1314 static int _locate_jvm_dll(const char* mod_fname, address base_addr,
1315                            address top_address, void * param) {
1316   if (!param) return -1;
1317 
1318   if (base_addr   &lt;= (address)_locate_jvm_dll &amp;&amp;
1319       top_address &gt; (address)_locate_jvm_dll) {
1320     ((address*)param)[0] = base_addr;
1321     ((address*)param)[1] = top_address;
1322     return 1;
1323   }
1324   return 0;
1325 }
1326 
1327 address vm_lib_location[2];    // start and end address of jvm.dll
1328 
1329 // check if addr is inside jvm.dll
1330 bool os::address_is_in_vm(address addr) {
1331   if (!vm_lib_location[0] || !vm_lib_location[1]) {
1332     if (!get_loaded_modules_info(_locate_jvm_dll, (void *)vm_lib_location)) {
1333       assert(false, &quot;Can&#39;t find jvm module.&quot;);
1334       return false;
1335     }
1336   }
1337 
1338   return (vm_lib_location[0] &lt;= addr) &amp;&amp; (addr &lt; vm_lib_location[1]);
1339 }
1340 
1341 // print module info; param is outputStream*
1342 static int _print_module(const char* fname, address base_address,
1343                          address top_address, void* param) {
1344   if (!param) return -1;
1345 
1346   outputStream* st = (outputStream*)param;
1347 
1348   st-&gt;print(PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; \t%s\n&quot;, base_address, top_address, fname);
1349   return 0;
1350 }
1351 
1352 // Loads .dll/.so and
1353 // in case of error it checks if .dll/.so was built for the
1354 // same architecture as Hotspot is running on
1355 void * os::dll_load(const char *name, char *ebuf, int ebuflen) {
1356   log_info(os)(&quot;attempting shared library load of %s&quot;, name);
1357 
1358   void * result = LoadLibrary(name);
1359   if (result != NULL) {
1360     Events::log(NULL, &quot;Loaded shared library %s&quot;, name);
1361     // Recalculate pdb search path if a DLL was loaded successfully.
1362     SymbolEngine::recalc_search_path();
1363     log_info(os)(&quot;shared library load of %s was successful&quot;, name);
1364     return result;
1365   }
1366   DWORD errcode = GetLastError();
1367   // Read system error message into ebuf
1368   // It may or may not be overwritten below (in the for loop and just above)
1369   lasterror(ebuf, (size_t) ebuflen);
1370   ebuf[ebuflen - 1] = &#39;\0&#39;;
1371   Events::log(NULL, &quot;Loading shared library %s failed, error code %lu&quot;, name, errcode);
1372   log_info(os)(&quot;shared library load of %s failed, error code %lu&quot;, name, errcode);
1373 
1374   if (errcode == ERROR_MOD_NOT_FOUND) {
1375     strncpy(ebuf, &quot;Can&#39;t find dependent libraries&quot;, ebuflen - 1);
1376     ebuf[ebuflen - 1] = &#39;\0&#39;;
1377     return NULL;
1378   }
1379 
1380   // Parsing dll below
1381   // If we can read dll-info and find that dll was built
1382   // for an architecture other than Hotspot is running in
1383   // - then print to buffer &quot;DLL was built for a different architecture&quot;
1384   // else call os::lasterror to obtain system error message
1385   int fd = ::open(name, O_RDONLY | O_BINARY, 0);
1386   if (fd &lt; 0) {
1387     return NULL;
1388   }
1389 
1390   uint32_t signature_offset;
1391   uint16_t lib_arch = 0;
1392   bool failed_to_get_lib_arch =
1393     ( // Go to position 3c in the dll
1394      (os::seek_to_file_offset(fd, IMAGE_FILE_PTR_TO_SIGNATURE) &lt; 0)
1395      ||
1396      // Read location of signature
1397      (sizeof(signature_offset) !=
1398      (os::read(fd, (void*)&amp;signature_offset, sizeof(signature_offset))))
1399      ||
1400      // Go to COFF File Header in dll
1401      // that is located after &quot;signature&quot; (4 bytes long)
1402      (os::seek_to_file_offset(fd,
1403      signature_offset + IMAGE_FILE_SIGNATURE_LENGTH) &lt; 0)
1404      ||
1405      // Read field that contains code of architecture
1406      // that dll was built for
1407      (sizeof(lib_arch) != (os::read(fd, (void*)&amp;lib_arch, sizeof(lib_arch))))
1408     );
1409 
1410   ::close(fd);
1411   if (failed_to_get_lib_arch) {
1412     // file i/o error - report os::lasterror(...) msg
1413     return NULL;
1414   }
1415 
1416   typedef struct {
1417     uint16_t arch_code;
1418     char* arch_name;
1419   } arch_t;
1420 
1421   static const arch_t arch_array[] = {
1422     {IMAGE_FILE_MACHINE_I386,      (char*)&quot;IA 32&quot;},
<a name="9" id="anc9"></a><span class="line-modified">1423     {IMAGE_FILE_MACHINE_AMD64,     (char*)&quot;AMD 64&quot;},</span>
<span class="line-added">1424     {IMAGE_FILE_MACHINE_ARM64,	   (char*)&quot;ARM 64&quot;}</span>
1425   };
1426 #if (defined _M_AMD64)
1427   static const uint16_t running_arch = IMAGE_FILE_MACHINE_AMD64;
1428 #elif (defined _M_IX86)
1429   static const uint16_t running_arch = IMAGE_FILE_MACHINE_I386;
<a name="10" id="anc10"></a><span class="line-added">1430 #elif (defined _M_ARM64)</span>
<span class="line-added">1431   static const uint16_t running_arch = IMAGE_FILE_MACHINE_ARM64;</span>
1432 #else
1433   #error Method os::dll_load requires that one of following \
<a name="11" id="anc11"></a><span class="line-modified">1434          is defined :_M_AMD64 or _M_IX86 or _M_ARM64</span>
1435 #endif
1436 
1437 
1438   // Obtain a string for printf operation
1439   // lib_arch_str shall contain string what platform this .dll was built for
1440   // running_arch_str shall string contain what platform Hotspot was built for
1441   char *running_arch_str = NULL, *lib_arch_str = NULL;
1442   for (unsigned int i = 0; i &lt; ARRAY_SIZE(arch_array); i++) {
1443     if (lib_arch == arch_array[i].arch_code) {
1444       lib_arch_str = arch_array[i].arch_name;
1445     }
1446     if (running_arch == arch_array[i].arch_code) {
1447       running_arch_str = arch_array[i].arch_name;
1448     }
1449   }
1450 
1451   assert(running_arch_str,
1452          &quot;Didn&#39;t find running architecture code in arch_array&quot;);
1453 
1454   // If the architecture is right
1455   // but some other error took place - report os::lasterror(...) msg
1456   if (lib_arch == running_arch) {
1457     return NULL;
1458   }
1459 
1460   if (lib_arch_str != NULL) {
1461     ::_snprintf(ebuf, ebuflen - 1,
1462                 &quot;Can&#39;t load %s-bit .dll on a %s-bit platform&quot;,
1463                 lib_arch_str, running_arch_str);
1464   } else {
1465     // don&#39;t know what architecture this dll was build for
1466     ::_snprintf(ebuf, ebuflen - 1,
1467                 &quot;Can&#39;t load this .dll (machine code=0x%x) on a %s-bit platform&quot;,
1468                 lib_arch, running_arch_str);
1469   }
1470 
1471   return NULL;
1472 }
1473 
1474 void os::print_dll_info(outputStream *st) {
1475   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
1476   get_loaded_modules_info(_print_module, (void *)st);
1477 }
1478 
1479 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1480   HANDLE   hProcess;
1481 
1482 # define MAX_NUM_MODULES 128
1483   HMODULE     modules[MAX_NUM_MODULES];
1484   static char filename[MAX_PATH];
1485   int         result = 0;
1486 
1487   int pid = os::current_process_id();
1488   hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
1489                          FALSE, pid);
1490   if (hProcess == NULL) return 0;
1491 
1492   DWORD size_needed;
1493   if (!EnumProcessModules(hProcess, modules, sizeof(modules), &amp;size_needed)) {
1494     CloseHandle(hProcess);
1495     return 0;
1496   }
1497 
1498   // number of modules that are currently loaded
1499   int num_modules = size_needed / sizeof(HMODULE);
1500 
1501   for (int i = 0; i &lt; MIN2(num_modules, MAX_NUM_MODULES); i++) {
1502     // Get Full pathname:
1503     if (!GetModuleFileNameEx(hProcess, modules[i], filename, sizeof(filename))) {
1504       filename[0] = &#39;\0&#39;;
1505     }
1506 
1507     MODULEINFO modinfo;
1508     if (!GetModuleInformation(hProcess, modules[i], &amp;modinfo, sizeof(modinfo))) {
1509       modinfo.lpBaseOfDll = NULL;
1510       modinfo.SizeOfImage = 0;
1511     }
1512 
1513     // Invoke callback function
1514     result = callback(filename, (address)modinfo.lpBaseOfDll,
1515                       (address)((u8)modinfo.lpBaseOfDll + (u8)modinfo.SizeOfImage), param);
1516     if (result) break;
1517   }
1518 
1519   CloseHandle(hProcess);
1520   return result;
1521 }
1522 
1523 bool os::get_host_name(char* buf, size_t buflen) {
1524   DWORD size = (DWORD)buflen;
1525   return (GetComputerNameEx(ComputerNameDnsHostname, buf, &amp;size) == TRUE);
1526 }
1527 
1528 void os::get_summary_os_info(char* buf, size_t buflen) {
1529   stringStream sst(buf, buflen);
1530   os::win32::print_windows_version(&amp;sst);
1531   // chop off newline character
1532   char* nl = strchr(buf, &#39;\n&#39;);
1533   if (nl != NULL) *nl = &#39;\0&#39;;
1534 }
1535 
1536 int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {
1537 #if _MSC_VER &gt;= 1900
1538   // Starting with Visual Studio 2015, vsnprint is C99 compliant.
1539   int result = ::vsnprintf(buf, len, fmt, args);
1540   // If an encoding error occurred (result &lt; 0) then it&#39;s not clear
1541   // whether the buffer is NUL terminated, so ensure it is.
1542   if ((result &lt; 0) &amp;&amp; (len &gt; 0)) {
1543     buf[len - 1] = &#39;\0&#39;;
1544   }
1545   return result;
1546 #else
1547   // Before Visual Studio 2015, vsnprintf is not C99 compliant, so use
1548   // _vsnprintf, whose behavior seems to be *mostly* consistent across
1549   // versions.  However, when len == 0, avoid _vsnprintf too, and just
1550   // go straight to _vscprintf.  The output is going to be truncated in
1551   // that case, except in the unusual case of empty output.  More
1552   // importantly, the documentation for various versions of Visual Studio
1553   // are inconsistent about the behavior of _vsnprintf when len == 0,
1554   // including it possibly being an error.
1555   int result = -1;
1556   if (len &gt; 0) {
1557     result = _vsnprintf(buf, len, fmt, args);
1558     // If output (including NUL terminator) is truncated, the buffer
1559     // won&#39;t be NUL terminated.  Add the trailing NUL specified by C99.
1560     if ((result &lt; 0) || ((size_t)result &gt;= len)) {
1561       buf[len - 1] = &#39;\0&#39;;
1562     }
1563   }
1564   if (result &lt; 0) {
1565     result = _vscprintf(fmt, args);
1566   }
1567   return result;
1568 #endif // _MSC_VER dispatch
1569 }
1570 
1571 static inline time_t get_mtime(const char* filename) {
1572   struct stat st;
1573   int ret = os::stat(filename, &amp;st);
1574   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
1575   return st.st_mtime;
1576 }
1577 
1578 int os::compare_file_modified_times(const char* file1, const char* file2) {
1579   time_t t1 = get_mtime(file1);
1580   time_t t2 = get_mtime(file2);
1581   return t1 - t2;
1582 }
1583 
1584 void os::print_os_info_brief(outputStream* st) {
1585   os::print_os_info(st);
1586 }
1587 
1588 void os::win32::print_uptime_info(outputStream* st) {
1589   unsigned long long ticks = GetTickCount64();
1590   os::print_dhm(st, &quot;OS uptime:&quot;, ticks/1000);
1591 }
1592 
1593 void os::print_os_info(outputStream* st) {
1594 #ifdef ASSERT
1595   char buffer[1024];
1596   st-&gt;print(&quot;HostName: &quot;);
1597   if (get_host_name(buffer, sizeof(buffer))) {
1598     st-&gt;print(&quot;%s &quot;, buffer);
1599   } else {
1600     st-&gt;print(&quot;N/A &quot;);
1601   }
1602 #endif
1603   st-&gt;print(&quot;OS:&quot;);
1604   os::win32::print_windows_version(st);
1605 
1606   os::win32::print_uptime_info(st);
1607 
1608 #ifdef _LP64
1609   VM_Version::print_platform_virtualization_info(st);
1610 #endif
1611 }
1612 
1613 void os::win32::print_windows_version(outputStream* st) {
1614   OSVERSIONINFOEX osvi;
1615   VS_FIXEDFILEINFO *file_info;
1616   TCHAR kernel32_path[MAX_PATH];
1617   UINT len, ret;
1618 
1619   // Use the GetVersionEx information to see if we&#39;re on a server or
1620   // workstation edition of Windows. Starting with Windows 8.1 we can&#39;t
1621   // trust the OS version information returned by this API.
1622   ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
1623   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
1624   if (!GetVersionEx((OSVERSIONINFO *)&amp;osvi)) {
1625     st-&gt;print_cr(&quot;Call to GetVersionEx failed&quot;);
1626     return;
1627   }
1628   bool is_workstation = (osvi.wProductType == VER_NT_WORKSTATION);
1629 
1630   // Get the full path to \Windows\System32\kernel32.dll and use that for
1631   // determining what version of Windows we&#39;re running on.
1632   len = MAX_PATH - (UINT)strlen(&quot;\\kernel32.dll&quot;) - 1;
1633   ret = GetSystemDirectory(kernel32_path, len);
1634   if (ret == 0 || ret &gt; len) {
1635     st-&gt;print_cr(&quot;Call to GetSystemDirectory failed&quot;);
1636     return;
1637   }
1638   strncat(kernel32_path, &quot;\\kernel32.dll&quot;, MAX_PATH - ret);
1639 
1640   DWORD version_size = GetFileVersionInfoSize(kernel32_path, NULL);
1641   if (version_size == 0) {
1642     st-&gt;print_cr(&quot;Call to GetFileVersionInfoSize failed&quot;);
1643     return;
1644   }
1645 
1646   LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);
1647   if (version_info == NULL) {
1648     st-&gt;print_cr(&quot;Failed to allocate version_info&quot;);
1649     return;
1650   }
1651 
1652   if (!GetFileVersionInfo(kernel32_path, NULL, version_size, version_info)) {
1653     os::free(version_info);
1654     st-&gt;print_cr(&quot;Call to GetFileVersionInfo failed&quot;);
1655     return;
1656   }
1657 
1658   if (!VerQueryValue(version_info, TEXT(&quot;\\&quot;), (LPVOID*)&amp;file_info, &amp;len)) {
1659     os::free(version_info);
1660     st-&gt;print_cr(&quot;Call to VerQueryValue failed&quot;);
1661     return;
1662   }
1663 
1664   int major_version = HIWORD(file_info-&gt;dwProductVersionMS);
1665   int minor_version = LOWORD(file_info-&gt;dwProductVersionMS);
1666   int build_number = HIWORD(file_info-&gt;dwProductVersionLS);
1667   int build_minor = LOWORD(file_info-&gt;dwProductVersionLS);
1668   int os_vers = major_version * 1000 + minor_version;
1669   os::free(version_info);
1670 
1671   st-&gt;print(&quot; Windows &quot;);
1672   switch (os_vers) {
1673 
1674   case 6000:
1675     if (is_workstation) {
1676       st-&gt;print(&quot;Vista&quot;);
1677     } else {
1678       st-&gt;print(&quot;Server 2008&quot;);
1679     }
1680     break;
1681 
1682   case 6001:
1683     if (is_workstation) {
1684       st-&gt;print(&quot;7&quot;);
1685     } else {
1686       st-&gt;print(&quot;Server 2008 R2&quot;);
1687     }
1688     break;
1689 
1690   case 6002:
1691     if (is_workstation) {
1692       st-&gt;print(&quot;8&quot;);
1693     } else {
1694       st-&gt;print(&quot;Server 2012&quot;);
1695     }
1696     break;
1697 
1698   case 6003:
1699     if (is_workstation) {
1700       st-&gt;print(&quot;8.1&quot;);
1701     } else {
1702       st-&gt;print(&quot;Server 2012 R2&quot;);
1703     }
1704     break;
1705 
1706   case 10000:
1707     if (is_workstation) {
1708       st-&gt;print(&quot;10&quot;);
1709     } else {
1710       // distinguish Windows Server 2016 and 2019 by build number
1711       // Windows server 2019 GA 10/2018 build number is 17763
1712       if (build_number &gt; 17762) {
1713         st-&gt;print(&quot;Server 2019&quot;);
1714       } else {
1715         st-&gt;print(&quot;Server 2016&quot;);
1716       }
1717     }
1718     break;
1719 
1720   default:
1721     // Unrecognized windows, print out its major and minor versions
1722     st-&gt;print(&quot;%d.%d&quot;, major_version, minor_version);
1723     break;
1724   }
1725 
1726   // Retrieve SYSTEM_INFO from GetNativeSystemInfo call so that we could
1727   // find out whether we are running on 64 bit processor or not
1728   SYSTEM_INFO si;
1729   ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
1730   GetNativeSystemInfo(&amp;si);
<a name="12" id="anc12"></a><span class="line-modified">1731   if ((si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) ||</span>
<span class="line-added">1732       (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ARM64)) {</span>
1733     st-&gt;print(&quot; , 64 bit&quot;);
1734   }
1735 
1736   st-&gt;print(&quot; Build %d&quot;, build_number);
1737   st-&gt;print(&quot; (%d.%d.%d.%d)&quot;, major_version, minor_version, build_number, build_minor);
1738   st-&gt;cr();
1739 }
1740 
1741 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1742   // Nothing to do for now.
1743 }
1744 
1745 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1746   HKEY key;
1747   DWORD status = RegOpenKey(HKEY_LOCAL_MACHINE,
1748                &quot;HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0&quot;, &amp;key);
1749   if (status == ERROR_SUCCESS) {
1750     DWORD size = (DWORD)buflen;
1751     status = RegQueryValueEx(key, &quot;ProcessorNameString&quot;, NULL, NULL, (byte*)buf, &amp;size);
1752     if (status != ERROR_SUCCESS) {
1753         strncpy(buf, &quot;## __CPU__&quot;, buflen);
1754     }
1755     RegCloseKey(key);
1756   } else {
1757     // Put generic cpu info to return
1758     strncpy(buf, &quot;## __CPU__&quot;, buflen);
1759   }
1760 }
1761 
1762 void os::print_memory_info(outputStream* st) {
1763   st-&gt;print(&quot;Memory:&quot;);
1764   st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
1765 
1766   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
1767   // value if total memory is larger than 4GB
1768   MEMORYSTATUSEX ms;
1769   ms.dwLength = sizeof(ms);
1770   int r1 = GlobalMemoryStatusEx(&amp;ms);
1771 
1772   if (r1 != 0) {
1773     st-&gt;print(&quot;, system-wide physical &quot; INT64_FORMAT &quot;M &quot;,
1774              (int64_t) ms.ullTotalPhys &gt;&gt; 20);
1775     st-&gt;print(&quot;(&quot; INT64_FORMAT &quot;M free)\n&quot;, (int64_t) ms.ullAvailPhys &gt;&gt; 20);
1776 
1777     st-&gt;print(&quot;TotalPageFile size &quot; INT64_FORMAT &quot;M &quot;,
1778              (int64_t) ms.ullTotalPageFile &gt;&gt; 20);
1779     st-&gt;print(&quot;(AvailPageFile size &quot; INT64_FORMAT &quot;M)&quot;,
1780              (int64_t) ms.ullAvailPageFile &gt;&gt; 20);
1781 
1782     // on 32bit Total/AvailVirtual are interesting (show us how close we get to 2-4 GB per process borders)
1783 #if defined(_M_IX86)
1784     st-&gt;print(&quot;, user-mode portion of virtual address-space &quot; INT64_FORMAT &quot;M &quot;,
1785              (int64_t) ms.ullTotalVirtual &gt;&gt; 20);
1786     st-&gt;print(&quot;(&quot; INT64_FORMAT &quot;M free)&quot;, (int64_t) ms.ullAvailVirtual &gt;&gt; 20);
1787 #endif
1788   } else {
1789     st-&gt;print(&quot;, GlobalMemoryStatusEx did not succeed so we miss some memory values.&quot;);
1790   }
1791 
1792   // extended memory statistics for a process
1793   PROCESS_MEMORY_COUNTERS_EX pmex;
1794   ZeroMemory(&amp;pmex, sizeof(PROCESS_MEMORY_COUNTERS_EX));
1795   pmex.cb = sizeof(pmex);
1796   int r2 = GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*) &amp;pmex, sizeof(pmex));
1797 
1798   if (r2 != 0) {
1799     st-&gt;print(&quot;\ncurrent process WorkingSet (physical memory assigned to process): &quot; INT64_FORMAT &quot;M, &quot;,
1800              (int64_t) pmex.WorkingSetSize &gt;&gt; 20);
1801     st-&gt;print(&quot;peak: &quot; INT64_FORMAT &quot;M\n&quot;, (int64_t) pmex.PeakWorkingSetSize &gt;&gt; 20);
1802 
1803     st-&gt;print(&quot;current process commit charge (\&quot;private bytes\&quot;): &quot; INT64_FORMAT &quot;M, &quot;,
1804              (int64_t) pmex.PrivateUsage &gt;&gt; 20);
1805     st-&gt;print(&quot;peak: &quot; INT64_FORMAT &quot;M&quot;, (int64_t) pmex.PeakPagefileUsage &gt;&gt; 20);
1806   } else {
1807     st-&gt;print(&quot;\nGetProcessMemoryInfo did not succeed so we miss some memory values.&quot;);
1808   }
1809 
1810   st-&gt;cr();
1811 }
1812 
1813 bool os::signal_sent_by_kill(const void* siginfo) {
1814   // TODO: Is this possible?
1815   return false;
1816 }
1817 
1818 void os::print_siginfo(outputStream *st, const void* siginfo) {
1819   const EXCEPTION_RECORD* const er = (EXCEPTION_RECORD*)siginfo;
1820   st-&gt;print(&quot;siginfo:&quot;);
1821 
1822   char tmp[64];
1823   if (os::exception_name(er-&gt;ExceptionCode, tmp, sizeof(tmp)) == NULL) {
1824     strcpy(tmp, &quot;EXCEPTION_??&quot;);
1825   }
1826   st-&gt;print(&quot; %s (0x%x)&quot;, tmp, er-&gt;ExceptionCode);
1827 
1828   if ((er-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||
1829        er-&gt;ExceptionCode == EXCEPTION_IN_PAGE_ERROR) &amp;&amp;
1830        er-&gt;NumberParameters &gt;= 2) {
1831     switch (er-&gt;ExceptionInformation[0]) {
1832     case 0: st-&gt;print(&quot;, reading address&quot;); break;
1833     case 1: st-&gt;print(&quot;, writing address&quot;); break;
1834     case 8: st-&gt;print(&quot;, data execution prevention violation at address&quot;); break;
1835     default: st-&gt;print(&quot;, ExceptionInformation=&quot; INTPTR_FORMAT,
1836                        er-&gt;ExceptionInformation[0]);
1837     }
1838     st-&gt;print(&quot; &quot; INTPTR_FORMAT, er-&gt;ExceptionInformation[1]);
1839   } else {
1840     int num = er-&gt;NumberParameters;
1841     if (num &gt; 0) {
1842       st-&gt;print(&quot;, ExceptionInformation=&quot;);
1843       for (int i = 0; i &lt; num; i++) {
1844         st-&gt;print(INTPTR_FORMAT &quot; &quot;, er-&gt;ExceptionInformation[i]);
1845       }
1846     }
1847   }
1848   st-&gt;cr();
1849 }
1850 
1851 bool os::signal_thread(Thread* thread, int sig, const char* reason) {
1852   // TODO: Can we kill thread?
1853   return false;
1854 }
1855 
1856 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1857   // do nothing
1858 }
1859 
1860 static char saved_jvm_path[MAX_PATH] = {0};
1861 
1862 // Find the full path to the current module, jvm.dll
1863 void os::jvm_path(char *buf, jint buflen) {
1864   // Error checking.
1865   if (buflen &lt; MAX_PATH) {
1866     assert(false, &quot;must use a large-enough buffer&quot;);
1867     buf[0] = &#39;\0&#39;;
1868     return;
1869   }
1870   // Lazy resolve the path to current module.
1871   if (saved_jvm_path[0] != 0) {
1872     strcpy(buf, saved_jvm_path);
1873     return;
1874   }
1875 
1876   buf[0] = &#39;\0&#39;;
1877   if (Arguments::sun_java_launcher_is_altjvm()) {
1878     // Support for the java launcher&#39;s &#39;-XXaltjvm=&lt;path&gt;&#39; option. Check
1879     // for a JAVA_HOME environment variable and fix up the path so it
1880     // looks like jvm.dll is installed there (append a fake suffix
1881     // hotspot/jvm.dll).
1882     char* java_home_var = ::getenv(&quot;JAVA_HOME&quot;);
1883     if (java_home_var != NULL &amp;&amp; java_home_var[0] != 0 &amp;&amp;
1884         strlen(java_home_var) &lt; (size_t)buflen) {
1885       strncpy(buf, java_home_var, buflen);
1886 
1887       // determine if this is a legacy image or modules image
1888       // modules image doesn&#39;t have &quot;jre&quot; subdirectory
1889       size_t len = strlen(buf);
1890       char* jrebin_p = buf + len;
1891       jio_snprintf(jrebin_p, buflen-len, &quot;\\jre\\bin\\&quot;);
1892       if (0 != _access(buf, 0)) {
1893         jio_snprintf(jrebin_p, buflen-len, &quot;\\bin\\&quot;);
1894       }
1895       len = strlen(buf);
1896       jio_snprintf(buf + len, buflen-len, &quot;hotspot\\jvm.dll&quot;);
1897     }
1898   }
1899 
1900   if (buf[0] == &#39;\0&#39;) {
1901     GetModuleFileName(vm_lib_handle, buf, buflen);
1902   }
1903   strncpy(saved_jvm_path, buf, MAX_PATH);
1904   saved_jvm_path[MAX_PATH - 1] = &#39;\0&#39;;
1905 }
1906 
1907 
1908 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1909 #ifndef _WIN64
1910   st-&gt;print(&quot;_&quot;);
1911 #endif
1912 }
1913 
1914 
1915 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1916 #ifndef _WIN64
1917   st-&gt;print(&quot;@%d&quot;, args_size  * sizeof(int));
1918 #endif
1919 }
1920 
1921 // This method is a copy of JDK&#39;s sysGetLastErrorString
1922 // from src/windows/hpi/src/system_md.c
1923 
1924 size_t os::lasterror(char* buf, size_t len) {
1925   DWORD errval;
1926 
1927   if ((errval = GetLastError()) != 0) {
1928     // DOS error
1929     size_t n = (size_t)FormatMessage(
1930                                      FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
1931                                      NULL,
1932                                      errval,
1933                                      0,
1934                                      buf,
1935                                      (DWORD)len,
1936                                      NULL);
1937     if (n &gt; 3) {
1938       // Drop final &#39;.&#39;, CR, LF
1939       if (buf[n - 1] == &#39;\n&#39;) n--;
1940       if (buf[n - 1] == &#39;\r&#39;) n--;
1941       if (buf[n - 1] == &#39;.&#39;) n--;
1942       buf[n] = &#39;\0&#39;;
1943     }
1944     return n;
1945   }
1946 
1947   if (errno != 0) {
1948     // C runtime error that has no corresponding DOS error code
1949     const char* s = os::strerror(errno);
1950     size_t n = strlen(s);
1951     if (n &gt;= len) n = len - 1;
1952     strncpy(buf, s, n);
1953     buf[n] = &#39;\0&#39;;
1954     return n;
1955   }
1956 
1957   return 0;
1958 }
1959 
1960 int os::get_last_error() {
1961   DWORD error = GetLastError();
1962   if (error == 0) {
1963     error = errno;
1964   }
1965   return (int)error;
1966 }
1967 
1968 // sun.misc.Signal
1969 // NOTE that this is a workaround for an apparent kernel bug where if
1970 // a signal handler for SIGBREAK is installed then that signal handler
1971 // takes priority over the console control handler for CTRL_CLOSE_EVENT.
1972 // See bug 4416763.
1973 static void (*sigbreakHandler)(int) = NULL;
1974 
1975 static void UserHandler(int sig, void *siginfo, void *context) {
1976   os::signal_notify(sig);
1977   // We need to reinstate the signal handler each time...
1978   os::signal(sig, (void*)UserHandler);
1979 }
1980 
1981 void* os::user_handler() {
1982   return (void*) UserHandler;
1983 }
1984 
1985 void* os::signal(int signal_number, void* handler) {
1986   if ((signal_number == SIGBREAK) &amp;&amp; (!ReduceSignalUsage)) {
1987     void (*oldHandler)(int) = sigbreakHandler;
1988     sigbreakHandler = (void (*)(int)) handler;
1989     return (void*) oldHandler;
1990   } else {
1991     return (void*)::signal(signal_number, (void (*)(int))handler);
1992   }
1993 }
1994 
1995 void os::signal_raise(int signal_number) {
1996   raise(signal_number);
1997 }
1998 
1999 // The Win32 C runtime library maps all console control events other than ^C
2000 // into SIGBREAK, which makes it impossible to distinguish ^BREAK from close,
2001 // logoff, and shutdown events.  We therefore install our own console handler
2002 // that raises SIGTERM for the latter cases.
2003 //
2004 static BOOL WINAPI consoleHandler(DWORD event) {
2005   switch (event) {
2006   case CTRL_C_EVENT:
2007     if (VMError::is_error_reported()) {
2008       // Ctrl-C is pressed during error reporting, likely because the error
2009       // handler fails to abort. Let VM die immediately.
2010       os::die();
2011     }
2012 
2013     os::signal_raise(SIGINT);
2014     return TRUE;
2015     break;
2016   case CTRL_BREAK_EVENT:
2017     if (sigbreakHandler != NULL) {
2018       (*sigbreakHandler)(SIGBREAK);
2019     }
2020     return TRUE;
2021     break;
2022   case CTRL_LOGOFF_EVENT: {
2023     // Don&#39;t terminate JVM if it is running in a non-interactive session,
2024     // such as a service process.
2025     USEROBJECTFLAGS flags;
2026     HANDLE handle = GetProcessWindowStation();
2027     if (handle != NULL &amp;&amp;
2028         GetUserObjectInformation(handle, UOI_FLAGS, &amp;flags,
2029         sizeof(USEROBJECTFLAGS), NULL)) {
2030       // If it is a non-interactive session, let next handler to deal
2031       // with it.
2032       if ((flags.dwFlags &amp; WSF_VISIBLE) == 0) {
2033         return FALSE;
2034       }
2035     }
2036   }
2037   case CTRL_CLOSE_EVENT:
2038   case CTRL_SHUTDOWN_EVENT:
2039     os::signal_raise(SIGTERM);
2040     return TRUE;
2041     break;
2042   default:
2043     break;
2044   }
2045   return FALSE;
2046 }
2047 
2048 // The following code is moved from os.cpp for making this
2049 // code platform specific, which it is by its very nature.
2050 
2051 // Return maximum OS signal used + 1 for internal use only
2052 // Used as exit signal for signal_thread
2053 int os::sigexitnum_pd() {
2054   return NSIG;
2055 }
2056 
2057 // a counter for each possible signal value, including signal_thread exit signal
2058 static volatile jint pending_signals[NSIG+1] = { 0 };
2059 static Semaphore* sig_sem = NULL;
2060 
2061 static void jdk_misc_signal_init() {
2062   // Initialize signal structures
2063   memset((void*)pending_signals, 0, sizeof(pending_signals));
2064 
2065   // Initialize signal semaphore
2066   sig_sem = new Semaphore();
2067 
2068   // Programs embedding the VM do not want it to attempt to receive
2069   // events like CTRL_LOGOFF_EVENT, which are used to implement the
2070   // shutdown hooks mechanism introduced in 1.3.  For example, when
2071   // the VM is run as part of a Windows NT service (i.e., a servlet
2072   // engine in a web server), the correct behavior is for any console
2073   // control handler to return FALSE, not TRUE, because the OS&#39;s
2074   // &quot;final&quot; handler for such events allows the process to continue if
2075   // it is a service (while terminating it if it is not a service).
2076   // To make this behavior uniform and the mechanism simpler, we
2077   // completely disable the VM&#39;s usage of these console events if -Xrs
2078   // (=ReduceSignalUsage) is specified.  This means, for example, that
2079   // the CTRL-BREAK thread dump mechanism is also disabled in this
2080   // case.  See bugs 4323062, 4345157, and related bugs.
2081 
2082   // Add a CTRL-C handler
2083   SetConsoleCtrlHandler(consoleHandler, TRUE);
2084 }
2085 
2086 void os::signal_notify(int sig) {
2087   if (sig_sem != NULL) {
2088     Atomic::inc(&amp;pending_signals[sig]);
2089     sig_sem-&gt;signal();
2090   } else {
2091     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
2092     // initialization isn&#39;t called.
2093     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
2094   }
2095 }
2096 
2097 static int check_pending_signals() {
2098   while (true) {
2099     for (int i = 0; i &lt; NSIG + 1; i++) {
2100       jint n = pending_signals[i];
2101       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {
2102         return i;
2103       }
2104     }
2105     JavaThread *thread = JavaThread::current();
2106 
2107     ThreadBlockInVM tbivm(thread);
2108 
2109     bool threadIsSuspended;
2110     do {
2111       thread-&gt;set_suspend_equivalent();
2112       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2113       sig_sem-&gt;wait();
2114 
2115       // were we externally suspended while we were waiting?
2116       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2117       if (threadIsSuspended) {
2118         // The semaphore has been incremented, but while we were waiting
2119         // another thread suspended us. We don&#39;t want to continue running
2120         // while suspended because that would surprise the thread that
2121         // suspended us.
2122         sig_sem-&gt;signal();
2123 
2124         thread-&gt;java_suspend_self();
2125       }
2126     } while (threadIsSuspended);
2127   }
2128 }
2129 
2130 int os::signal_wait() {
2131   return check_pending_signals();
2132 }
2133 
2134 // Implicit OS exception handling
2135 
2136 LONG Handle_Exception(struct _EXCEPTION_POINTERS* exceptionInfo,
2137                       address handler) {
2138   JavaThread* thread = (JavaThread*) Thread::current_or_null();
2139   // Save pc in thread
2140 #ifdef _M_AMD64
2141   // Do not blow up if no thread info available.
2142   if (thread) {
2143     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Rip);
2144   }
2145   // Set pc to handler
2146   exceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)handler;
<a name="13" id="anc13"></a><span class="line-added">2147 #elif defined(_M_ARM64)</span>
<span class="line-added">2148   // Do not blow up if no thread info available.</span>
<span class="line-added">2149   if (thread) {</span>
<span class="line-added">2150     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Pc);</span>
<span class="line-added">2151   }</span>
<span class="line-added">2152   // Set pc to handler</span>
<span class="line-added">2153   exceptionInfo-&gt;ContextRecord-&gt;Pc = (DWORD64)handler;</span>
2154 #else
2155   // Do not blow up if no thread info available.
2156   if (thread) {
2157     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Eip);
2158   }
2159   // Set pc to handler
2160   exceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)(DWORD_PTR)handler;
2161 #endif
2162 
2163   // Continue the execution
2164   return EXCEPTION_CONTINUE_EXECUTION;
2165 }
2166 
2167 
2168 // Used for PostMortemDump
2169 extern &quot;C&quot; void safepoints();
2170 extern &quot;C&quot; void find(int x);
2171 extern &quot;C&quot; void events();
2172 
2173 // According to Windows API documentation, an illegal instruction sequence should generate
2174 // the 0xC000001C exception code. However, real world experience shows that occasionnaly
2175 // the execution of an illegal instruction can generate the exception code 0xC000001E. This
2176 // seems to be an undocumented feature of Win NT 4.0 (and probably other Windows systems).
2177 
2178 #define EXCEPTION_ILLEGAL_INSTRUCTION_2 0xC000001E
2179 
2180 // From &quot;Execution Protection in the Windows Operating System&quot; draft 0.35
2181 // Once a system header becomes available, the &quot;real&quot; define should be
2182 // included or copied here.
2183 #define EXCEPTION_INFO_EXEC_VIOLATION 0x08
2184 
2185 // Windows Vista/2008 heap corruption check
2186 #define EXCEPTION_HEAP_CORRUPTION        0xC0000374
2187 
2188 // All Visual C++ exceptions thrown from code generated by the Microsoft Visual
2189 // C++ compiler contain this error code. Because this is a compiler-generated
2190 // error, the code is not listed in the Win32 API header files.
2191 // The code is actually a cryptic mnemonic device, with the initial &quot;E&quot;
2192 // standing for &quot;exception&quot; and the final 3 bytes (0x6D7363) representing the
2193 // ASCII values of &quot;msc&quot;.
2194 
2195 #define EXCEPTION_UNCAUGHT_CXX_EXCEPTION    0xE06D7363
2196 
2197 #define def_excpt(val) { #val, (val) }
2198 
2199 static const struct { const char* name; uint number; } exceptlabels[] = {
2200     def_excpt(EXCEPTION_ACCESS_VIOLATION),
2201     def_excpt(EXCEPTION_DATATYPE_MISALIGNMENT),
2202     def_excpt(EXCEPTION_BREAKPOINT),
2203     def_excpt(EXCEPTION_SINGLE_STEP),
2204     def_excpt(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
2205     def_excpt(EXCEPTION_FLT_DENORMAL_OPERAND),
2206     def_excpt(EXCEPTION_FLT_DIVIDE_BY_ZERO),
2207     def_excpt(EXCEPTION_FLT_INEXACT_RESULT),
2208     def_excpt(EXCEPTION_FLT_INVALID_OPERATION),
2209     def_excpt(EXCEPTION_FLT_OVERFLOW),
2210     def_excpt(EXCEPTION_FLT_STACK_CHECK),
2211     def_excpt(EXCEPTION_FLT_UNDERFLOW),
2212     def_excpt(EXCEPTION_INT_DIVIDE_BY_ZERO),
2213     def_excpt(EXCEPTION_INT_OVERFLOW),
2214     def_excpt(EXCEPTION_PRIV_INSTRUCTION),
2215     def_excpt(EXCEPTION_IN_PAGE_ERROR),
2216     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION),
2217     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION_2),
2218     def_excpt(EXCEPTION_NONCONTINUABLE_EXCEPTION),
2219     def_excpt(EXCEPTION_STACK_OVERFLOW),
2220     def_excpt(EXCEPTION_INVALID_DISPOSITION),
2221     def_excpt(EXCEPTION_GUARD_PAGE),
2222     def_excpt(EXCEPTION_INVALID_HANDLE),
2223     def_excpt(EXCEPTION_UNCAUGHT_CXX_EXCEPTION),
2224     def_excpt(EXCEPTION_HEAP_CORRUPTION)
2225 };
2226 
2227 #undef def_excpt
2228 
2229 const char* os::exception_name(int exception_code, char *buf, size_t size) {
2230   uint code = static_cast&lt;uint&gt;(exception_code);
2231   for (uint i = 0; i &lt; ARRAY_SIZE(exceptlabels); ++i) {
2232     if (exceptlabels[i].number == code) {
2233       jio_snprintf(buf, size, &quot;%s&quot;, exceptlabels[i].name);
2234       return buf;
2235     }
2236   }
2237 
2238   return NULL;
2239 }
2240 
2241 //-----------------------------------------------------------------------------
2242 LONG Handle_IDiv_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2243   // handle exception caused by idiv; should only happen for -MinInt/-1
2244   // (division by zero is handled explicitly)
2245 #ifdef  _M_AMD64
2246   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2247   address pc = (address)ctx-&gt;Rip;
2248   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; pc[1] == 0xF7 || pc[0] == 0xF7, &quot;not an idiv opcode&quot;);
2249   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; (pc[2] &amp; ~0x7) == 0xF8 || (pc[1] &amp; ~0x7) == 0xF8, &quot;cannot handle non-register operands&quot;);
2250   if (pc[0] == 0xF7) {
2251     // set correct result values and continue after idiv instruction
2252     ctx-&gt;Rip = (DWORD64)pc + 2;        // idiv reg, reg  is 2 bytes
2253   } else {
2254     ctx-&gt;Rip = (DWORD64)pc + 3;        // REX idiv reg, reg  is 3 bytes
2255   }
2256   // Do not set ctx-&gt;Rax as it already contains the correct value (either 32 or 64 bit, depending on the operation)
2257   // this is the case because the exception only happens for -MinValue/-1 and -MinValue is always in rax because of the
2258   // idiv opcode (0xF7).
2259   ctx-&gt;Rdx = (DWORD)0;             // remainder
2260   // Continue the execution
<a name="14" id="anc14"></a><span class="line-added">2261 #elif defined(_M_ARM64)</span>
<span class="line-added">2262   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;</span>
<span class="line-added">2263   address pc = (address)ctx-&gt;Sp;</span>
<span class="line-added">2264   assert(pc[0] == 0x83, &quot;not an sdiv opcode&quot;); //Fixme did i get the right opcode?</span>
<span class="line-added">2265   assert(ctx-&gt;X4 == min_jint, &quot;unexpected idiv exception&quot;);</span>
<span class="line-added">2266   // set correct result values and continue after idiv instruction</span>
<span class="line-added">2267   ctx-&gt;Pc = (uint64_t)pc + 4;        // idiv reg, reg, reg  is 4 bytes</span>
<span class="line-added">2268   ctx-&gt;X4 = (uint64_t)min_jint;      // result</span>
<span class="line-added">2269   ctx-&gt;X5 = (uint64_t)0;             // remainder</span>
<span class="line-added">2270   // Continue the execution</span>
2271 #else
2272   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2273   address pc = (address)ctx-&gt;Eip;
2274   assert(pc[0] == 0xF7, &quot;not an idiv opcode&quot;);
2275   assert((pc[1] &amp; ~0x7) == 0xF8, &quot;cannot handle non-register operands&quot;);
2276   assert(ctx-&gt;Eax == min_jint, &quot;unexpected idiv exception&quot;);
2277   // set correct result values and continue after idiv instruction
2278   ctx-&gt;Eip = (DWORD)pc + 2;        // idiv reg, reg  is 2 bytes
2279   ctx-&gt;Eax = (DWORD)min_jint;      // result
2280   ctx-&gt;Edx = (DWORD)0;             // remainder
2281   // Continue the execution
2282 #endif
2283   return EXCEPTION_CONTINUE_EXECUTION;
2284 }
2285 
<a name="15" id="anc15"></a><span class="line-added">2286 #if defined(_M_AMD64) || defined(_M_IX86)</span>
2287 //-----------------------------------------------------------------------------
2288 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2289   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2290 #ifndef  _WIN64
2291   // handle exception caused by native method modifying control word
2292   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2293 
2294   switch (exception_code) {
2295   case EXCEPTION_FLT_DENORMAL_OPERAND:
2296   case EXCEPTION_FLT_DIVIDE_BY_ZERO:
2297   case EXCEPTION_FLT_INEXACT_RESULT:
2298   case EXCEPTION_FLT_INVALID_OPERATION:
2299   case EXCEPTION_FLT_OVERFLOW:
2300   case EXCEPTION_FLT_STACK_CHECK:
2301   case EXCEPTION_FLT_UNDERFLOW:
2302     jint fp_control_word = (* (jint*) StubRoutines::addr_fpu_cntrl_wrd_std());
2303     if (fp_control_word != ctx-&gt;FloatSave.ControlWord) {
2304       // Restore FPCW and mask out FLT exceptions
2305       ctx-&gt;FloatSave.ControlWord = fp_control_word | 0xffffffc0;
2306       // Mask out pending FLT exceptions
2307       ctx-&gt;FloatSave.StatusWord &amp;=  0xffffff00;
2308       return EXCEPTION_CONTINUE_EXECUTION;
2309     }
2310   }
2311 
2312   if (prev_uef_handler != NULL) {
2313     // We didn&#39;t handle this exception so pass it to the previous
2314     // UnhandledExceptionFilter.
2315     return (prev_uef_handler)(exceptionInfo);
2316   }
2317 #else // !_WIN64
2318   // On Windows, the mxcsr control bits are non-volatile across calls
2319   // See also CR 6192333
2320   //
2321   jint MxCsr = INITIAL_MXCSR;
2322   // we can&#39;t use StubRoutines::addr_mxcsr_std()
2323   // because in Win64 mxcsr is not saved there
2324   if (MxCsr != ctx-&gt;MxCsr) {
2325     ctx-&gt;MxCsr = MxCsr;
2326     return EXCEPTION_CONTINUE_EXECUTION;
2327   }
2328 #endif // !_WIN64
2329 
2330   return EXCEPTION_CONTINUE_SEARCH;
2331 }
<a name="16" id="anc16"></a><span class="line-added">2332 #endif</span>
2333 
<a name="17" id="anc17"></a><span class="line-modified">2334 void report_error(Thread* t, DWORD exception_code,</span>
<span class="line-added">2335                                 address addr, void* siginfo, void* context);</span>
<span class="line-added">2336 void report_error(Thread* t, DWORD exception_code,</span>
2337                                 address addr, void* siginfo, void* context) {
2338   VMError::report_and_die(t, exception_code, addr, siginfo, context);
2339 
2340   // If UseOsErrorReporting, this will return here and save the error file
2341   // somewhere where we can find it in the minidump.
2342 }
2343 
<a name="18" id="anc18"></a>





















































2344 //-----------------------------------------------------------------------------
2345 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2346   if (InterceptOSException) return EXCEPTION_CONTINUE_SEARCH;
2347   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
<a name="19" id="anc19"></a><span class="line-modified">2348   PEXCEPTION_RECORD exception_record = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="line-added">2349   address addr = (address) exception_record-&gt;ExceptionInformation[1];</span>
<span class="line-added">2350 #if defined(_M_ARM64)</span>
<span class="line-added">2351   address pc = (address)exceptionInfo-&gt;ContextRecord-&gt;Pc;</span>
<span class="line-added">2352 #elif defined(_M_AMD64)</span>
2353   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;
2354 #else
2355   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2356 #endif
2357   Thread* t = Thread::current_or_null_safe();
2358 
2359   // Handle SafeFetch32 and SafeFetchN exceptions.
2360   if (StubRoutines::is_safefetch_fault(pc)) {
2361     return Handle_Exception(exceptionInfo, StubRoutines::continuation_for_safefetch_fault(pc));
2362   }
2363 
2364 #ifndef _WIN64
2365   // Execution protection violation - win32 running on AMD64 only
2366   // Handled first to avoid misdiagnosis as a &quot;normal&quot; access violation;
2367   // This is safe to do because we have a new/unique ExceptionInformation
2368   // code for this condition.
2369   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
<a name="20" id="anc20"></a><span class="line-modified">2370     int exception_subcode = (int) exception_record-&gt;ExceptionInformation[0];</span>


2371 
2372     if (exception_subcode == EXCEPTION_INFO_EXEC_VIOLATION) {
2373       int page_size = os::vm_page_size();
2374 
2375       // Make sure the pc and the faulting address are sane.
2376       //
2377       // If an instruction spans a page boundary, and the page containing
2378       // the beginning of the instruction is executable but the following
2379       // page is not, the pc and the faulting address might be slightly
2380       // different - we still want to unguard the 2nd page in this case.
2381       //
2382       // 15 bytes seems to be a (very) safe value for max instruction size.
2383       bool pc_is_near_addr =
2384         (pointer_delta((void*) addr, (void*) pc, sizeof(char)) &lt; 15);
2385       bool instr_spans_page_boundary =
2386         (align_down((intptr_t) pc ^ (intptr_t) addr,
2387                          (intptr_t) page_size) &gt; 0);
2388 
2389       if (pc == addr || (pc_is_near_addr &amp;&amp; instr_spans_page_boundary)) {
2390         static volatile address last_addr =
2391           (address) os::non_memory_address_word();
2392 
2393         // In conservative mode, don&#39;t unguard unless the address is in the VM
2394         if (UnguardOnExecutionViolation &gt; 0 &amp;&amp; addr != last_addr &amp;&amp;
2395             (UnguardOnExecutionViolation &gt; 1 || os::address_is_in_vm(addr))) {
2396 
2397           // Set memory to RWX and retry
2398           address page_start = align_down(addr, page_size);
2399           bool res = os::protect_memory((char*) page_start, page_size,
2400                                         os::MEM_PROT_RWX);
2401 
2402           log_debug(os)(&quot;Execution protection violation &quot;
2403                         &quot;at &quot; INTPTR_FORMAT
2404                         &quot;, unguarding &quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(addr),
2405                         p2i(page_start), (res ? &quot;success&quot; : os::strerror(errno)));
2406 
2407           // Set last_addr so if we fault again at the same address, we don&#39;t
2408           // end up in an endless loop.
2409           //
2410           // There are two potential complications here.  Two threads trapping
2411           // at the same address at the same time could cause one of the
2412           // threads to think it already unguarded, and abort the VM.  Likely
2413           // very rare.
2414           //
2415           // The other race involves two threads alternately trapping at
2416           // different addresses and failing to unguard the page, resulting in
2417           // an endless loop.  This condition is probably even more unlikely
2418           // than the first.
2419           //
2420           // Although both cases could be avoided by using locks or thread
2421           // local last_addr, these solutions are unnecessary complication:
2422           // this handler is a best-effort safety net, not a complete solution.
2423           // It is disabled by default and should only be used as a workaround
2424           // in case we missed any no-execute-unsafe VM code.
2425 
2426           last_addr = addr;
2427 
2428           return EXCEPTION_CONTINUE_EXECUTION;
2429         }
2430       }
2431 
2432       // Last unguard failed or not unguarding
2433       tty-&gt;print_raw_cr(&quot;Execution protection violation&quot;);
2434       report_error(t, exception_code, addr, exceptionInfo-&gt;ExceptionRecord,
2435                    exceptionInfo-&gt;ContextRecord);
2436       return EXCEPTION_CONTINUE_SEARCH;
2437     }
2438   }
2439 #endif // _WIN64
2440 
<a name="21" id="anc21"></a><span class="line-added">2441 #if defined(_M_AMD64) || defined(_M_IX86)</span>
2442   if ((exception_code == EXCEPTION_ACCESS_VIOLATION) &amp;&amp;
2443       VM_Version::is_cpuinfo_segv_addr(pc)) {
2444     // Verify that OS save/restore AVX registers.
2445     return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr());
2446   }
<a name="22" id="anc22"></a><span class="line-added">2447 #endif</span>
2448 
2449   if (t != NULL &amp;&amp; t-&gt;is_Java_thread()) {
2450     JavaThread* thread = (JavaThread*) t;
2451     bool in_java = thread-&gt;thread_state() == _thread_in_Java;
<a name="23" id="anc23"></a><span class="line-added">2452     bool in_native = thread-&gt;thread_state() == _thread_in_native;</span>
<span class="line-added">2453     bool in_vm = thread-&gt;thread_state() == _thread_in_vm;</span>
<span class="line-added">2454     CodeBlob* cb = in_java ? CodeCache::find_blob_unsafe(pc) : NULL;</span>
2455 
2456     // Handle potential stack overflows up front.
2457     if (exception_code == EXCEPTION_STACK_OVERFLOW) {
2458       if (thread-&gt;stack_guards_enabled()) {
2459         if (in_java) {
2460           frame fr;
<a name="24" id="anc24"></a>

2461           if (os::win32::get_frame_at_stack_banging_point(thread, exceptionInfo, pc, &amp;fr)) {
2462             assert(fr.is_java_frame(), &quot;Must be a Java frame&quot;);
2463             SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
2464           }
2465         }
2466         // Yellow zone violation.  The o/s has unprotected the first yellow
2467         // zone page for us.  Note:  must call disable_stack_yellow_zone to
2468         // update the enabled status, even if the zone contains only one page.
<a name="25" id="anc25"></a><span class="line-modified">2469         assert(!in_vm, &quot;Undersized StackShadowPages&quot;);</span>
2470         thread-&gt;disable_stack_yellow_reserved_zone();
2471         // If not in java code, return and hope for the best.
2472         return in_java
2473             ? Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW))
2474             :  EXCEPTION_CONTINUE_EXECUTION;
2475       } else {
2476         // Fatal red zone violation.
2477         thread-&gt;disable_stack_red_zone();
2478         tty-&gt;print_raw_cr(&quot;An unrecoverable stack overflow has occurred.&quot;);
2479         report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2480                       exceptionInfo-&gt;ContextRecord);
2481         return EXCEPTION_CONTINUE_SEARCH;
2482       }
2483     } else if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
<a name="26" id="anc26"></a>
2484       if (in_java) {
<a name="27" id="anc27"></a><span class="line-modified">2485         // Either stack overflow or null pointer exception.</span>

2486         address stack_end = thread-&gt;stack_end();
2487         if (addr &lt; stack_end &amp;&amp; addr &gt;= stack_end - os::vm_page_size()) {
2488           // Stack overflow.
2489           assert(!os::uses_stack_guard_pages(),
2490                  &quot;should be caught by red zone code above.&quot;);
2491           return Handle_Exception(exceptionInfo,
2492                                   SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW));
2493         }
2494         // Check for safepoint polling and implicit null
2495         // We only expect null pointers in the stubs (vtable)
2496         // the rest are checked explicitly now.
<a name="28" id="anc28"></a>
2497         if (cb != NULL) {
2498           if (os::is_poll_address(addr)) {
2499             address stub = SharedRuntime::get_poll_stub(pc);
2500             return Handle_Exception(exceptionInfo, stub);
2501           }
2502         }
<a name="29" id="anc29"></a>
2503 #ifdef _WIN64
<a name="30" id="anc30"></a><span class="line-modified">2504         // If it&#39;s a legal stack address map the entire region in</span>
<span class="line-modified">2505         //</span>
<span class="line-modified">2506         if (addr &gt; thread-&gt;stack_reserved_zone_base() &amp;&amp; addr &lt; thread-&gt;stack_base()) {</span>
<span class="line-modified">2507           addr = (address)((uintptr_t)addr &amp; (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));</span>
<span class="line-modified">2508           os::commit_memory((char *)addr, thread-&gt;stack_base() - addr, !ExecMem);</span>
<span class="line-modified">2509           return EXCEPTION_CONTINUE_EXECUTION;</span>
<span class="line-modified">2510         }</span>




2511 #endif
<a name="31" id="anc31"></a><span class="line-modified">2512         // Null pointer exception.</span>
<span class="line-modified">2513         if (MacroAssembler::uses_implicit_null_check((void*)addr)) {</span>
<span class="line-modified">2514           address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);</span>
<span class="line-modified">2515           if (stub != NULL) return Handle_Exception(exceptionInfo, stub);</span>
<span class="line-modified">2516         }</span>
<span class="line-modified">2517       }</span>
<span class="line-modified">2518 </span>
<span class="line-modified">2519       // Unsafe memory access</span>
<span class="line-modified">2520       CompiledMethod* nm = cb != NULL ? cb-&gt;as_compiled_method_or_null() : NULL;</span>
<span class="line-modified">2521       bool is_unsafe_arraycopy = (in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);</span>
<span class="line-added">2522       if (is_unsafe_arraycopy ||</span>
<span class="line-added">2523           ((in_native || in_vm) &amp;&amp; thread-&gt;doing_unsafe_access()) ||</span>
<span class="line-added">2524           (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {</span>
<span class="line-added">2525         address next_pc =  Assembler::locate_next_instruction(pc);</span>
<span class="line-added">2526         if (is_unsafe_arraycopy) {</span>
<span class="line-added">2527           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
2528         }
<a name="32" id="anc32"></a><span class="line-added">2529         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, next_pc));</span>
2530       }
2531 
2532 #ifdef _WIN64
2533       // Special care for fast JNI field accessors.
2534       // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks
2535       // in and the heap gets shrunk before the field access.
<a name="33" id="anc33"></a><span class="line-modified">2536       address slowcase_pc = JNI_FastGetField::find_slowcase_pc(pc);</span>
<span class="line-modified">2537       if (slowcase_pc != (address)-1) {</span>
<span class="line-modified">2538         return Handle_Exception(exceptionInfo, slowcase_pc);</span>


2539       }
2540 #endif
2541 
2542       // Stack overflow or null pointer exception in native code.
2543       report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2544                    exceptionInfo-&gt;ContextRecord);
2545       return EXCEPTION_CONTINUE_SEARCH;
<a name="34" id="anc34"></a><span class="line-modified">2546     } else if (exception_code == EXCEPTION_IN_PAGE_ERROR) {</span>
<span class="line-modified">2547       CompiledMethod* nm = cb != NULL ? cb-&gt;as_compiled_method_or_null() : NULL;</span>
<span class="line-modified">2548       bool is_unsafe_arraycopy = (in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);</span>
<span class="line-modified">2549       if (((in_vm || in_native || is_unsafe_arraycopy) &amp;&amp; thread-&gt;doing_unsafe_access()) ||</span>












2550           (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {
2551         address next_pc =  Assembler::locate_next_instruction(pc);
2552         if (is_unsafe_arraycopy) {
2553           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
2554         }
2555         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, next_pc));
2556       }
2557     }
2558 
<a name="35" id="anc35"></a><span class="line-added">2559 #ifdef _M_ARM64</span>
<span class="line-added">2560     if (in_java &amp;&amp;</span>
<span class="line-added">2561         (exception_code == EXCEPTION_ILLEGAL_INSTRUCTION ||</span>
<span class="line-added">2562           exception_code == EXCEPTION_ILLEGAL_INSTRUCTION_2)) {</span>
<span class="line-added">2563       if (nativeInstruction_at(pc)-&gt;is_sigill_zombie_not_entrant()) {</span>
<span class="line-added">2564         if (TraceTraps) {</span>
<span class="line-added">2565           tty-&gt;print_cr(&quot;trap: zombie_not_entrant&quot;);</span>
<span class="line-added">2566         }</span>
<span class="line-added">2567         return Handle_Exception(exceptionInfo, SharedRuntime::get_handle_wrong_method_stub());</span>
<span class="line-added">2568       }</span>
<span class="line-added">2569     }</span>
<span class="line-added">2570 #endif</span>
<span class="line-added">2571 </span>
2572     if (in_java) {
2573       switch (exception_code) {
2574       case EXCEPTION_INT_DIVIDE_BY_ZERO:
2575         return Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO));
2576 
2577       case EXCEPTION_INT_OVERFLOW:
2578         return Handle_IDiv_Exception(exceptionInfo);
2579 
2580       } // switch
2581     }
<a name="36" id="anc36"></a><span class="line-added">2582 </span>
<span class="line-added">2583 #if defined(_M_AMD64) || defined(_M_IX86)</span>
2584     if (((thread-&gt;thread_state() == _thread_in_Java) ||
2585          (thread-&gt;thread_state() == _thread_in_native)) &amp;&amp;
2586          exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
2587       LONG result=Handle_FLT_Exception(exceptionInfo);
2588       if (result==EXCEPTION_CONTINUE_EXECUTION) return result;
2589     }
<a name="37" id="anc37"></a><span class="line-added">2590 #endif</span>
2591   }
2592 
2593   if (exception_code != EXCEPTION_BREAKPOINT) {
2594     report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2595                  exceptionInfo-&gt;ContextRecord);
2596   }
2597   return EXCEPTION_CONTINUE_SEARCH;
2598 }
2599 
2600 #ifndef _WIN64
2601 // Special care for fast JNI accessors.
2602 // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in and
2603 // the heap gets shrunk before the field access.
2604 // Need to install our own structured exception handler since native code may
2605 // install its own.
2606 LONG WINAPI fastJNIAccessorExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2607   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2608   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2609     address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2610     address addr = JNI_FastGetField::find_slowcase_pc(pc);
2611     if (addr != (address)-1) {
2612       return Handle_Exception(exceptionInfo, addr);
2613     }
2614   }
2615   return EXCEPTION_CONTINUE_SEARCH;
2616 }
2617 
2618 #define DEFINE_FAST_GETFIELD(Return, Fieldname, Result)                     \
2619   Return JNICALL jni_fast_Get##Result##Field_wrapper(JNIEnv *env,           \
2620                                                      jobject obj,           \
2621                                                      jfieldID fieldID) {    \
2622     __try {                                                                 \
2623       return (*JNI_FastGetField::jni_fast_Get##Result##Field_fp)(env,       \
2624                                                                  obj,       \
2625                                                                  fieldID);  \
2626     } __except(fastJNIAccessorExceptionFilter((_EXCEPTION_POINTERS*)        \
2627                                               _exception_info())) {         \
2628     }                                                                       \
2629     return 0;                                                               \
2630   }
2631 
2632 DEFINE_FAST_GETFIELD(jboolean, bool,   Boolean)
2633 DEFINE_FAST_GETFIELD(jbyte,    byte,   Byte)
2634 DEFINE_FAST_GETFIELD(jchar,    char,   Char)
2635 DEFINE_FAST_GETFIELD(jshort,   short,  Short)
2636 DEFINE_FAST_GETFIELD(jint,     int,    Int)
2637 DEFINE_FAST_GETFIELD(jlong,    long,   Long)
2638 DEFINE_FAST_GETFIELD(jfloat,   float,  Float)
2639 DEFINE_FAST_GETFIELD(jdouble,  double, Double)
2640 
2641 address os::win32::fast_jni_accessor_wrapper(BasicType type) {
2642   switch (type) {
2643   case T_BOOLEAN: return (address)jni_fast_GetBooleanField_wrapper;
2644   case T_BYTE:    return (address)jni_fast_GetByteField_wrapper;
2645   case T_CHAR:    return (address)jni_fast_GetCharField_wrapper;
2646   case T_SHORT:   return (address)jni_fast_GetShortField_wrapper;
2647   case T_INT:     return (address)jni_fast_GetIntField_wrapper;
2648   case T_LONG:    return (address)jni_fast_GetLongField_wrapper;
2649   case T_FLOAT:   return (address)jni_fast_GetFloatField_wrapper;
2650   case T_DOUBLE:  return (address)jni_fast_GetDoubleField_wrapper;
2651   default:        ShouldNotReachHere();
2652   }
2653   return (address)-1;
2654 }
2655 #endif
2656 
2657 // Virtual Memory
2658 
2659 int os::vm_page_size() { return os::win32::vm_page_size(); }
2660 int os::vm_allocation_granularity() {
2661   return os::win32::vm_allocation_granularity();
2662 }
2663 
2664 // Windows large page support is available on Windows 2003. In order to use
2665 // large page memory, the administrator must first assign additional privilege
2666 // to the user:
2667 //   + select Control Panel -&gt; Administrative Tools -&gt; Local Security Policy
2668 //   + select Local Policies -&gt; User Rights Assignment
2669 //   + double click &quot;Lock pages in memory&quot;, add users and/or groups
2670 //   + reboot
2671 // Note the above steps are needed for administrator as well, as administrators
2672 // by default do not have the privilege to lock pages in memory.
2673 //
2674 // Note about Windows 2003: although the API supports committing large page
2675 // memory on a page-by-page basis and VirtualAlloc() returns success under this
2676 // scenario, I found through experiment it only uses large page if the entire
2677 // memory region is reserved and committed in a single VirtualAlloc() call.
2678 // This makes Windows large page support more or less like Solaris ISM, in
2679 // that the entire heap must be committed upfront. This probably will change
2680 // in the future, if so the code below needs to be revisited.
2681 
2682 #ifndef MEM_LARGE_PAGES
2683   #define MEM_LARGE_PAGES 0x20000000
2684 #endif
2685 
2686 static HANDLE    _hProcess;
2687 static HANDLE    _hToken;
2688 
2689 // Container for NUMA node list info
2690 class NUMANodeListHolder {
2691  private:
2692   int *_numa_used_node_list;  // allocated below
2693   int _numa_used_node_count;
2694 
2695   void free_node_list() {
2696     FREE_C_HEAP_ARRAY(int, _numa_used_node_list);
2697   }
2698 
2699  public:
2700   NUMANodeListHolder() {
2701     _numa_used_node_count = 0;
2702     _numa_used_node_list = NULL;
2703     // do rest of initialization in build routine (after function pointers are set up)
2704   }
2705 
2706   ~NUMANodeListHolder() {
2707     free_node_list();
2708   }
2709 
2710   bool build() {
2711     DWORD_PTR proc_aff_mask;
2712     DWORD_PTR sys_aff_mask;
2713     if (!GetProcessAffinityMask(GetCurrentProcess(), &amp;proc_aff_mask, &amp;sys_aff_mask)) return false;
2714     ULONG highest_node_number;
2715     if (!GetNumaHighestNodeNumber(&amp;highest_node_number)) return false;
2716     free_node_list();
2717     _numa_used_node_list = NEW_C_HEAP_ARRAY(int, highest_node_number + 1, mtInternal);
2718     for (unsigned int i = 0; i &lt;= highest_node_number; i++) {
2719       ULONGLONG proc_mask_numa_node;
2720       if (!GetNumaNodeProcessorMask(i, &amp;proc_mask_numa_node)) return false;
2721       if ((proc_aff_mask &amp; proc_mask_numa_node)!=0) {
2722         _numa_used_node_list[_numa_used_node_count++] = i;
2723       }
2724     }
2725     return (_numa_used_node_count &gt; 1);
2726   }
2727 
2728   int get_count() { return _numa_used_node_count; }
2729   int get_node_list_entry(int n) {
2730     // for indexes out of range, returns -1
2731     return (n &lt; _numa_used_node_count ? _numa_used_node_list[n] : -1);
2732   }
2733 
2734 } numa_node_list_holder;
2735 
2736 
2737 
2738 static size_t _large_page_size = 0;
2739 
2740 static bool request_lock_memory_privilege() {
2741   _hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
2742                           os::current_process_id());
2743 
2744   LUID luid;
2745   if (_hProcess != NULL &amp;&amp;
2746       OpenProcessToken(_hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;_hToken) &amp;&amp;
2747       LookupPrivilegeValue(NULL, &quot;SeLockMemoryPrivilege&quot;, &amp;luid)) {
2748 
2749     TOKEN_PRIVILEGES tp;
2750     tp.PrivilegeCount = 1;
2751     tp.Privileges[0].Luid = luid;
2752     tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
2753 
2754     // AdjustTokenPrivileges() may return TRUE even when it couldn&#39;t change the
2755     // privilege. Check GetLastError() too. See MSDN document.
2756     if (AdjustTokenPrivileges(_hToken, false, &amp;tp, sizeof(tp), NULL, NULL) &amp;&amp;
2757         (GetLastError() == ERROR_SUCCESS)) {
2758       return true;
2759     }
2760   }
2761 
2762   return false;
2763 }
2764 
2765 static void cleanup_after_large_page_init() {
2766   if (_hProcess) CloseHandle(_hProcess);
2767   _hProcess = NULL;
2768   if (_hToken) CloseHandle(_hToken);
2769   _hToken = NULL;
2770 }
2771 
2772 static bool numa_interleaving_init() {
2773   bool success = false;
2774   bool use_numa_interleaving_specified = !FLAG_IS_DEFAULT(UseNUMAInterleaving);
2775 
2776   // print a warning if UseNUMAInterleaving flag is specified on command line
2777   bool warn_on_failure = use_numa_interleaving_specified;
2778 #define WARN(msg) if (warn_on_failure) { warning(msg); }
2779 
2780   // NUMAInterleaveGranularity cannot be less than vm_allocation_granularity (or _large_page_size if using large pages)
2781   size_t min_interleave_granularity = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2782   NUMAInterleaveGranularity = align_up(NUMAInterleaveGranularity, min_interleave_granularity);
2783 
2784   if (numa_node_list_holder.build()) {
2785     if (log_is_enabled(Debug, os, cpu)) {
2786       Log(os, cpu) log;
2787       log.debug(&quot;NUMA UsedNodeCount=%d, namely &quot;, numa_node_list_holder.get_count());
2788       for (int i = 0; i &lt; numa_node_list_holder.get_count(); i++) {
2789         log.debug(&quot;  %d &quot;, numa_node_list_holder.get_node_list_entry(i));
2790       }
2791     }
2792     success = true;
2793   } else {
2794     WARN(&quot;Process does not cover multiple NUMA nodes.&quot;);
2795   }
2796   if (!success) {
2797     if (use_numa_interleaving_specified) WARN(&quot;...Ignoring UseNUMAInterleaving flag.&quot;);
2798   }
2799   return success;
2800 #undef WARN
2801 }
2802 
2803 // this routine is used whenever we need to reserve a contiguous VA range
2804 // but we need to make separate VirtualAlloc calls for each piece of the range
2805 // Reasons for doing this:
2806 //  * UseLargePagesIndividualAllocation was set (normally only needed on WS2003 but possible to be set otherwise)
2807 //  * UseNUMAInterleaving requires a separate node for each piece
2808 static char* allocate_pages_individually(size_t bytes, char* addr, DWORD flags,
2809                                          DWORD prot,
2810                                          bool should_inject_error = false) {
2811   char * p_buf;
2812   // note: at setup time we guaranteed that NUMAInterleaveGranularity was aligned up to a page size
2813   size_t page_size = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2814   size_t chunk_size = UseNUMAInterleaving ? NUMAInterleaveGranularity : page_size;
2815 
2816   // first reserve enough address space in advance since we want to be
2817   // able to break a single contiguous virtual address range into multiple
2818   // large page commits but WS2003 does not allow reserving large page space
2819   // so we just use 4K pages for reserve, this gives us a legal contiguous
2820   // address space. then we will deallocate that reservation, and re alloc
2821   // using large pages
2822   const size_t size_of_reserve = bytes + chunk_size;
2823   if (bytes &gt; size_of_reserve) {
2824     // Overflowed.
2825     return NULL;
2826   }
2827   p_buf = (char *) VirtualAlloc(addr,
2828                                 size_of_reserve,  // size of Reserve
2829                                 MEM_RESERVE,
2830                                 PAGE_READWRITE);
2831   // If reservation failed, return NULL
2832   if (p_buf == NULL) return NULL;
2833   MemTracker::record_virtual_memory_reserve((address)p_buf, size_of_reserve, CALLER_PC);
2834   os::release_memory(p_buf, bytes + chunk_size);
2835 
2836   // we still need to round up to a page boundary (in case we are using large pages)
2837   // but not to a chunk boundary (in case InterleavingGranularity doesn&#39;t align with page size)
2838   // instead we handle this in the bytes_to_rq computation below
2839   p_buf = align_up(p_buf, page_size);
2840 
2841   // now go through and allocate one chunk at a time until all bytes are
2842   // allocated
2843   size_t  bytes_remaining = bytes;
2844   // An overflow of align_up() would have been caught above
2845   // in the calculation of size_of_reserve.
2846   char * next_alloc_addr = p_buf;
2847   HANDLE hProc = GetCurrentProcess();
2848 
2849 #ifdef ASSERT
2850   // Variable for the failure injection
2851   int ran_num = os::random();
2852   size_t fail_after = ran_num % bytes;
2853 #endif
2854 
2855   int count=0;
2856   while (bytes_remaining) {
2857     // select bytes_to_rq to get to the next chunk_size boundary
2858 
2859     size_t bytes_to_rq = MIN2(bytes_remaining, chunk_size - ((size_t)next_alloc_addr % chunk_size));
2860     // Note allocate and commit
2861     char * p_new;
2862 
2863 #ifdef ASSERT
2864     bool inject_error_now = should_inject_error &amp;&amp; (bytes_remaining &lt;= fail_after);
2865 #else
2866     const bool inject_error_now = false;
2867 #endif
2868 
2869     if (inject_error_now) {
2870       p_new = NULL;
2871     } else {
2872       if (!UseNUMAInterleaving) {
2873         p_new = (char *) VirtualAlloc(next_alloc_addr,
2874                                       bytes_to_rq,
2875                                       flags,
2876                                       prot);
2877       } else {
2878         // get the next node to use from the used_node_list
2879         assert(numa_node_list_holder.get_count() &gt; 0, &quot;Multiple NUMA nodes expected&quot;);
2880         DWORD node = numa_node_list_holder.get_node_list_entry(count % numa_node_list_holder.get_count());
2881         p_new = (char *)VirtualAllocExNuma(hProc, next_alloc_addr, bytes_to_rq, flags, prot, node);
2882       }
2883     }
2884 
2885     if (p_new == NULL) {
2886       // Free any allocated pages
2887       if (next_alloc_addr &gt; p_buf) {
2888         // Some memory was committed so release it.
2889         size_t bytes_to_release = bytes - bytes_remaining;
2890         // NMT has yet to record any individual blocks, so it
2891         // need to create a dummy &#39;reserve&#39; record to match
2892         // the release.
2893         MemTracker::record_virtual_memory_reserve((address)p_buf,
2894                                                   bytes_to_release, CALLER_PC);
2895         os::release_memory(p_buf, bytes_to_release);
2896       }
2897 #ifdef ASSERT
2898       if (should_inject_error) {
2899         log_develop_debug(pagesize)(&quot;Reserving pages individually failed.&quot;);
2900       }
2901 #endif
2902       return NULL;
2903     }
2904 
2905     bytes_remaining -= bytes_to_rq;
2906     next_alloc_addr += bytes_to_rq;
2907     count++;
2908   }
2909   // Although the memory is allocated individually, it is returned as one.
2910   // NMT records it as one block.
2911   if ((flags &amp; MEM_COMMIT) != 0) {
2912     MemTracker::record_virtual_memory_reserve_and_commit((address)p_buf, bytes, CALLER_PC);
2913   } else {
2914     MemTracker::record_virtual_memory_reserve((address)p_buf, bytes, CALLER_PC);
2915   }
2916 
2917   // made it this far, success
2918   return p_buf;
2919 }
2920 
2921 
2922 
2923 void os::large_page_init() {
2924   if (!UseLargePages) return;
2925 
2926   // print a warning if any large page related flag is specified on command line
2927   bool warn_on_failure = !FLAG_IS_DEFAULT(UseLargePages) ||
2928                          !FLAG_IS_DEFAULT(LargePageSizeInBytes);
2929   bool success = false;
2930 
2931 #define WARN(msg) if (warn_on_failure) { warning(msg); }
2932   if (request_lock_memory_privilege()) {
2933     size_t s = GetLargePageMinimum();
2934     if (s) {
2935 #if defined(IA32) || defined(AMD64)
2936       if (s &gt; 4*M || LargePageSizeInBytes &gt; 4*M) {
2937         WARN(&quot;JVM cannot use large pages bigger than 4mb.&quot;);
2938       } else {
2939 #endif
2940         if (LargePageSizeInBytes &amp;&amp; LargePageSizeInBytes % s == 0) {
2941           _large_page_size = LargePageSizeInBytes;
2942         } else {
2943           _large_page_size = s;
2944         }
2945         success = true;
2946 #if defined(IA32) || defined(AMD64)
2947       }
2948 #endif
2949     } else {
2950       WARN(&quot;Large page is not supported by the processor.&quot;);
2951     }
2952   } else {
2953     WARN(&quot;JVM cannot use large page memory because it does not have enough privilege to lock pages in memory.&quot;);
2954   }
2955 #undef WARN
2956 
2957   const size_t default_page_size = (size_t) vm_page_size();
2958   if (success &amp;&amp; _large_page_size &gt; default_page_size) {
2959     _page_sizes[0] = _large_page_size;
2960     _page_sizes[1] = default_page_size;
2961     _page_sizes[2] = 0;
2962   }
2963 
2964   cleanup_after_large_page_init();
2965   UseLargePages = success;
2966 }
2967 
2968 int os::create_file_for_heap(const char* dir) {
2969 
2970   const char name_template[] = &quot;/jvmheap.XXXXXX&quot;;
2971 
2972   size_t fullname_len = strlen(dir) + strlen(name_template);
2973   char *fullname = (char*)os::malloc(fullname_len + 1, mtInternal);
2974   if (fullname == NULL) {
2975     vm_exit_during_initialization(err_msg(&quot;Malloc failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));
2976     return -1;
2977   }
2978   int n = snprintf(fullname, fullname_len + 1, &quot;%s%s&quot;, dir, name_template);
2979   assert((size_t)n == fullname_len, &quot;Unexpected number of characters in string&quot;);
2980 
2981   os::native_path(fullname);
2982 
2983   char *path = _mktemp(fullname);
2984   if (path == NULL) {
2985     warning(&quot;_mktemp could not create file name from template %s (%s)&quot;, fullname, os::strerror(errno));
2986     os::free(fullname);
2987     return -1;
2988   }
2989 
2990   int fd = _open(path, O_RDWR | O_CREAT | O_TEMPORARY | O_EXCL, S_IWRITE | S_IREAD);
2991 
2992   os::free(fullname);
2993   if (fd &lt; 0) {
2994     warning(&quot;Problem opening file for heap (%s)&quot;, os::strerror(errno));
2995     return -1;
2996   }
2997   return fd;
2998 }
2999 
3000 // If &#39;base&#39; is not NULL, function will return NULL if it cannot get &#39;base&#39;
3001 char* os::map_memory_to_file(char* base, size_t size, int fd) {
3002   assert(fd != -1, &quot;File descriptor is not valid&quot;);
3003 
3004   HANDLE fh = (HANDLE)_get_osfhandle(fd);
3005 #ifdef _LP64
3006   HANDLE fileMapping = CreateFileMapping(fh, NULL, PAGE_READWRITE,
3007     (DWORD)(size &gt;&gt; 32), (DWORD)(size &amp; 0xFFFFFFFF), NULL);
3008 #else
3009   HANDLE fileMapping = CreateFileMapping(fh, NULL, PAGE_READWRITE,
3010     0, (DWORD)size, NULL);
3011 #endif
3012   if (fileMapping == NULL) {
3013     if (GetLastError() == ERROR_DISK_FULL) {
3014       vm_exit_during_initialization(err_msg(&quot;Could not allocate sufficient disk space for Java heap&quot;));
3015     }
3016     else {
3017       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
3018     }
3019 
3020     return NULL;
3021   }
3022 
3023   LPVOID addr = MapViewOfFileEx(fileMapping, FILE_MAP_WRITE, 0, 0, size, base);
3024 
3025   CloseHandle(fileMapping);
3026 
3027   return (char*)addr;
3028 }
3029 
3030 char* os::replace_existing_mapping_with_file_mapping(char* base, size_t size, int fd) {
3031   assert(fd != -1, &quot;File descriptor is not valid&quot;);
3032   assert(base != NULL, &quot;Base address cannot be NULL&quot;);
3033 
3034   release_memory(base, size);
3035   return map_memory_to_file(base, size, fd);
3036 }
3037 
3038 // On win32, one cannot release just a part of reserved memory, it&#39;s an
3039 // all or nothing deal.  When we split a reservation, we must break the
3040 // reservation into two reservations.
3041 void os::pd_split_reserved_memory(char *base, size_t size, size_t split,
3042                                   bool realloc) {
3043   if (size &gt; 0) {
3044     release_memory(base, size);
3045     if (realloc) {
3046       reserve_memory(split, base);
3047     }
3048     if (size != split) {
3049       reserve_memory(size - split, base + split);
3050     }
3051   }
3052 }
3053 
3054 // Multiple threads can race in this code but it&#39;s not possible to unmap small sections of
3055 // virtual space to get requested alignment, like posix-like os&#39;s.
3056 // Windows prevents multiple thread from remapping over each other so this loop is thread-safe.
3057 char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {
3058   assert((alignment &amp; (os::vm_allocation_granularity() - 1)) == 0,
3059          &quot;Alignment must be a multiple of allocation granularity (page size)&quot;);
3060   assert((size &amp; (alignment -1)) == 0, &quot;size must be &#39;alignment&#39; aligned&quot;);
3061 
3062   size_t extra_size = size + alignment;
3063   assert(extra_size &gt;= size, &quot;overflow, size is too large to allow alignment&quot;);
3064 
3065   char* aligned_base = NULL;
3066 
3067   do {
3068     char* extra_base = os::reserve_memory(extra_size, NULL, alignment, file_desc);
3069     if (extra_base == NULL) {
3070       return NULL;
3071     }
3072     // Do manual alignment
3073     aligned_base = align_up(extra_base, alignment);
3074 
3075     if (file_desc != -1) {
3076       os::unmap_memory(extra_base, extra_size);
3077     } else {
3078       os::release_memory(extra_base, extra_size);
3079     }
3080 
3081     aligned_base = os::reserve_memory(size, aligned_base, 0, file_desc);
3082 
3083   } while (aligned_base == NULL);
3084 
3085   return aligned_base;
3086 }
3087 
3088 char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint) {
3089   assert((size_t)addr % os::vm_allocation_granularity() == 0,
3090          &quot;reserve alignment&quot;);
3091   assert(bytes % os::vm_page_size() == 0, &quot;reserve page size&quot;);
3092   char* res;
3093   // note that if UseLargePages is on, all the areas that require interleaving
3094   // will go thru reserve_memory_special rather than thru here.
3095   bool use_individual = (UseNUMAInterleaving &amp;&amp; !UseLargePages);
3096   if (!use_individual) {
3097     res = (char*)VirtualAlloc(addr, bytes, MEM_RESERVE, PAGE_READWRITE);
3098   } else {
3099     elapsedTimer reserveTimer;
3100     if (Verbose &amp;&amp; PrintMiscellaneous) reserveTimer.start();
3101     // in numa interleaving, we have to allocate pages individually
3102     // (well really chunks of NUMAInterleaveGranularity size)
3103     res = allocate_pages_individually(bytes, addr, MEM_RESERVE, PAGE_READWRITE);
3104     if (res == NULL) {
3105       warning(&quot;NUMA page allocation failed&quot;);
3106     }
3107     if (Verbose &amp;&amp; PrintMiscellaneous) {
3108       reserveTimer.stop();
3109       tty-&gt;print_cr(&quot;reserve_memory of %Ix bytes took &quot; JLONG_FORMAT &quot; ms (&quot; JLONG_FORMAT &quot; ticks)&quot;, bytes,
3110                     reserveTimer.milliseconds(), reserveTimer.ticks());
3111     }
3112   }
3113   assert(res == NULL || addr == NULL || addr == res,
3114          &quot;Unexpected address from reserve.&quot;);
3115 
3116   return res;
3117 }
3118 
3119 // Reserve memory at an arbitrary address, only if that area is
3120 // available (and not reserved for something else).
3121 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
3122   // Windows os::reserve_memory() fails of the requested address range is
3123   // not avilable.
3124   return reserve_memory(bytes, requested_addr);
3125 }
3126 
3127 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
3128   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
3129   return map_memory_to_file(requested_addr, bytes, file_desc);
3130 }
3131 
3132 size_t os::large_page_size() {
3133   return _large_page_size;
3134 }
3135 
3136 bool os::can_commit_large_page_memory() {
3137   // Windows only uses large page memory when the entire region is reserved
3138   // and committed in a single VirtualAlloc() call. This may change in the
3139   // future, but with Windows 2003 it&#39;s not possible to commit on demand.
3140   return false;
3141 }
3142 
3143 bool os::can_execute_large_page_memory() {
3144   return true;
3145 }
3146 
3147 char* os::reserve_memory_special(size_t bytes, size_t alignment, char* addr,
3148                                  bool exec) {
3149   assert(UseLargePages, &quot;only for large pages&quot;);
3150 
3151   if (!is_aligned(bytes, os::large_page_size()) || alignment &gt; os::large_page_size()) {
3152     return NULL; // Fallback to small pages.
3153   }
3154 
3155   const DWORD prot = exec ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
3156   const DWORD flags = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3157 
3158   // with large pages, there are two cases where we need to use Individual Allocation
3159   // 1) the UseLargePagesIndividualAllocation flag is set (set by default on WS2003)
3160   // 2) NUMA Interleaving is enabled, in which case we use a different node for each page
3161   if (UseLargePagesIndividualAllocation || UseNUMAInterleaving) {
3162     log_debug(pagesize)(&quot;Reserving large pages individually.&quot;);
3163 
3164     char * p_buf = allocate_pages_individually(bytes, addr, flags, prot, LargePagesIndividualAllocationInjectError);
3165     if (p_buf == NULL) {
3166       // give an appropriate warning message
3167       if (UseNUMAInterleaving) {
3168         warning(&quot;NUMA large page allocation failed, UseLargePages flag ignored&quot;);
3169       }
3170       if (UseLargePagesIndividualAllocation) {
3171         warning(&quot;Individually allocated large pages failed, &quot;
3172                 &quot;use -XX:-UseLargePagesIndividualAllocation to turn off&quot;);
3173       }
3174       return NULL;
3175     }
3176 
3177     return p_buf;
3178 
3179   } else {
3180     log_debug(pagesize)(&quot;Reserving large pages in a single large chunk.&quot;);
3181 
3182     // normal policy just allocate it all at once
3183     DWORD flag = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3184     char * res = (char *)VirtualAlloc(addr, bytes, flag, prot);
3185     if (res != NULL) {
3186       MemTracker::record_virtual_memory_reserve_and_commit((address)res, bytes, CALLER_PC);
3187     }
3188 
3189     return res;
3190   }
3191 }
3192 
3193 bool os::release_memory_special(char* base, size_t bytes) {
3194   assert(base != NULL, &quot;Sanity check&quot;);
3195   return release_memory(base, bytes);
3196 }
3197 
3198 void os::print_statistics() {
3199 }
3200 
3201 static void warn_fail_commit_memory(char* addr, size_t bytes, bool exec) {
3202   int err = os::get_last_error();
3203   char buf[256];
3204   size_t buf_len = os::lasterror(buf, sizeof(buf));
3205   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3206           &quot;, %d) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3207           exec, buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3208 }
3209 
3210 bool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {
3211   if (bytes == 0) {
3212     // Don&#39;t bother the OS with noops.
3213     return true;
3214   }
3215   assert((size_t) addr % os::vm_page_size() == 0, &quot;commit on page boundaries&quot;);
3216   assert(bytes % os::vm_page_size() == 0, &quot;commit in page-sized chunks&quot;);
3217   // Don&#39;t attempt to print anything if the OS call fails. We&#39;re
3218   // probably low on resources, so the print itself may cause crashes.
3219 
3220   // unless we have NUMAInterleaving enabled, the range of a commit
3221   // is always within a reserve covered by a single VirtualAlloc
3222   // in that case we can just do a single commit for the requested size
3223   if (!UseNUMAInterleaving) {
3224     if (VirtualAlloc(addr, bytes, MEM_COMMIT, PAGE_READWRITE) == NULL) {
3225       NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3226       return false;
3227     }
3228     if (exec) {
3229       DWORD oldprot;
3230       // Windows doc says to use VirtualProtect to get execute permissions
3231       if (!VirtualProtect(addr, bytes, PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3232         NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3233         return false;
3234       }
3235     }
3236     return true;
3237   } else {
3238 
3239     // when NUMAInterleaving is enabled, the commit might cover a range that
3240     // came from multiple VirtualAlloc reserves (using allocate_pages_individually).
3241     // VirtualQuery can help us determine that.  The RegionSize that VirtualQuery
3242     // returns represents the number of bytes that can be committed in one step.
3243     size_t bytes_remaining = bytes;
3244     char * next_alloc_addr = addr;
3245     while (bytes_remaining &gt; 0) {
3246       MEMORY_BASIC_INFORMATION alloc_info;
3247       VirtualQuery(next_alloc_addr, &amp;alloc_info, sizeof(alloc_info));
3248       size_t bytes_to_rq = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3249       if (VirtualAlloc(next_alloc_addr, bytes_to_rq, MEM_COMMIT,
3250                        PAGE_READWRITE) == NULL) {
3251         NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3252                                             exec);)
3253         return false;
3254       }
3255       if (exec) {
3256         DWORD oldprot;
3257         if (!VirtualProtect(next_alloc_addr, bytes_to_rq,
3258                             PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3259           NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3260                                               exec);)
3261           return false;
3262         }
3263       }
3264       bytes_remaining -= bytes_to_rq;
3265       next_alloc_addr += bytes_to_rq;
3266     }
3267   }
3268   // if we made it this far, return true
3269   return true;
3270 }
3271 
3272 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
3273                           bool exec) {
3274   // alignment_hint is ignored on this OS
3275   return pd_commit_memory(addr, size, exec);
3276 }
3277 
3278 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
3279                                   const char* mesg) {
3280   assert(mesg != NULL, &quot;mesg must be specified&quot;);
3281   if (!pd_commit_memory(addr, size, exec)) {
3282     warn_fail_commit_memory(addr, size, exec);
3283     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
3284   }
3285 }
3286 
3287 void os::pd_commit_memory_or_exit(char* addr, size_t size,
3288                                   size_t alignment_hint, bool exec,
3289                                   const char* mesg) {
3290   // alignment_hint is ignored on this OS
3291   pd_commit_memory_or_exit(addr, size, exec, mesg);
3292 }
3293 
3294 bool os::pd_uncommit_memory(char* addr, size_t bytes) {
3295   if (bytes == 0) {
3296     // Don&#39;t bother the OS with noops.
3297     return true;
3298   }
3299   assert((size_t) addr % os::vm_page_size() == 0, &quot;uncommit on page boundaries&quot;);
3300   assert(bytes % os::vm_page_size() == 0, &quot;uncommit in page-sized chunks&quot;);
3301   return (VirtualFree(addr, bytes, MEM_DECOMMIT) != 0);
3302 }
3303 
3304 bool os::pd_release_memory(char* addr, size_t bytes) {
3305   return VirtualFree(addr, 0, MEM_RELEASE) != 0;
3306 }
3307 
3308 bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
3309   return os::commit_memory(addr, size, !ExecMem);
3310 }
3311 
3312 bool os::remove_stack_guard_pages(char* addr, size_t size) {
3313   return os::uncommit_memory(addr, size);
3314 }
3315 
3316 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
3317   uint count = 0;
3318   bool ret = false;
3319   size_t bytes_remaining = bytes;
3320   char * next_protect_addr = addr;
3321 
3322   // Use VirtualQuery() to get the chunk size.
3323   while (bytes_remaining) {
3324     MEMORY_BASIC_INFORMATION alloc_info;
3325     if (VirtualQuery(next_protect_addr, &amp;alloc_info, sizeof(alloc_info)) == 0) {
3326       return false;
3327     }
3328 
3329     size_t bytes_to_protect = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3330     // We used different API at allocate_pages_individually() based on UseNUMAInterleaving,
3331     // but we don&#39;t distinguish here as both cases are protected by same API.
3332     ret = VirtualProtect(next_protect_addr, bytes_to_protect, p, old_status) != 0;
3333     warning(&quot;Failed protecting pages individually for chunk #%u&quot;, count);
3334     if (!ret) {
3335       return false;
3336     }
3337 
3338     bytes_remaining -= bytes_to_protect;
3339     next_protect_addr += bytes_to_protect;
3340     count++;
3341   }
3342   return ret;
3343 }
3344 
3345 // Set protections specified
3346 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
3347                         bool is_committed) {
3348   unsigned int p = 0;
3349   switch (prot) {
3350   case MEM_PROT_NONE: p = PAGE_NOACCESS; break;
3351   case MEM_PROT_READ: p = PAGE_READONLY; break;
3352   case MEM_PROT_RW:   p = PAGE_READWRITE; break;
3353   case MEM_PROT_RWX:  p = PAGE_EXECUTE_READWRITE; break;
3354   default:
3355     ShouldNotReachHere();
3356   }
3357 
3358   DWORD old_status;
3359 
3360   // Strange enough, but on Win32 one can change protection only for committed
3361   // memory, not a big deal anyway, as bytes less or equal than 64K
3362   if (!is_committed) {
3363     commit_memory_or_exit(addr, bytes, prot == MEM_PROT_RWX,
3364                           &quot;cannot commit protection page&quot;);
3365   }
3366   // One cannot use os::guard_memory() here, as on Win32 guard page
3367   // have different (one-shot) semantics, from MSDN on PAGE_GUARD:
3368   //
3369   // Pages in the region become guard pages. Any attempt to access a guard page
3370   // causes the system to raise a STATUS_GUARD_PAGE exception and turn off
3371   // the guard page status. Guard pages thus act as a one-time access alarm.
3372   bool ret;
3373   if (UseNUMAInterleaving) {
3374     // If UseNUMAInterleaving is enabled, the pages may have been allocated a chunk at a time,
3375     // so we must protect the chunks individually.
3376     ret = protect_pages_individually(addr, bytes, p, &amp;old_status);
3377   } else {
3378     ret = VirtualProtect(addr, bytes, p, &amp;old_status) != 0;
3379   }
3380 #ifdef ASSERT
3381   if (!ret) {
3382     int err = os::get_last_error();
3383     char buf[256];
3384     size_t buf_len = os::lasterror(buf, sizeof(buf));
3385     warning(&quot;INFO: os::protect_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3386           &quot;) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3387           buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3388   }
3389 #endif
3390   return ret;
3391 }
3392 
3393 bool os::guard_memory(char* addr, size_t bytes) {
3394   DWORD old_status;
3395   return VirtualProtect(addr, bytes, PAGE_READWRITE | PAGE_GUARD, &amp;old_status) != 0;
3396 }
3397 
3398 bool os::unguard_memory(char* addr, size_t bytes) {
3399   DWORD old_status;
3400   return VirtualProtect(addr, bytes, PAGE_READWRITE, &amp;old_status) != 0;
3401 }
3402 
3403 void os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3404 void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3405 void os::numa_make_global(char *addr, size_t bytes)    { }
3406 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint)    { }
3407 bool os::numa_topology_changed()                       { return false; }
3408 size_t os::numa_get_groups_num()                       { return MAX2(numa_node_list_holder.get_count(), 1); }
3409 int os::numa_get_group_id()                            { return 0; }
3410 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
3411   if (numa_node_list_holder.get_count() == 0 &amp;&amp; size &gt; 0) {
3412     // Provide an answer for UMA systems
3413     ids[0] = 0;
3414     return 1;
3415   } else {
3416     // check for size bigger than actual groups_num
3417     size = MIN2(size, numa_get_groups_num());
3418     for (int i = 0; i &lt; (int)size; i++) {
3419       ids[i] = numa_node_list_holder.get_node_list_entry(i);
3420     }
3421     return size;
3422   }
3423 }
3424 
3425 int os::numa_get_group_id_for_address(const void* address) {
3426   return 0;
3427 }
3428 
3429 bool os::get_page_info(char *start, page_info* info) {
3430   return false;
3431 }
3432 
3433 char *os::scan_pages(char *start, char* end, page_info* page_expected,
3434                      page_info* page_found) {
3435   return end;
3436 }
3437 
3438 char* os::non_memory_address_word() {
3439   // Must never look like an address returned by reserve_memory,
3440   // even in its subfields (as defined by the CPU immediate fields,
3441   // if the CPU splits constants across multiple instructions).
<a name="38" id="anc38"></a><span class="line-added">3442 #ifdef _M_ARM64</span>
<span class="line-added">3443   // AArch64 has a maximum addressable space of 48-bits</span>
<span class="line-added">3444   return (char*)((1ull &lt;&lt; 48) - 1);</span>
<span class="line-added">3445 #else</span>
3446   return (char*)-1;
<a name="39" id="anc39"></a><span class="line-added">3447 #endif</span>
3448 }
3449 
3450 #define MAX_ERROR_COUNT 100
3451 #define SYS_THREAD_ERROR 0xffffffffUL
3452 
3453 void os::pd_start_thread(Thread* thread) {
3454   DWORD ret = ResumeThread(thread-&gt;osthread()-&gt;thread_handle());
3455   // Returns previous suspend state:
3456   // 0:  Thread was not suspended
3457   // 1:  Thread is running now
3458   // &gt;1: Thread is still suspended.
3459   assert(ret != SYS_THREAD_ERROR, &quot;StartThread failed&quot;); // should propagate back
3460 }
3461 
3462 
3463 // Short sleep, direct OS call.
3464 //
3465 // ms = 0, means allow others (if any) to run.
3466 //
3467 void os::naked_short_sleep(jlong ms) {
3468   assert(ms &lt; 1000, &quot;Un-interruptable sleep, short time use only&quot;);
3469   Sleep(ms);
3470 }
3471 
3472 // Windows does not provide sleep functionality with nanosecond resolution, so we
3473 // try to approximate this with spinning combined with yielding if another thread
3474 // is ready to run on the current processor.
3475 void os::naked_short_nanosleep(jlong ns) {
3476   assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
3477 
3478   int64_t start = os::javaTimeNanos();
3479   do {
3480     if (SwitchToThread() == 0) {
3481       // Nothing else is ready to run on this cpu, spin a little
3482       SpinPause();
3483     }
3484   } while (os::javaTimeNanos() - start &lt; ns);
3485 }
3486 
3487 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
3488 void os::infinite_sleep() {
3489   while (true) {    // sleep forever ...
3490     Sleep(100000);  // ... 100 seconds at a time
3491   }
3492 }
3493 
3494 typedef BOOL (WINAPI * STTSignature)(void);
3495 
3496 void os::naked_yield() {
3497   // Consider passing back the return value from SwitchToThread().
3498   SwitchToThread();
3499 }
3500 
3501 // Win32 only gives you access to seven real priorities at a time,
3502 // so we compress Java&#39;s ten down to seven.  It would be better
3503 // if we dynamically adjusted relative priorities.
3504 
3505 int os::java_to_os_priority[CriticalPriority + 1] = {
3506   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3507   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3508   THREAD_PRIORITY_LOWEST,                       // 2
3509   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3510   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3511   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3512   THREAD_PRIORITY_NORMAL,                       // 6
3513   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3514   THREAD_PRIORITY_ABOVE_NORMAL,                 // 8
3515   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3516   THREAD_PRIORITY_HIGHEST,                      // 10 MaxPriority
3517   THREAD_PRIORITY_HIGHEST                       // 11 CriticalPriority
3518 };
3519 
3520 int prio_policy1[CriticalPriority + 1] = {
3521   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3522   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3523   THREAD_PRIORITY_LOWEST,                       // 2
3524   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3525   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3526   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3527   THREAD_PRIORITY_ABOVE_NORMAL,                 // 6
3528   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3529   THREAD_PRIORITY_HIGHEST,                      // 8
3530   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3531   THREAD_PRIORITY_TIME_CRITICAL,                // 10 MaxPriority
3532   THREAD_PRIORITY_TIME_CRITICAL                 // 11 CriticalPriority
3533 };
3534 
3535 static int prio_init() {
3536   // If ThreadPriorityPolicy is 1, switch tables
3537   if (ThreadPriorityPolicy == 1) {
3538     int i;
3539     for (i = 0; i &lt; CriticalPriority + 1; i++) {
3540       os::java_to_os_priority[i] = prio_policy1[i];
3541     }
3542   }
3543   if (UseCriticalJavaThreadPriority) {
3544     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
3545   }
3546   return 0;
3547 }
3548 
3549 OSReturn os::set_native_priority(Thread* thread, int priority) {
3550   if (!UseThreadPriorities) return OS_OK;
3551   bool ret = SetThreadPriority(thread-&gt;osthread()-&gt;thread_handle(), priority) != 0;
3552   return ret ? OS_OK : OS_ERR;
3553 }
3554 
3555 OSReturn os::get_native_priority(const Thread* const thread,
3556                                  int* priority_ptr) {
3557   if (!UseThreadPriorities) {
3558     *priority_ptr = java_to_os_priority[NormPriority];
3559     return OS_OK;
3560   }
3561   int os_prio = GetThreadPriority(thread-&gt;osthread()-&gt;thread_handle());
3562   if (os_prio == THREAD_PRIORITY_ERROR_RETURN) {
3563     assert(false, &quot;GetThreadPriority failed&quot;);
3564     return OS_ERR;
3565   }
3566   *priority_ptr = os_prio;
3567   return OS_OK;
3568 }
3569 
3570 // GetCurrentThreadId() returns DWORD
3571 intx os::current_thread_id()  { return GetCurrentThreadId(); }
3572 
3573 static int _initial_pid = 0;
3574 
3575 int os::current_process_id() {
3576   return (_initial_pid ? _initial_pid : _getpid());
3577 }
3578 
3579 int    os::win32::_vm_page_size              = 0;
3580 int    os::win32::_vm_allocation_granularity = 0;
3581 int    os::win32::_processor_type            = 0;
3582 // Processor level is not available on non-NT systems, use vm_version instead
3583 int    os::win32::_processor_level           = 0;
3584 julong os::win32::_physical_memory           = 0;
3585 size_t os::win32::_default_stack_size        = 0;
3586 
3587 intx          os::win32::_os_thread_limit    = 0;
3588 volatile intx os::win32::_os_thread_count    = 0;
3589 
3590 bool   os::win32::_is_windows_server         = false;
3591 
3592 // 6573254
3593 // Currently, the bug is observed across all the supported Windows releases,
3594 // including the latest one (as of this writing - Windows Server 2012 R2)
3595 bool   os::win32::_has_exit_bug              = true;
3596 
3597 void os::win32::initialize_system_info() {
3598   SYSTEM_INFO si;
3599   GetSystemInfo(&amp;si);
3600   _vm_page_size    = si.dwPageSize;
3601   _vm_allocation_granularity = si.dwAllocationGranularity;
3602   _processor_type  = si.dwProcessorType;
3603   _processor_level = si.wProcessorLevel;
3604   set_processor_count(si.dwNumberOfProcessors);
3605 
3606   MEMORYSTATUSEX ms;
3607   ms.dwLength = sizeof(ms);
3608 
3609   // also returns dwAvailPhys (free physical memory bytes), dwTotalVirtual, dwAvailVirtual,
3610   // dwMemoryLoad (% of memory in use)
3611   GlobalMemoryStatusEx(&amp;ms);
3612   _physical_memory = ms.ullTotalPhys;
3613 
3614   if (FLAG_IS_DEFAULT(MaxRAM)) {
3615     // Adjust MaxRAM according to the maximum virtual address space available.
3616     FLAG_SET_DEFAULT(MaxRAM, MIN2(MaxRAM, (uint64_t) ms.ullTotalVirtual));
3617   }
3618 
3619   OSVERSIONINFOEX oi;
3620   oi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
3621   GetVersionEx((OSVERSIONINFO*)&amp;oi);
3622   switch (oi.dwPlatformId) {
3623   case VER_PLATFORM_WIN32_NT:
3624     {
3625       int os_vers = oi.dwMajorVersion * 1000 + oi.dwMinorVersion;
3626       if (oi.wProductType == VER_NT_DOMAIN_CONTROLLER ||
3627           oi.wProductType == VER_NT_SERVER) {
3628         _is_windows_server = true;
3629       }
3630     }
3631     break;
3632   default: fatal(&quot;Unknown platform&quot;);
3633   }
3634 
3635   _default_stack_size = os::current_stack_size();
3636   assert(_default_stack_size &gt; (size_t) _vm_page_size, &quot;invalid stack size&quot;);
3637   assert((_default_stack_size &amp; (_vm_page_size - 1)) == 0,
3638          &quot;stack size not a multiple of page size&quot;);
3639 
3640   initialize_performance_counter();
3641 }
3642 
<a name="40" id="anc40"></a><span class="line-added">3643 int os::win32::get_cacheline_size() {</span>
<span class="line-added">3644   PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;</span>
<span class="line-added">3645   DWORD returnLength = 0;</span>
<span class="line-added">3646 </span>
<span class="line-added">3647   // See https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation</span>
<span class="line-added">3648 </span>
<span class="line-added">3649   GetLogicalProcessorInformation(NULL, &amp;returnLength);</span>
<span class="line-added">3650   assert(GetLastError() == ERROR_INSUFFICIENT_BUFFER, &quot;Unexpected return from GetLogicalProcessorInformation&quot;);</span>
<span class="line-added">3651 </span>
<span class="line-added">3652   buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)os::malloc(returnLength, mtInternal);</span>
<span class="line-added">3653   BOOL rc = GetLogicalProcessorInformation(buffer, &amp;returnLength);</span>
<span class="line-added">3654   assert(rc, &quot;Unexpected return from GetLogicalProcessorInformation&quot;);</span>
<span class="line-added">3655 </span>
<span class="line-added">3656   int line_sz = -1;</span>
<span class="line-added">3657   for (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = buffer; ptr &lt; buffer + returnLength / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); ptr++) {</span>
<span class="line-added">3658     switch (ptr-&gt;Relationship) {</span>
<span class="line-added">3659     case RelationCache:</span>
<span class="line-added">3660       // Cache data is in ptr-&gt;Cache, one CACHE_DESCRIPTOR structure for each cache.</span>
<span class="line-added">3661       PCACHE_DESCRIPTOR Cache = &amp;ptr-&gt;Cache;</span>
<span class="line-added">3662       if (Cache-&gt;Level == 1) {</span>
<span class="line-added">3663         line_sz = Cache-&gt;LineSize;</span>
<span class="line-added">3664       }</span>
<span class="line-added">3665       break;</span>
<span class="line-added">3666     }</span>
<span class="line-added">3667   }</span>
<span class="line-added">3668   os::free(buffer);</span>
<span class="line-added">3669   return line_sz;</span>
<span class="line-added">3670 }</span>
3671 
3672 HINSTANCE os::win32::load_Windows_dll(const char* name, char *ebuf,
3673                                       int ebuflen) {
3674   char path[MAX_PATH];
3675   DWORD size;
3676   DWORD pathLen = (DWORD)sizeof(path);
3677   HINSTANCE result = NULL;
3678 
3679   // only allow library name without path component
3680   assert(strchr(name, &#39;\\&#39;) == NULL, &quot;path not allowed&quot;);
3681   assert(strchr(name, &#39;:&#39;) == NULL, &quot;path not allowed&quot;);
3682   if (strchr(name, &#39;\\&#39;) != NULL || strchr(name, &#39;:&#39;) != NULL) {
3683     jio_snprintf(ebuf, ebuflen,
3684                  &quot;Invalid parameter while calling os::win32::load_windows_dll(): cannot take path: %s&quot;, name);
3685     return NULL;
3686   }
3687 
3688   // search system directory
3689   if ((size = GetSystemDirectory(path, pathLen)) &gt; 0) {
3690     if (size &gt;= pathLen) {
3691       return NULL; // truncated
3692     }
3693     if (jio_snprintf(path + size, pathLen - size, &quot;\\%s&quot;, name) == -1) {
3694       return NULL; // truncated
3695     }
3696     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3697       return result;
3698     }
3699   }
3700 
3701   // try Windows directory
3702   if ((size = GetWindowsDirectory(path, pathLen)) &gt; 0) {
3703     if (size &gt;= pathLen) {
3704       return NULL; // truncated
3705     }
3706     if (jio_snprintf(path + size, pathLen - size, &quot;\\%s&quot;, name) == -1) {
3707       return NULL; // truncated
3708     }
3709     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3710       return result;
3711     }
3712   }
3713 
3714   jio_snprintf(ebuf, ebuflen,
3715                &quot;os::win32::load_windows_dll() cannot load %s from system directories.&quot;, name);
3716   return NULL;
3717 }
3718 
3719 #define MAXIMUM_THREADS_TO_KEEP (16 * MAXIMUM_WAIT_OBJECTS)
3720 #define EXIT_TIMEOUT 300000 /* 5 minutes */
3721 
3722 static BOOL CALLBACK init_crit_sect_call(PINIT_ONCE, PVOID pcrit_sect, PVOID*) {
3723   InitializeCriticalSection((CRITICAL_SECTION*)pcrit_sect);
3724   return TRUE;
3725 }
3726 
3727 int os::win32::exit_process_or_thread(Ept what, int exit_code) {
3728   // Basic approach:
3729   //  - Each exiting thread registers its intent to exit and then does so.
3730   //  - A thread trying to terminate the process must wait for all
3731   //    threads currently exiting to complete their exit.
3732 
3733   if (os::win32::has_exit_bug()) {
3734     // The array holds handles of the threads that have started exiting by calling
3735     // _endthreadex().
3736     // Should be large enough to avoid blocking the exiting thread due to lack of
3737     // a free slot.
3738     static HANDLE handles[MAXIMUM_THREADS_TO_KEEP];
3739     static int handle_count = 0;
3740 
3741     static INIT_ONCE init_once_crit_sect = INIT_ONCE_STATIC_INIT;
3742     static CRITICAL_SECTION crit_sect;
3743     static volatile DWORD process_exiting = 0;
3744     int i, j;
3745     DWORD res;
3746     HANDLE hproc, hthr;
3747 
3748     // We only attempt to register threads until a process exiting
3749     // thread manages to set the process_exiting flag. Any threads
3750     // that come through here after the process_exiting flag is set
3751     // are unregistered and will be caught in the SuspendThread()
3752     // infinite loop below.
3753     bool registered = false;
3754 
3755     // The first thread that reached this point, initializes the critical section.
3756     if (!InitOnceExecuteOnce(&amp;init_once_crit_sect, init_crit_sect_call, &amp;crit_sect, NULL)) {
3757       warning(&quot;crit_sect initialization failed in %s: %d\n&quot;, __FILE__, __LINE__);
3758     } else if (Atomic::load_acquire(&amp;process_exiting) == 0) {
3759       if (what != EPT_THREAD) {
3760         // Atomically set process_exiting before the critical section
3761         // to increase the visibility between racing threads.
3762         Atomic::cmpxchg(&amp;process_exiting, (DWORD)0, GetCurrentThreadId());
3763       }
3764       EnterCriticalSection(&amp;crit_sect);
3765 
3766       if (what == EPT_THREAD &amp;&amp; Atomic::load_acquire(&amp;process_exiting) == 0) {
3767         // Remove from the array those handles of the threads that have completed exiting.
3768         for (i = 0, j = 0; i &lt; handle_count; ++i) {
3769           res = WaitForSingleObject(handles[i], 0 /* don&#39;t wait */);
3770           if (res == WAIT_TIMEOUT) {
3771             handles[j++] = handles[i];
3772           } else {
3773             if (res == WAIT_FAILED) {
3774               warning(&quot;WaitForSingleObject failed (%u) in %s: %d\n&quot;,
3775                       GetLastError(), __FILE__, __LINE__);
3776             }
3777             // Don&#39;t keep the handle, if we failed waiting for it.
3778             CloseHandle(handles[i]);
3779           }
3780         }
3781 
3782         // If there&#39;s no free slot in the array of the kept handles, we&#39;ll have to
3783         // wait until at least one thread completes exiting.
3784         if ((handle_count = j) == MAXIMUM_THREADS_TO_KEEP) {
3785           // Raise the priority of the oldest exiting thread to increase its chances
3786           // to complete sooner.
3787           SetThreadPriority(handles[0], THREAD_PRIORITY_ABOVE_NORMAL);
3788           res = WaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, handles, FALSE, EXIT_TIMEOUT);
3789           if (res &gt;= WAIT_OBJECT_0 &amp;&amp; res &lt; (WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS)) {
3790             i = (res - WAIT_OBJECT_0);
3791             handle_count = MAXIMUM_THREADS_TO_KEEP - 1;
3792             for (; i &lt; handle_count; ++i) {
3793               handles[i] = handles[i + 1];
3794             }
3795           } else {
3796             warning(&quot;WaitForMultipleObjects %s (%u) in %s: %d\n&quot;,
3797                     (res == WAIT_FAILED ? &quot;failed&quot; : &quot;timed out&quot;),
3798                     GetLastError(), __FILE__, __LINE__);
3799             // Don&#39;t keep handles, if we failed waiting for them.
3800             for (i = 0; i &lt; MAXIMUM_THREADS_TO_KEEP; ++i) {
3801               CloseHandle(handles[i]);
3802             }
3803             handle_count = 0;
3804           }
3805         }
3806 
3807         // Store a duplicate of the current thread handle in the array of handles.
3808         hproc = GetCurrentProcess();
3809         hthr = GetCurrentThread();
3810         if (!DuplicateHandle(hproc, hthr, hproc, &amp;handles[handle_count],
3811                              0, FALSE, DUPLICATE_SAME_ACCESS)) {
3812           warning(&quot;DuplicateHandle failed (%u) in %s: %d\n&quot;,
3813                   GetLastError(), __FILE__, __LINE__);
3814 
3815           // We can&#39;t register this thread (no more handles) so this thread
3816           // may be racing with a thread that is calling exit(). If the thread
3817           // that is calling exit() has managed to set the process_exiting
3818           // flag, then this thread will be caught in the SuspendThread()
3819           // infinite loop below which closes that race. A small timing
3820           // window remains before the process_exiting flag is set, but it
3821           // is only exposed when we are out of handles.
3822         } else {
3823           ++handle_count;
3824           registered = true;
3825 
3826           // The current exiting thread has stored its handle in the array, and now
3827           // should leave the critical section before calling _endthreadex().
3828         }
3829 
3830       } else if (what != EPT_THREAD &amp;&amp; handle_count &gt; 0) {
3831         jlong start_time, finish_time, timeout_left;
3832         // Before ending the process, make sure all the threads that had called
3833         // _endthreadex() completed.
3834 
3835         // Set the priority level of the current thread to the same value as
3836         // the priority level of exiting threads.
3837         // This is to ensure it will be given a fair chance to execute if
3838         // the timeout expires.
3839         hthr = GetCurrentThread();
3840         SetThreadPriority(hthr, THREAD_PRIORITY_ABOVE_NORMAL);
3841         start_time = os::javaTimeNanos();
3842         finish_time = start_time + ((jlong)EXIT_TIMEOUT * 1000000L);
3843         for (i = 0; ; ) {
3844           int portion_count = handle_count - i;
3845           if (portion_count &gt; MAXIMUM_WAIT_OBJECTS) {
3846             portion_count = MAXIMUM_WAIT_OBJECTS;
3847           }
3848           for (j = 0; j &lt; portion_count; ++j) {
3849             SetThreadPriority(handles[i + j], THREAD_PRIORITY_ABOVE_NORMAL);
3850           }
3851           timeout_left = (finish_time - start_time) / 1000000L;
3852           if (timeout_left &lt; 0) {
3853             timeout_left = 0;
3854           }
3855           res = WaitForMultipleObjects(portion_count, handles + i, TRUE, timeout_left);
3856           if (res == WAIT_FAILED || res == WAIT_TIMEOUT) {
3857             warning(&quot;WaitForMultipleObjects %s (%u) in %s: %d\n&quot;,
3858                     (res == WAIT_FAILED ? &quot;failed&quot; : &quot;timed out&quot;),
3859                     GetLastError(), __FILE__, __LINE__);
3860             // Reset portion_count so we close the remaining
3861             // handles due to this error.
3862             portion_count = handle_count - i;
3863           }
3864           for (j = 0; j &lt; portion_count; ++j) {
3865             CloseHandle(handles[i + j]);
3866           }
3867           if ((i += portion_count) &gt;= handle_count) {
3868             break;
3869           }
3870           start_time = os::javaTimeNanos();
3871         }
3872         handle_count = 0;
3873       }
3874 
3875       LeaveCriticalSection(&amp;crit_sect);
3876     }
3877 
3878     if (!registered &amp;&amp;
3879         Atomic::load_acquire(&amp;process_exiting) != 0 &amp;&amp;
3880         process_exiting != GetCurrentThreadId()) {
3881       // Some other thread is about to call exit(), so we don&#39;t let
3882       // the current unregistered thread proceed to exit() or _endthreadex()
3883       while (true) {
3884         SuspendThread(GetCurrentThread());
3885         // Avoid busy-wait loop, if SuspendThread() failed.
3886         Sleep(EXIT_TIMEOUT);
3887       }
3888     }
3889   }
3890 
3891   // We are here if either
3892   // - there&#39;s no &#39;race at exit&#39; bug on this OS release;
3893   // - initialization of the critical section failed (unlikely);
3894   // - the current thread has registered itself and left the critical section;
3895   // - the process-exiting thread has raised the flag and left the critical section.
3896   if (what == EPT_THREAD) {
3897     _endthreadex((unsigned)exit_code);
3898   } else if (what == EPT_PROCESS) {
3899     ::exit(exit_code);
3900   } else {
3901     _exit(exit_code);
3902   }
3903 
3904   // Should not reach here
3905   return exit_code;
3906 }
3907 
3908 #undef EXIT_TIMEOUT
3909 
3910 void os::win32::setmode_streams() {
3911   _setmode(_fileno(stdin), _O_BINARY);
3912   _setmode(_fileno(stdout), _O_BINARY);
3913   _setmode(_fileno(stderr), _O_BINARY);
3914 }
3915 
3916 void os::wait_for_keypress_at_exit(void) {
3917   if (PauseAtExit) {
3918     fprintf(stderr, &quot;Press any key to continue...\n&quot;);
3919     fgetc(stdin);
3920   }
3921 }
3922 
3923 
3924 bool os::message_box(const char* title, const char* message) {
3925   int result = MessageBox(NULL, message, title,
3926                           MB_YESNO | MB_ICONERROR | MB_SYSTEMMODAL | MB_DEFAULT_DESKTOP_ONLY);
3927   return result == IDYES;
3928 }
3929 
3930 #ifndef PRODUCT
3931 #ifndef _WIN64
3932 // Helpers to check whether NX protection is enabled
3933 int nx_exception_filter(_EXCEPTION_POINTERS *pex) {
3934   if (pex-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION &amp;&amp;
3935       pex-&gt;ExceptionRecord-&gt;NumberParameters &gt; 0 &amp;&amp;
3936       pex-&gt;ExceptionRecord-&gt;ExceptionInformation[0] ==
3937       EXCEPTION_INFO_EXEC_VIOLATION) {
3938     return EXCEPTION_EXECUTE_HANDLER;
3939   }
3940   return EXCEPTION_CONTINUE_SEARCH;
3941 }
3942 
3943 void nx_check_protection() {
3944   // If NX is enabled we&#39;ll get an exception calling into code on the stack
3945   char code[] = { (char)0xC3 }; // ret
3946   void *code_ptr = (void *)code;
3947   __try {
3948     __asm call code_ptr
3949   } __except(nx_exception_filter((_EXCEPTION_POINTERS*)_exception_info())) {
3950     tty-&gt;print_raw_cr(&quot;NX protection detected.&quot;);
3951   }
3952 }
3953 #endif // _WIN64
3954 #endif // PRODUCT
3955 
3956 // This is called _before_ the global arguments have been parsed
3957 void os::init(void) {
3958   _initial_pid = _getpid();
3959 
3960   init_random(1234567);
3961 
3962   win32::initialize_system_info();
3963   win32::setmode_streams();
3964   init_page_sizes((size_t) win32::vm_page_size());
3965 
3966   // This may be overridden later when argument processing is done.
3967   FLAG_SET_ERGO(UseLargePagesIndividualAllocation, false);
3968 
3969   // Initialize main_process and main_thread
3970   main_process = GetCurrentProcess();  // Remember main_process is a pseudo handle
3971   if (!DuplicateHandle(main_process, GetCurrentThread(), main_process,
3972                        &amp;main_thread, THREAD_ALL_ACCESS, false, 0)) {
3973     fatal(&quot;DuplicateHandle failed\n&quot;);
3974   }
3975   main_thread_id = (int) GetCurrentThreadId();
3976 
3977   // initialize fast thread access - only used for 32-bit
3978   win32::initialize_thread_ptr_offset();
3979 }
3980 
3981 // To install functions for atexit processing
3982 extern &quot;C&quot; {
3983   static void perfMemory_exit_helper() {
3984     perfMemory_exit();
3985   }
3986 }
3987 
3988 static jint initSock();
3989 
3990 // this is called _after_ the global arguments have been parsed
3991 jint os::init_2(void) {
3992 
3993   // This could be set any time but all platforms
3994   // have to set it the same so we have to mirror Solaris.
3995   DEBUG_ONLY(os::set_mutex_init_done();)
3996 
3997   // Setup Windows Exceptions
<a name="41" id="anc41"></a><span class="line-modified">3998   topLevelVectoredExceptionHandler = AddVectoredExceptionHandler(1, topLevelExceptionFilter);</span>









3999 
4000   // for debugging float code generation bugs
4001   if (ForceFloatExceptions) {
4002 #ifndef  _WIN64
4003     static long fp_control_word = 0;
4004     __asm { fstcw fp_control_word }
4005     // see Intel PPro Manual, Vol. 2, p 7-16
4006     const long precision = 0x20;
4007     const long underflow = 0x10;
4008     const long overflow  = 0x08;
4009     const long zero_div  = 0x04;
4010     const long denorm    = 0x02;
4011     const long invalid   = 0x01;
4012     fp_control_word |= invalid;
4013     __asm { fldcw fp_control_word }
4014 #endif
4015   }
4016 
4017   // If stack_commit_size is 0, windows will reserve the default size,
4018   // but only commit a small portion of it.
4019   size_t stack_commit_size = align_up(ThreadStackSize*K, os::vm_page_size());
4020   size_t default_reserve_size = os::win32::default_stack_size();
4021   size_t actual_reserve_size = stack_commit_size;
4022   if (stack_commit_size &lt; default_reserve_size) {
4023     // If stack_commit_size == 0, we want this too
4024     actual_reserve_size = default_reserve_size;
4025   }
4026 
4027   // Check minimum allowable stack size for thread creation and to initialize
4028   // the java system classes, including StackOverflowError - depends on page
4029   // size.  Add two 4K pages for compiler2 recursion in main thread.
4030   // Add in 4*BytesPerWord 4K pages to account for VM stack during
4031   // class initialization depending on 32 or 64 bit VM.
4032   size_t min_stack_allowed =
4033             (size_t)(JavaThread::stack_guard_zone_size() +
4034                      JavaThread::stack_shadow_zone_size() +
4035                      (4*BytesPerWord COMPILER2_PRESENT(+2)) * 4 * K);
4036 
4037   min_stack_allowed = align_up(min_stack_allowed, os::vm_page_size());
4038 
4039   if (actual_reserve_size &lt; min_stack_allowed) {
4040     tty-&gt;print_cr(&quot;\nThe Java thread stack size specified is too small. &quot;
4041                   &quot;Specify at least %dk&quot;,
4042                   min_stack_allowed / K);
4043     return JNI_ERR;
4044   }
4045 
4046   JavaThread::set_stack_size_at_create(stack_commit_size);
4047 
4048   // Calculate theoretical max. size of Threads to guard gainst artifical
4049   // out-of-memory situations, where all available address-space has been
4050   // reserved by thread stacks.
4051   assert(actual_reserve_size != 0, &quot;Must have a stack&quot;);
4052 
4053   // Calculate the thread limit when we should start doing Virtual Memory
4054   // banging. Currently when the threads will have used all but 200Mb of space.
4055   //
4056   // TODO: consider performing a similar calculation for commit size instead
4057   // as reserve size, since on a 64-bit platform we&#39;ll run into that more
4058   // often than running out of virtual memory space.  We can use the
4059   // lower value of the two calculations as the os_thread_limit.
4060   size_t max_address_space = ((size_t)1 &lt;&lt; (BitsPerWord - 1)) - (200 * K * K);
4061   win32::_os_thread_limit = (intx)(max_address_space / actual_reserve_size);
4062 
4063   // at exit methods are called in the reverse order of their registration.
4064   // there is no limit to the number of functions registered. atexit does
4065   // not set errno.
4066 
4067   if (PerfAllowAtExitRegistration) {
4068     // only register atexit functions if PerfAllowAtExitRegistration is set.
4069     // atexit functions can be delayed until process exit time, which
4070     // can be problematic for embedded VM situations. Embedded VMs should
4071     // call DestroyJavaVM() to assure that VM resources are released.
4072 
4073     // note: perfMemory_exit_helper atexit function may be removed in
4074     // the future if the appropriate cleanup code can be added to the
4075     // VM_Exit VMOperation&#39;s doit method.
4076     if (atexit(perfMemory_exit_helper) != 0) {
4077       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
4078     }
4079   }
4080 
4081 #ifndef _WIN64
4082   // Print something if NX is enabled (win32 on AMD64)
4083   NOT_PRODUCT(if (PrintMiscellaneous &amp;&amp; Verbose) nx_check_protection());
4084 #endif
4085 
4086   // initialize thread priority policy
4087   prio_init();
4088 
4089   if (UseNUMA &amp;&amp; !ForceNUMA) {
4090     UseNUMA = false; // We don&#39;t fully support this yet
4091   }
4092 
<a name="42" id="anc42"></a><span class="line-modified">4093   if (UseNUMA) {</span>
4094     // first check whether this Windows OS supports VirtualAllocExNuma, if not ignore this flag
4095     bool success = numa_interleaving_init();
4096     if (!success) UseNUMAInterleaving = false;
4097   }
4098 
4099   if (initSock() != JNI_OK) {
4100     return JNI_ERR;
4101   }
4102 
4103   SymbolEngine::recalc_search_path();
4104 
4105   // Initialize data for jdk.internal.misc.Signal
4106   if (!ReduceSignalUsage) {
4107     jdk_misc_signal_init();
4108   }
4109 
4110   return JNI_OK;
4111 }
4112 
4113 // Mark the polling page as unreadable
4114 void os::make_polling_page_unreadable(void) {
4115   DWORD old_status;
4116   if (!VirtualProtect((char *)_polling_page, os::vm_page_size(),
4117                       PAGE_NOACCESS, &amp;old_status)) {
4118     fatal(&quot;Could not disable polling page&quot;);
4119   }
4120 }
4121 
4122 // Mark the polling page as readable
4123 void os::make_polling_page_readable(void) {
4124   DWORD old_status;
4125   if (!VirtualProtect((char *)_polling_page, os::vm_page_size(),
4126                       PAGE_READONLY, &amp;old_status)) {
4127     fatal(&quot;Could not enable polling page&quot;);
4128   }
4129 }
4130 
4131 // combine the high and low DWORD into a ULONGLONG
4132 static ULONGLONG make_double_word(DWORD high_word, DWORD low_word) {
4133   ULONGLONG value = high_word;
4134   value &lt;&lt;= sizeof(high_word) * 8;
4135   value |= low_word;
4136   return value;
4137 }
4138 
4139 // Transfers data from WIN32_FILE_ATTRIBUTE_DATA structure to struct stat
4140 static void file_attribute_data_to_stat(struct stat* sbuf, WIN32_FILE_ATTRIBUTE_DATA file_data) {
4141   ::memset((void*)sbuf, 0, sizeof(struct stat));
4142   sbuf-&gt;st_size = (_off_t)make_double_word(file_data.nFileSizeHigh, file_data.nFileSizeLow);
4143   sbuf-&gt;st_mtime = make_double_word(file_data.ftLastWriteTime.dwHighDateTime,
4144                                   file_data.ftLastWriteTime.dwLowDateTime);
4145   sbuf-&gt;st_ctime = make_double_word(file_data.ftCreationTime.dwHighDateTime,
4146                                   file_data.ftCreationTime.dwLowDateTime);
4147   sbuf-&gt;st_atime = make_double_word(file_data.ftLastAccessTime.dwHighDateTime,
4148                                   file_data.ftLastAccessTime.dwLowDateTime);
4149   if ((file_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
4150     sbuf-&gt;st_mode |= S_IFDIR;
4151   } else {
4152     sbuf-&gt;st_mode |= S_IFREG;
4153   }
4154 }
4155 
4156 // Returns the given path as an absolute wide path in unc format. The returned path is NULL
4157 // on error (with err being set accordingly) and should be freed via os::free() otherwise.
4158 // additional_space is the number of additionally allocated wchars after the terminating L&#39;\0&#39;.
4159 // This is based on pathToNTPath() in io_util_md.cpp, but omits the optimizations for
4160 // short paths.
4161 static wchar_t* wide_abs_unc_path(char const* path, errno_t &amp; err, int additional_space = 0) {
4162   if ((path == NULL) || (path[0] == &#39;\0&#39;)) {
4163     err = ENOENT;
4164     return NULL;
4165   }
4166 
4167   size_t path_len = strlen(path);
4168   // Need to allocate at least room for 3 characters, since os::native_path transforms C: to C:.
4169   char* buf = (char*) os::malloc(1 + MAX2((size_t) 3, path_len), mtInternal);
4170   wchar_t* result = NULL;
4171 
4172   if (buf == NULL) {
4173     err = ENOMEM;
4174   } else {
4175     memcpy(buf, path, path_len + 1);
4176     os::native_path(buf);
4177 
4178     wchar_t* prefix;
4179     int prefix_off = 0;
4180     bool is_abs = true;
4181     bool needs_fullpath = true;
4182 
4183     if (::isalpha(buf[0]) &amp;&amp; !::IsDBCSLeadByte(buf[0]) &amp;&amp; buf[1] == &#39;:&#39; &amp;&amp; buf[2] == &#39;\\&#39;) {
4184       prefix = L&quot;\\\\?\\&quot;;
4185     } else if (buf[0] == &#39;\\&#39; &amp;&amp; buf[1] == &#39;\\&#39;) {
4186       if (buf[2] == &#39;?&#39; &amp;&amp; buf[3] == &#39;\\&#39;) {
4187         prefix = L&quot;&quot;;
4188         needs_fullpath = false;
4189       } else {
4190         prefix = L&quot;\\\\?\\UNC&quot;;
4191         prefix_off = 1; // Overwrite the first char with the prefix, so \\share\path becomes \\?\UNC\share\path
4192       }
4193     } else {
4194       is_abs = false;
4195       prefix = L&quot;\\\\?\\&quot;;
4196     }
4197 
4198     size_t buf_len = strlen(buf);
4199     size_t prefix_len = wcslen(prefix);
4200     size_t full_path_size = is_abs ? 1 + buf_len : JVM_MAXPATHLEN;
4201     size_t result_size = prefix_len + full_path_size - prefix_off;
4202     result = (wchar_t*) os::malloc(sizeof(wchar_t) * (additional_space + result_size), mtInternal);
4203 
4204     if (result == NULL) {
4205       err = ENOMEM;
4206     } else {
4207       size_t converted_chars;
4208       wchar_t* path_start = result + prefix_len - prefix_off;
4209       err = ::mbstowcs_s(&amp;converted_chars, path_start, buf_len + 1, buf, buf_len);
4210 
4211       if ((err == ERROR_SUCCESS) &amp;&amp; needs_fullpath) {
4212         wchar_t* tmp = (wchar_t*) os::malloc(sizeof(wchar_t) * full_path_size, mtInternal);
4213 
4214         if (tmp == NULL) {
4215           err = ENOMEM;
4216         } else {
4217           if (!_wfullpath(tmp, path_start, full_path_size)) {
4218             err = ENOENT;
4219           } else {
4220             ::memcpy(path_start, tmp, (1 + wcslen(tmp)) * sizeof(wchar_t));
4221           }
4222 
4223           os::free(tmp);
4224         }
4225       }
4226 
4227       memcpy(result, prefix, sizeof(wchar_t) * prefix_len);
4228 
4229       // Remove trailing pathsep (not for \\?\&lt;DRIVE&gt;:\, since it would make it relative)
4230       size_t result_len = wcslen(result);
4231 
4232       if (result[result_len - 1] == L&#39;\\&#39;) {
4233         if (!(::iswalpha(result[4]) &amp;&amp; result[5] == L&#39;:&#39; &amp;&amp; result_len == 7)) {
4234           result[result_len - 1] = L&#39;\0&#39;;
4235         }
4236       }
4237     }
4238   }
4239 
4240   os::free(buf);
4241 
4242   if (err != ERROR_SUCCESS) {
4243     os::free(result);
4244     result = NULL;
4245   }
4246 
4247   return result;
4248 }
4249 
4250 int os::stat(const char *path, struct stat *sbuf) {
4251   errno_t err;
4252   wchar_t* wide_path = wide_abs_unc_path(path, err);
4253 
4254   if (wide_path == NULL) {
4255     errno = err;
4256     return -1;
4257   }
4258 
4259   WIN32_FILE_ATTRIBUTE_DATA file_data;;
4260   BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &amp;file_data);
4261   os::free(wide_path);
4262 
4263   if (!bret) {
4264     errno = ::GetLastError();
4265     return -1;
4266   }
4267 
4268   file_attribute_data_to_stat(sbuf, file_data);
4269   return 0;
4270 }
4271 
4272 static HANDLE create_read_only_file_handle(const char* file) {
4273   errno_t err;
4274   wchar_t* wide_path = wide_abs_unc_path(file, err);
4275 
4276   if (wide_path == NULL) {
4277     errno = err;
4278     return INVALID_HANDLE_VALUE;
4279   }
4280 
4281   HANDLE handle = ::CreateFileW(wide_path, 0, FILE_SHARE_READ,
4282                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
4283   os::free(wide_path);
4284 
4285   return handle;
4286 }
4287 
4288 bool os::same_files(const char* file1, const char* file2) {
4289 
4290   if (file1 == NULL &amp;&amp; file2 == NULL) {
4291     return true;
4292   }
4293 
4294   if (file1 == NULL || file2 == NULL) {
4295     return false;
4296   }
4297 
4298   if (strcmp(file1, file2) == 0) {
4299     return true;
4300   }
4301 
4302   HANDLE handle1 = create_read_only_file_handle(file1);
4303   HANDLE handle2 = create_read_only_file_handle(file2);
4304   bool result = false;
4305 
4306   // if we could open both paths...
4307   if (handle1 != INVALID_HANDLE_VALUE &amp;&amp; handle2 != INVALID_HANDLE_VALUE) {
4308     BY_HANDLE_FILE_INFORMATION fileInfo1;
4309     BY_HANDLE_FILE_INFORMATION fileInfo2;
4310     if (::GetFileInformationByHandle(handle1, &amp;fileInfo1) &amp;&amp;
4311       ::GetFileInformationByHandle(handle2, &amp;fileInfo2)) {
4312       // the paths are the same if they refer to the same file (fileindex) on the same volume (volume serial number)
4313       if (fileInfo1.dwVolumeSerialNumber == fileInfo2.dwVolumeSerialNumber &amp;&amp;
4314         fileInfo1.nFileIndexHigh == fileInfo2.nFileIndexHigh &amp;&amp;
4315         fileInfo1.nFileIndexLow == fileInfo2.nFileIndexLow) {
4316         result = true;
4317       }
4318     }
4319   }
4320 
4321   //free the handles
4322   if (handle1 != INVALID_HANDLE_VALUE) {
4323     ::CloseHandle(handle1);
4324   }
4325 
4326   if (handle2 != INVALID_HANDLE_VALUE) {
4327     ::CloseHandle(handle2);
4328   }
4329 
4330   return result;
4331 }
4332 
4333 #define FT2INT64(ft) \
4334   ((jlong)((jlong)(ft).dwHighDateTime &lt;&lt; 32 | (julong)(ft).dwLowDateTime))
4335 
4336 
4337 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
4338 // are used by JVM M&amp;M and JVMTI to get user+sys or user CPU time
4339 // of a thread.
4340 //
4341 // current_thread_cpu_time() and thread_cpu_time(Thread*) returns
4342 // the fast estimate available on the platform.
4343 
4344 // current_thread_cpu_time() is not optimized for Windows yet
4345 jlong os::current_thread_cpu_time() {
4346   // return user + sys since the cost is the same
4347   return os::thread_cpu_time(Thread::current(), true /* user+sys */);
4348 }
4349 
4350 jlong os::thread_cpu_time(Thread* thread) {
4351   // consistent with what current_thread_cpu_time() returns.
4352   return os::thread_cpu_time(thread, true /* user+sys */);
4353 }
4354 
4355 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
4356   return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
4357 }
4358 
4359 jlong os::thread_cpu_time(Thread* thread, bool user_sys_cpu_time) {
4360   // This code is copy from clasic VM -&gt; hpi::sysThreadCPUTime
4361   // If this function changes, os::is_thread_cpu_time_supported() should too
4362   FILETIME CreationTime;
4363   FILETIME ExitTime;
4364   FILETIME KernelTime;
4365   FILETIME UserTime;
4366 
4367   if (GetThreadTimes(thread-&gt;osthread()-&gt;thread_handle(), &amp;CreationTime,
4368                       &amp;ExitTime, &amp;KernelTime, &amp;UserTime) == 0) {
4369     return -1;
4370   } else if (user_sys_cpu_time) {
4371     return (FT2INT64(UserTime) + FT2INT64(KernelTime)) * 100;
4372   } else {
4373     return FT2INT64(UserTime) * 100;
4374   }
4375 }
4376 
4377 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4378   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4379   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4380   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4381   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4382 }
4383 
4384 void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4385   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4386   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4387   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4388   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4389 }
4390 
4391 bool os::is_thread_cpu_time_supported() {
4392   // see os::thread_cpu_time
4393   FILETIME CreationTime;
4394   FILETIME ExitTime;
4395   FILETIME KernelTime;
4396   FILETIME UserTime;
4397 
4398   if (GetThreadTimes(GetCurrentThread(), &amp;CreationTime, &amp;ExitTime,
4399                       &amp;KernelTime, &amp;UserTime) == 0) {
4400     return false;
4401   } else {
4402     return true;
4403   }
4404 }
4405 
4406 // Windows does&#39;t provide a loadavg primitive so this is stubbed out for now.
4407 // It does have primitives (PDH API) to get CPU usage and run queue length.
4408 // &quot;\\Processor(_Total)\\% Processor Time&quot;, &quot;\\System\\Processor Queue Length&quot;
4409 // If we wanted to implement loadavg on Windows, we have a few options:
4410 //
4411 // a) Query CPU usage and run queue length and &quot;fake&quot; an answer by
4412 //    returning the CPU usage if it&#39;s under 100%, and the run queue
4413 //    length otherwise.  It turns out that querying is pretty slow
4414 //    on Windows, on the order of 200 microseconds on a fast machine.
4415 //    Note that on the Windows the CPU usage value is the % usage
4416 //    since the last time the API was called (and the first call
4417 //    returns 100%), so we&#39;d have to deal with that as well.
4418 //
4419 // b) Sample the &quot;fake&quot; answer using a sampling thread and store
4420 //    the answer in a global variable.  The call to loadavg would
4421 //    just return the value of the global, avoiding the slow query.
4422 //
4423 // c) Sample a better answer using exponential decay to smooth the
4424 //    value.  This is basically the algorithm used by UNIX kernels.
4425 //
4426 // Note that sampling thread starvation could affect both (b) and (c).
4427 int os::loadavg(double loadavg[], int nelem) {
4428   return -1;
4429 }
4430 
4431 
4432 // DontYieldALot=false by default: dutifully perform all yields as requested by JVM_Yield()
4433 bool os::dont_yield() {
4434   return DontYieldALot;
4435 }
4436 
4437 int os::open(const char *path, int oflag, int mode) {
4438   errno_t err;
4439   wchar_t* wide_path = wide_abs_unc_path(path, err);
4440 
4441   if (wide_path == NULL) {
4442     errno = err;
4443     return -1;
4444   }
4445   int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);
4446   os::free(wide_path);
4447 
4448   if (fd == -1) {
4449     errno = ::GetLastError();
4450   }
4451 
4452   return fd;
4453 }
4454 
4455 FILE* os::open(int fd, const char* mode) {
4456   return ::_fdopen(fd, mode);
4457 }
4458 
4459 // Is a (classpath) directory empty?
4460 bool os::dir_is_empty(const char* path) {
4461   errno_t err;
4462   wchar_t* wide_path = wide_abs_unc_path(path, err, 2);
4463 
4464   if (wide_path == NULL) {
4465     errno = err;
4466     return false;
4467   }
4468 
4469   // Make sure we end with &quot;\\*&quot;
4470   if (wide_path[wcslen(wide_path) - 1] == L&#39;\\&#39;) {
4471     wcscat(wide_path, L&quot;*&quot;);
4472   } else {
4473     wcscat(wide_path, L&quot;\\*&quot;);
4474   }
4475 
4476   WIN32_FIND_DATAW fd;
4477   HANDLE f = ::FindFirstFileW(wide_path, &amp;fd);
4478   os::free(wide_path);
4479   bool is_empty = true;
4480 
4481   if (f != INVALID_HANDLE_VALUE) {
4482     while (is_empty &amp;&amp; ::FindNextFileW(f, &amp;fd)) {
4483       // An empty directory contains only the current directory file
4484       // and the previous directory file.
4485       if ((wcscmp(fd.cFileName, L&quot;.&quot;) != 0) &amp;&amp;
4486           (wcscmp(fd.cFileName, L&quot;..&quot;) != 0)) {
4487         is_empty = false;
4488       }
4489     }
4490     FindClose(f);
4491   } else {
4492     errno = ::GetLastError();
4493   }
4494 
4495   return is_empty;
4496 }
4497 
4498 // create binary file, rewriting existing file if required
4499 int os::create_binary_file(const char* path, bool rewrite_existing) {
4500   int oflags = _O_CREAT | _O_WRONLY | _O_BINARY;
4501   if (!rewrite_existing) {
4502     oflags |= _O_EXCL;
4503   }
4504   return ::open(path, oflags, _S_IREAD | _S_IWRITE);
4505 }
4506 
4507 // return current position of file pointer
4508 jlong os::current_file_offset(int fd) {
4509   return (jlong)::_lseeki64(fd, (__int64)0L, SEEK_CUR);
4510 }
4511 
4512 // move file pointer to the specified offset
4513 jlong os::seek_to_file_offset(int fd, jlong offset) {
4514   return (jlong)::_lseeki64(fd, (__int64)offset, SEEK_SET);
4515 }
4516 
4517 
4518 jlong os::lseek(int fd, jlong offset, int whence) {
4519   return (jlong) ::_lseeki64(fd, offset, whence);
4520 }
4521 
4522 ssize_t os::read_at(int fd, void *buf, unsigned int nBytes, jlong offset) {
4523   OVERLAPPED ov;
4524   DWORD nread;
4525   BOOL result;
4526 
4527   ZeroMemory(&amp;ov, sizeof(ov));
4528   ov.Offset = (DWORD)offset;
4529   ov.OffsetHigh = (DWORD)(offset &gt;&gt; 32);
4530 
4531   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4532 
4533   result = ReadFile(h, (LPVOID)buf, nBytes, &amp;nread, &amp;ov);
4534 
4535   return result ? nread : 0;
4536 }
4537 
4538 
4539 // This method is a slightly reworked copy of JDK&#39;s sysNativePath
4540 // from src/windows/hpi/src/path_md.c
4541 
4542 // Convert a pathname to native format.  On win32, this involves forcing all
4543 // separators to be &#39;\\&#39; rather than &#39;/&#39; (both are legal inputs, but Win95
4544 // sometimes rejects &#39;/&#39;) and removing redundant separators.  The input path is
4545 // assumed to have been converted into the character encoding used by the local
4546 // system.  Because this might be a double-byte encoding, care is taken to
4547 // treat double-byte lead characters correctly.
4548 //
4549 // This procedure modifies the given path in place, as the result is never
4550 // longer than the original.  There is no error return; this operation always
4551 // succeeds.
4552 char * os::native_path(char *path) {
4553   char *src = path, *dst = path, *end = path;
4554   char *colon = NULL;  // If a drive specifier is found, this will
4555                        // point to the colon following the drive letter
4556 
4557   // Assumption: &#39;/&#39;, &#39;\\&#39;, &#39;:&#39;, and drive letters are never lead bytes
4558   assert(((!::IsDBCSLeadByte(&#39;/&#39;)) &amp;&amp; (!::IsDBCSLeadByte(&#39;\\&#39;))
4559           &amp;&amp; (!::IsDBCSLeadByte(&#39;:&#39;))), &quot;Illegal lead byte&quot;);
4560 
4561   // Check for leading separators
4562 #define isfilesep(c) ((c) == &#39;/&#39; || (c) == &#39;\\&#39;)
4563   while (isfilesep(*src)) {
4564     src++;
4565   }
4566 
4567   if (::isalpha(*src) &amp;&amp; !::IsDBCSLeadByte(*src) &amp;&amp; src[1] == &#39;:&#39;) {
4568     // Remove leading separators if followed by drive specifier.  This
4569     // hack is necessary to support file URLs containing drive
4570     // specifiers (e.g., &quot;file://c:/path&quot;).  As a side effect,
4571     // &quot;/c:/path&quot; can be used as an alternative to &quot;c:/path&quot;.
4572     *dst++ = *src++;
4573     colon = dst;
4574     *dst++ = &#39;:&#39;;
4575     src++;
4576   } else {
4577     src = path;
4578     if (isfilesep(src[0]) &amp;&amp; isfilesep(src[1])) {
4579       // UNC pathname: Retain first separator; leave src pointed at
4580       // second separator so that further separators will be collapsed
4581       // into the second separator.  The result will be a pathname
4582       // beginning with &quot;\\\\&quot; followed (most likely) by a host name.
4583       src = dst = path + 1;
4584       path[0] = &#39;\\&#39;;     // Force first separator to &#39;\\&#39;
4585     }
4586   }
4587 
4588   end = dst;
4589 
4590   // Remove redundant separators from remainder of path, forcing all
4591   // separators to be &#39;\\&#39; rather than &#39;/&#39;. Also, single byte space
4592   // characters are removed from the end of the path because those
4593   // are not legal ending characters on this operating system.
4594   //
4595   while (*src != &#39;\0&#39;) {
4596     if (isfilesep(*src)) {
4597       *dst++ = &#39;\\&#39;; src++;
4598       while (isfilesep(*src)) src++;
4599       if (*src == &#39;\0&#39;) {
4600         // Check for trailing separator
4601         end = dst;
4602         if (colon == dst - 2) break;  // &quot;z:\\&quot;
4603         if (dst == path + 1) break;   // &quot;\\&quot;
4604         if (dst == path + 2 &amp;&amp; isfilesep(path[0])) {
4605           // &quot;\\\\&quot; is not collapsed to &quot;\\&quot; because &quot;\\\\&quot; marks the
4606           // beginning of a UNC pathname.  Even though it is not, by
4607           // itself, a valid UNC pathname, we leave it as is in order
4608           // to be consistent with the path canonicalizer as well
4609           // as the win32 APIs, which treat this case as an invalid
4610           // UNC pathname rather than as an alias for the root
4611           // directory of the current drive.
4612           break;
4613         }
4614         end = --dst;  // Path does not denote a root directory, so
4615                       // remove trailing separator
4616         break;
4617       }
4618       end = dst;
4619     } else {
4620       if (::IsDBCSLeadByte(*src)) {  // Copy a double-byte character
4621         *dst++ = *src++;
4622         if (*src) *dst++ = *src++;
4623         end = dst;
4624       } else {  // Copy a single-byte character
4625         char c = *src++;
4626         *dst++ = c;
4627         // Space is not a legal ending character
4628         if (c != &#39; &#39;) end = dst;
4629       }
4630     }
4631   }
4632 
4633   *end = &#39;\0&#39;;
4634 
4635   // For &quot;z:&quot;, add &quot;.&quot; to work around a bug in the C runtime library
4636   if (colon == dst - 1) {
4637     path[2] = &#39;.&#39;;
4638     path[3] = &#39;\0&#39;;
4639   }
4640 
4641   return path;
4642 }
4643 
4644 // This code is a copy of JDK&#39;s sysSetLength
4645 // from src/windows/hpi/src/sys_api_md.c
4646 
4647 int os::ftruncate(int fd, jlong length) {
4648   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4649   long high = (long)(length &gt;&gt; 32);
4650   DWORD ret;
4651 
4652   if (h == (HANDLE)(-1)) {
4653     return -1;
4654   }
4655 
4656   ret = ::SetFilePointer(h, (long)(length), &amp;high, FILE_BEGIN);
4657   if ((ret == 0xFFFFFFFF) &amp;&amp; (::GetLastError() != NO_ERROR)) {
4658     return -1;
4659   }
4660 
4661   if (::SetEndOfFile(h) == FALSE) {
4662     return -1;
4663   }
4664 
4665   return 0;
4666 }
4667 
4668 int os::get_fileno(FILE* fp) {
4669   return _fileno(fp);
4670 }
4671 
4672 // This code is a copy of JDK&#39;s sysSync
4673 // from src/windows/hpi/src/sys_api_md.c
4674 // except for the legacy workaround for a bug in Win 98
4675 
4676 int os::fsync(int fd) {
4677   HANDLE handle = (HANDLE)::_get_osfhandle(fd);
4678 
4679   if ((!::FlushFileBuffers(handle)) &amp;&amp;
4680       (GetLastError() != ERROR_ACCESS_DENIED)) {
4681     // from winerror.h
4682     return -1;
4683   }
4684   return 0;
4685 }
4686 
4687 static int nonSeekAvailable(int, long *);
4688 static int stdinAvailable(int, long *);
4689 
4690 // This code is a copy of JDK&#39;s sysAvailable
4691 // from src/windows/hpi/src/sys_api_md.c
4692 
4693 int os::available(int fd, jlong *bytes) {
4694   jlong cur, end;
4695   struct _stati64 stbuf64;
4696 
4697   if (::_fstati64(fd, &amp;stbuf64) &gt;= 0) {
4698     int mode = stbuf64.st_mode;
4699     if (S_ISCHR(mode) || S_ISFIFO(mode)) {
4700       int ret;
4701       long lpbytes;
4702       if (fd == 0) {
4703         ret = stdinAvailable(fd, &amp;lpbytes);
4704       } else {
4705         ret = nonSeekAvailable(fd, &amp;lpbytes);
4706       }
4707       (*bytes) = (jlong)(lpbytes);
4708       return ret;
4709     }
4710     if ((cur = ::_lseeki64(fd, 0L, SEEK_CUR)) == -1) {
4711       return FALSE;
4712     } else if ((end = ::_lseeki64(fd, 0L, SEEK_END)) == -1) {
4713       return FALSE;
4714     } else if (::_lseeki64(fd, cur, SEEK_SET) == -1) {
4715       return FALSE;
4716     }
4717     *bytes = end - cur;
4718     return TRUE;
4719   } else {
4720     return FALSE;
4721   }
4722 }
4723 
4724 void os::flockfile(FILE* fp) {
4725   _lock_file(fp);
4726 }
4727 
4728 void os::funlockfile(FILE* fp) {
4729   _unlock_file(fp);
4730 }
4731 
4732 // This code is a copy of JDK&#39;s nonSeekAvailable
4733 // from src/windows/hpi/src/sys_api_md.c
4734 
4735 static int nonSeekAvailable(int fd, long *pbytes) {
4736   // This is used for available on non-seekable devices
4737   // (like both named and anonymous pipes, such as pipes
4738   //  connected to an exec&#39;d process).
4739   // Standard Input is a special case.
4740   HANDLE han;
4741 
4742   if ((han = (HANDLE) ::_get_osfhandle(fd)) == (HANDLE)(-1)) {
4743     return FALSE;
4744   }
4745 
4746   if (! ::PeekNamedPipe(han, NULL, 0, NULL, (LPDWORD)pbytes, NULL)) {
4747     // PeekNamedPipe fails when at EOF.  In that case we
4748     // simply make *pbytes = 0 which is consistent with the
4749     // behavior we get on Solaris when an fd is at EOF.
4750     // The only alternative is to raise an Exception,
4751     // which isn&#39;t really warranted.
4752     //
4753     if (::GetLastError() != ERROR_BROKEN_PIPE) {
4754       return FALSE;
4755     }
4756     *pbytes = 0;
4757   }
4758   return TRUE;
4759 }
4760 
4761 #define MAX_INPUT_EVENTS 2000
4762 
4763 // This code is a copy of JDK&#39;s stdinAvailable
4764 // from src/windows/hpi/src/sys_api_md.c
4765 
4766 static int stdinAvailable(int fd, long *pbytes) {
4767   HANDLE han;
4768   DWORD numEventsRead = 0;  // Number of events read from buffer
4769   DWORD numEvents = 0;      // Number of events in buffer
4770   DWORD i = 0;              // Loop index
4771   DWORD curLength = 0;      // Position marker
4772   DWORD actualLength = 0;   // Number of bytes readable
4773   BOOL error = FALSE;       // Error holder
4774   INPUT_RECORD *lpBuffer;   // Pointer to records of input events
4775 
4776   if ((han = ::GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
4777     return FALSE;
4778   }
4779 
4780   // Construct an array of input records in the console buffer
4781   error = ::GetNumberOfConsoleInputEvents(han, &amp;numEvents);
4782   if (error == 0) {
4783     return nonSeekAvailable(fd, pbytes);
4784   }
4785 
4786   // lpBuffer must fit into 64K or else PeekConsoleInput fails
4787   if (numEvents &gt; MAX_INPUT_EVENTS) {
4788     numEvents = MAX_INPUT_EVENTS;
4789   }
4790 
4791   lpBuffer = (INPUT_RECORD *)os::malloc(numEvents * sizeof(INPUT_RECORD), mtInternal);
4792   if (lpBuffer == NULL) {
4793     return FALSE;
4794   }
4795 
4796   error = ::PeekConsoleInput(han, lpBuffer, numEvents, &amp;numEventsRead);
4797   if (error == 0) {
4798     os::free(lpBuffer);
4799     return FALSE;
4800   }
4801 
4802   // Examine input records for the number of bytes available
4803   for (i=0; i&lt;numEvents; i++) {
4804     if (lpBuffer[i].EventType == KEY_EVENT) {
4805 
4806       KEY_EVENT_RECORD *keyRecord = (KEY_EVENT_RECORD *)
4807                                       &amp;(lpBuffer[i].Event);
4808       if (keyRecord-&gt;bKeyDown == TRUE) {
4809         CHAR *keyPressed = (CHAR *) &amp;(keyRecord-&gt;uChar);
4810         curLength++;
4811         if (*keyPressed == &#39;\r&#39;) {
4812           actualLength = curLength;
4813         }
4814       }
4815     }
4816   }
4817 
4818   if (lpBuffer != NULL) {
4819     os::free(lpBuffer);
4820   }
4821 
4822   *pbytes = (long) actualLength;
4823   return TRUE;
4824 }
4825 
4826 // Map a block of memory.
4827 char* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,
4828                         char *addr, size_t bytes, bool read_only,
4829                         bool allow_exec) {
4830   HANDLE hFile;
4831   char* base;
4832 
4833   hFile = CreateFile(file_name, GENERIC_READ, FILE_SHARE_READ, NULL,
4834                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
4835   if (hFile == NULL) {
4836     log_info(os)(&quot;CreateFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4837     return NULL;
4838   }
4839 
4840   if (allow_exec) {
4841     // CreateFileMapping/MapViewOfFileEx can&#39;t map executable memory
4842     // unless it comes from a PE image (which the shared archive is not.)
4843     // Even VirtualProtect refuses to give execute access to mapped memory
4844     // that was not previously executable.
4845     //
4846     // Instead, stick the executable region in anonymous memory.  Yuck.
4847     // Penalty is that ~4 pages will not be shareable - in the future
4848     // we might consider DLLizing the shared archive with a proper PE
4849     // header so that mapping executable + sharing is possible.
4850 
4851     base = (char*) VirtualAlloc(addr, bytes, MEM_COMMIT | MEM_RESERVE,
4852                                 PAGE_READWRITE);
4853     if (base == NULL) {
4854       log_info(os)(&quot;VirtualAlloc() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4855       CloseHandle(hFile);
4856       return NULL;
4857     }
4858 
4859     // Record virtual memory allocation
4860     MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);
4861 
4862     DWORD bytes_read;
4863     OVERLAPPED overlapped;
4864     overlapped.Offset = (DWORD)file_offset;
4865     overlapped.OffsetHigh = 0;
4866     overlapped.hEvent = NULL;
4867     // ReadFile guarantees that if the return value is true, the requested
4868     // number of bytes were read before returning.
4869     bool res = ReadFile(hFile, base, (DWORD)bytes, &amp;bytes_read, &amp;overlapped) != 0;
4870     if (!res) {
4871       log_info(os)(&quot;ReadFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4872       release_memory(base, bytes);
4873       CloseHandle(hFile);
4874       return NULL;
4875     }
4876   } else {
4877     HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,
4878                                     NULL /* file_name */);
4879     if (hMap == NULL) {
4880       log_info(os)(&quot;CreateFileMapping() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4881       CloseHandle(hFile);
4882       return NULL;
4883     }
4884 
4885     DWORD access = read_only ? FILE_MAP_READ : FILE_MAP_COPY;
4886     base = (char*)MapViewOfFileEx(hMap, access, 0, (DWORD)file_offset,
4887                                   (DWORD)bytes, addr);
4888     if (base == NULL) {
4889       log_info(os)(&quot;MapViewOfFileEx() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4890       CloseHandle(hMap);
4891       CloseHandle(hFile);
4892       return NULL;
4893     }
4894 
4895     if (CloseHandle(hMap) == 0) {
4896       log_info(os)(&quot;CloseHandle(hMap) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4897       CloseHandle(hFile);
4898       return base;
4899     }
4900   }
4901 
4902   if (allow_exec) {
4903     DWORD old_protect;
4904     DWORD exec_access = read_only ? PAGE_EXECUTE_READ : PAGE_EXECUTE_READWRITE;
4905     bool res = VirtualProtect(base, bytes, exec_access, &amp;old_protect) != 0;
4906 
4907     if (!res) {
4908       log_info(os)(&quot;VirtualProtect() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4909       // Don&#39;t consider this a hard error, on IA32 even if the
4910       // VirtualProtect fails, we should still be able to execute
4911       CloseHandle(hFile);
4912       return base;
4913     }
4914   }
4915 
4916   if (CloseHandle(hFile) == 0) {
4917     log_info(os)(&quot;CloseHandle(hFile) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4918     return base;
4919   }
4920 
4921   return base;
4922 }
4923 
4924 
4925 // Remap a block of memory.
4926 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
4927                           char *addr, size_t bytes, bool read_only,
4928                           bool allow_exec) {
4929   // This OS does not allow existing memory maps to be remapped so we
4930   // would have to unmap the memory before we remap it.
4931 
4932   // Because there is a small window between unmapping memory and mapping
4933   // it in again with different protections, CDS archives are mapped RW
4934   // on windows, so this function isn&#39;t called.
4935   ShouldNotReachHere();
4936   return NULL;
4937 }
4938 
4939 
4940 // Unmap a block of memory.
4941 // Returns true=success, otherwise false.
4942 
4943 bool os::pd_unmap_memory(char* addr, size_t bytes) {
4944   MEMORY_BASIC_INFORMATION mem_info;
4945   if (VirtualQuery(addr, &amp;mem_info, sizeof(mem_info)) == 0) {
4946     log_info(os)(&quot;VirtualQuery() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4947     return false;
4948   }
4949 
4950   // Executable memory was not mapped using CreateFileMapping/MapViewOfFileEx.
4951   // Instead, executable region was allocated using VirtualAlloc(). See
4952   // pd_map_memory() above.
4953   //
4954   // The following flags should match the &#39;exec_access&#39; flages used for
4955   // VirtualProtect() in pd_map_memory().
4956   if (mem_info.Protect == PAGE_EXECUTE_READ ||
4957       mem_info.Protect == PAGE_EXECUTE_READWRITE) {
4958     return pd_release_memory(addr, bytes);
4959   }
4960 
4961   BOOL result = UnmapViewOfFile(addr);
4962   if (result == 0) {
4963     log_info(os)(&quot;UnmapViewOfFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4964     return false;
4965   }
4966   return true;
4967 }
4968 
4969 void os::pause() {
4970   char filename[MAX_PATH];
4971   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
4972     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);
4973   } else {
4974     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
4975   }
4976 
4977   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4978   if (fd != -1) {
4979     struct stat buf;
4980     ::close(fd);
4981     while (::stat(filename, &amp;buf) == 0) {
4982       Sleep(100);
4983     }
4984   } else {
4985     jio_fprintf(stderr,
4986                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
4987   }
4988 }
4989 
4990 Thread* os::ThreadCrashProtection::_protected_thread = NULL;
4991 os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;
4992 volatile intptr_t os::ThreadCrashProtection::_crash_mux = 0;
4993 
4994 os::ThreadCrashProtection::ThreadCrashProtection() {
4995 }
4996 
4997 // See the caveats for this class in os_windows.hpp
4998 // Protects the callback call so that raised OS EXCEPTIONS causes a jump back
4999 // into this method and returns false. If no OS EXCEPTION was raised, returns
5000 // true.
5001 // The callback is supposed to provide the method that should be protected.
5002 //
5003 bool os::ThreadCrashProtection::call(os::CrashProtectionCallback&amp; cb) {
5004 
5005   Thread::muxAcquire(&amp;_crash_mux, &quot;CrashProtection&quot;);
5006 
5007   _protected_thread = Thread::current_or_null();
5008   assert(_protected_thread != NULL, &quot;Cannot crash protect a NULL thread&quot;);
5009 
5010   bool success = true;
5011   __try {
5012     _crash_protection = this;
5013     cb.call();
5014   } __except(EXCEPTION_EXECUTE_HANDLER) {
5015     // only for protection, nothing to do
5016     success = false;
5017   }
5018   _crash_protection = NULL;
5019   _protected_thread = NULL;
5020   Thread::muxRelease(&amp;_crash_mux);
5021   return success;
5022 }
5023 
5024 
5025 class HighResolutionInterval : public CHeapObj&lt;mtThread&gt; {
5026   // The default timer resolution seems to be 10 milliseconds.
5027   // (Where is this written down?)
5028   // If someone wants to sleep for only a fraction of the default,
5029   // then we set the timer resolution down to 1 millisecond for
5030   // the duration of their interval.
5031   // We carefully set the resolution back, since otherwise we
5032   // seem to incur an overhead (3%?) that we don&#39;t need.
5033   // CONSIDER: if ms is small, say 3, then we should run with a high resolution time.
5034   // Buf if ms is large, say 500, or 503, we should avoid the call to timeBeginPeriod().
5035   // Alternatively, we could compute the relative error (503/500 = .6%) and only use
5036   // timeBeginPeriod() if the relative error exceeded some threshold.
5037   // timeBeginPeriod() has been linked to problems with clock drift on win32 systems and
5038   // to decreased efficiency related to increased timer &quot;tick&quot; rates.  We want to minimize
5039   // (a) calls to timeBeginPeriod() and timeEndPeriod() and (b) time spent with high
5040   // resolution timers running.
5041  private:
5042   jlong resolution;
5043  public:
5044   HighResolutionInterval(jlong ms) {
5045     resolution = ms % 10L;
5046     if (resolution != 0) {
5047       MMRESULT result = timeBeginPeriod(1L);
5048     }
5049   }
5050   ~HighResolutionInterval() {
5051     if (resolution != 0) {
5052       MMRESULT result = timeEndPeriod(1L);
5053     }
5054     resolution = 0L;
5055   }
5056 };
5057 
5058 // An Event wraps a win32 &quot;CreateEvent&quot; kernel handle.
5059 //
5060 // We have a number of choices regarding &quot;CreateEvent&quot; win32 handle leakage:
5061 //
5062 // 1:  When a thread dies return the Event to the EventFreeList, clear the ParkHandle
5063 //     field, and call CloseHandle() on the win32 event handle.  Unpark() would
5064 //     need to be modified to tolerate finding a NULL (invalid) win32 event handle.
5065 //     In addition, an unpark() operation might fetch the handle field, but the
5066 //     event could recycle between the fetch and the SetEvent() operation.
5067 //     SetEvent() would either fail because the handle was invalid, or inadvertently work,
5068 //     as the win32 handle value had been recycled.  In an ideal world calling SetEvent()
5069 //     on an stale but recycled handle would be harmless, but in practice this might
5070 //     confuse other non-Sun code, so it&#39;s not a viable approach.
5071 //
5072 // 2:  Once a win32 event handle is associated with an Event, it remains associated
5073 //     with the Event.  The event handle is never closed.  This could be construed
5074 //     as handle leakage, but only up to the maximum # of threads that have been extant
5075 //     at any one time.  This shouldn&#39;t be an issue, as windows platforms typically
5076 //     permit a process to have hundreds of thousands of open handles.
5077 //
5078 // 3:  Same as (1), but periodically, at stop-the-world time, rundown the EventFreeList
5079 //     and release unused handles.
5080 //
5081 // 4:  Add a CRITICAL_SECTION to the Event to protect LD+SetEvent from LD;ST(null);CloseHandle.
5082 //     It&#39;s not clear, however, that we wouldn&#39;t be trading one type of leak for another.
5083 //
5084 // 5.  Use an RCU-like mechanism (Read-Copy Update).
5085 //     Or perhaps something similar to Maged Michael&#39;s &quot;Hazard pointers&quot;.
5086 //
5087 // We use (2).
5088 //
5089 // TODO-FIXME:
5090 // 1.  Reconcile Doug&#39;s JSR166 j.u.c park-unpark with the objectmonitor implementation.
5091 // 2.  Consider wrapping the WaitForSingleObject(Ex) calls in SEH try/finally blocks
5092 //     to recover from (or at least detect) the dreaded Windows 841176 bug.
5093 // 3.  Collapse the JSR166 parker event, and the objectmonitor ParkEvent
5094 //     into a single win32 CreateEvent() handle.
5095 //
5096 // Assumption:
5097 //    Only one parker can exist on an event, which is why we allocate
5098 //    them per-thread. Multiple unparkers can coexist.
5099 //
5100 // _Event transitions in park()
5101 //   -1 =&gt; -1 : illegal
5102 //    1 =&gt;  0 : pass - return immediately
5103 //    0 =&gt; -1 : block; then set _Event to 0 before returning
5104 //
5105 // _Event transitions in unpark()
5106 //    0 =&gt; 1 : just return
5107 //    1 =&gt; 1 : just return
5108 //   -1 =&gt; either 0 or 1; must signal target thread
5109 //         That is, we can safely transition _Event from -1 to either
5110 //         0 or 1.
5111 //
5112 // _Event serves as a restricted-range semaphore.
5113 //   -1 : thread is blocked, i.e. there is a waiter
5114 //    0 : neutral: thread is running or ready,
5115 //        could have been signaled after a wait started
5116 //    1 : signaled - thread is running or ready
5117 //
5118 // Another possible encoding of _Event would be with
5119 // explicit &quot;PARKED&quot; == 01b and &quot;SIGNALED&quot; == 10b bits.
5120 //
5121 
5122 int os::PlatformEvent::park(jlong Millis) {
5123   // Transitions for _Event:
5124   //   -1 =&gt; -1 : illegal
5125   //    1 =&gt;  0 : pass - return immediately
5126   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5127 
5128   guarantee(_ParkHandle != NULL , &quot;Invariant&quot;);
5129   guarantee(Millis &gt; 0          , &quot;Invariant&quot;);
5130 
5131   // CONSIDER: defer assigning a CreateEvent() handle to the Event until
5132   // the initial park() operation.
5133   // Consider: use atomic decrement instead of CAS-loop
5134 
5135   int v;
5136   for (;;) {
5137     v = _Event;
5138     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;
5139   }
5140   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5141   if (v != 0) return OS_OK;
5142 
5143   // Do this the hard way by blocking ...
5144   // TODO: consider a brief spin here, gated on the success of recent
5145   // spin attempts by this thread.
5146   //
5147   // We decompose long timeouts into series of shorter timed waits.
5148   // Evidently large timo values passed in WaitForSingleObject() are problematic on some
5149   // versions of Windows.  See EventWait() for details.  This may be superstition.  Or not.
5150   // We trust the WAIT_TIMEOUT indication and don&#39;t track the elapsed wait time
5151   // with os::javaTimeNanos().  Furthermore, we assume that spurious returns from
5152   // ::WaitForSingleObject() caused by latent ::setEvent() operations will tend
5153   // to happen early in the wait interval.  Specifically, after a spurious wakeup (rv ==
5154   // WAIT_OBJECT_0 but _Event is still &lt; 0) we don&#39;t bother to recompute Millis to compensate
5155   // for the already waited time.  This policy does not admit any new outcomes.
5156   // In the future, however, we might want to track the accumulated wait time and
5157   // adjust Millis accordingly if we encounter a spurious wakeup.
5158 
5159   const int MAXTIMEOUT = 0x10000000;
5160   DWORD rv = WAIT_TIMEOUT;
5161   while (_Event &lt; 0 &amp;&amp; Millis &gt; 0) {
5162     DWORD prd = Millis;     // set prd = MAX (Millis, MAXTIMEOUT)
5163     if (Millis &gt; MAXTIMEOUT) {
5164       prd = MAXTIMEOUT;
5165     }
5166     HighResolutionInterval *phri = NULL;
5167     if (!ForceTimeHighResolution) {
5168       phri = new HighResolutionInterval(prd);
5169     }
5170     rv = ::WaitForSingleObject(_ParkHandle, prd);
5171     assert(rv == WAIT_OBJECT_0 || rv == WAIT_TIMEOUT, &quot;WaitForSingleObject failed&quot;);
5172     if (rv == WAIT_TIMEOUT) {
5173       Millis -= prd;
5174     }
5175     delete phri; // if it is NULL, harmless
5176   }
5177   v = _Event;
5178   _Event = 0;
5179   // see comment at end of os::PlatformEvent::park() below:
5180   OrderAccess::fence();
5181   // If we encounter a nearly simultanous timeout expiry and unpark()
5182   // we return OS_OK indicating we awoke via unpark().
5183   // Implementor&#39;s license -- returning OS_TIMEOUT would be equally valid, however.
5184   return (v &gt;= 0) ? OS_OK : OS_TIMEOUT;
5185 }
5186 
5187 void os::PlatformEvent::park() {
5188   // Transitions for _Event:
5189   //   -1 =&gt; -1 : illegal
5190   //    1 =&gt;  0 : pass - return immediately
5191   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5192 
5193   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5194   // Invariant: Only the thread associated with the Event/PlatformEvent
5195   // may call park().
5196   // Consider: use atomic decrement instead of CAS-loop
5197   int v;
5198   for (;;) {
5199     v = _Event;
5200     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;
5201   }
5202   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5203   if (v != 0) return;
5204 
5205   // Do this the hard way by blocking ...
5206   // TODO: consider a brief spin here, gated on the success of recent
5207   // spin attempts by this thread.
5208   while (_Event &lt; 0) {
5209     DWORD rv = ::WaitForSingleObject(_ParkHandle, INFINITE);
5210     assert(rv == WAIT_OBJECT_0, &quot;WaitForSingleObject failed&quot;);
5211   }
5212 
5213   // Usually we&#39;ll find _Event == 0 at this point, but as
5214   // an optional optimization we clear it, just in case can
5215   // multiple unpark() operations drove _Event up to 1.
5216   _Event = 0;
5217   OrderAccess::fence();
5218   guarantee(_Event &gt;= 0, &quot;invariant&quot;);
5219 }
5220 
5221 void os::PlatformEvent::unpark() {
5222   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5223 
5224   // Transitions for _Event:
5225   //    0 =&gt; 1 : just return
5226   //    1 =&gt; 1 : just return
5227   //   -1 =&gt; either 0 or 1; must signal target thread
5228   //         That is, we can safely transition _Event from -1 to either
5229   //         0 or 1.
5230   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
5231   //
5232   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
5233   // that it will take two back-to-back park() calls for the owning
5234   // thread to block. This has the benefit of forcing a spurious return
5235   // from the first park() call after an unpark() call which will help
5236   // shake out uses of park() and unpark() without condition variables.
5237 
5238   if (Atomic::xchg(&amp;_Event, 1) &gt;= 0) return;
5239 
5240   ::SetEvent(_ParkHandle);
5241 }
5242 
5243 
5244 // JSR166
5245 // -------------------------------------------------------
5246 
5247 // The Windows implementation of Park is very straightforward: Basic
5248 // operations on Win32 Events turn out to have the right semantics to
5249 // use them directly. We opportunistically resuse the event inherited
5250 // from Monitor.
5251 
5252 void Parker::park(bool isAbsolute, jlong time) {
5253   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5254   // First, demultiplex/decode time arguments
5255   if (time &lt; 0) { // don&#39;t wait
5256     return;
5257   } else if (time == 0 &amp;&amp; !isAbsolute) {
5258     time = INFINITE;
5259   } else if (isAbsolute) {
5260     time -= os::javaTimeMillis(); // convert to relative time
5261     if (time &lt;= 0) {  // already elapsed
5262       return;
5263     }
5264   } else { // relative
5265     time /= 1000000;  // Must coarsen from nanos to millis
5266     if (time == 0) {  // Wait for the minimal time unit if zero
5267       time = 1;
5268     }
5269   }
5270 
5271   JavaThread* thread = JavaThread::current();
5272 
5273   // Don&#39;t wait if interrupted or already triggered
5274   if (thread-&gt;is_interrupted(false) ||
5275       WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {
5276     ResetEvent(_ParkEvent);
5277     return;
5278   } else {
5279     ThreadBlockInVM tbivm(thread);
5280     OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
5281     thread-&gt;set_suspend_equivalent();
5282 
5283     WaitForSingleObject(_ParkEvent, time);
5284     ResetEvent(_ParkEvent);
5285 
5286     // If externally suspended while waiting, re-suspend
5287     if (thread-&gt;handle_special_suspend_equivalent_condition()) {
5288       thread-&gt;java_suspend_self();
5289     }
5290   }
5291 }
5292 
5293 void Parker::unpark() {
5294   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5295   SetEvent(_ParkEvent);
5296 }
5297 
5298 // Platform Monitor implementation
5299 
5300 // Must already be locked
5301 int os::PlatformMonitor::wait(jlong millis) {
5302   assert(millis &gt;= 0, &quot;negative timeout&quot;);
5303   int ret = OS_TIMEOUT;
5304   int status = SleepConditionVariableCS(&amp;_cond, &amp;_mutex,
5305                                         millis == 0 ? INFINITE : millis);
5306   if (status != 0) {
5307     ret = OS_OK;
5308   }
5309   #ifndef PRODUCT
5310   else {
5311     DWORD err = GetLastError();
5312     assert(err == ERROR_TIMEOUT, &quot;SleepConditionVariableCS: %ld:&quot;, err);
5313   }
5314   #endif
5315   return ret;
5316 }
5317 
5318 // Run the specified command in a separate process. Return its exit value,
5319 // or -1 on failure (e.g. can&#39;t create a new process).
5320 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
5321   STARTUPINFO si;
5322   PROCESS_INFORMATION pi;
5323   DWORD exit_code;
5324 
5325   char * cmd_string;
5326   const char * cmd_prefix = &quot;cmd /C &quot;;
5327   size_t len = strlen(cmd) + strlen(cmd_prefix) + 1;
5328   cmd_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtInternal);
5329   if (cmd_string == NULL) {
5330     return -1;
5331   }
5332   cmd_string[0] = &#39;\0&#39;;
5333   strcat(cmd_string, cmd_prefix);
5334   strcat(cmd_string, cmd);
5335 
5336   // now replace all &#39;\n&#39; with &#39;&amp;&#39;
5337   char * substring = cmd_string;
5338   while ((substring = strchr(substring, &#39;\n&#39;)) != NULL) {
5339     substring[0] = &#39;&amp;&#39;;
5340     substring++;
5341   }
5342   memset(&amp;si, 0, sizeof(si));
5343   si.cb = sizeof(si);
5344   memset(&amp;pi, 0, sizeof(pi));
5345   BOOL rslt = CreateProcess(NULL,   // executable name - use command line
5346                             cmd_string,    // command line
5347                             NULL,   // process security attribute
5348                             NULL,   // thread security attribute
5349                             TRUE,   // inherits system handles
5350                             0,      // no creation flags
5351                             NULL,   // use parent&#39;s environment block
5352                             NULL,   // use parent&#39;s starting directory
5353                             &amp;si,    // (in) startup information
5354                             &amp;pi);   // (out) process information
5355 
5356   if (rslt) {
5357     // Wait until child process exits.
5358     WaitForSingleObject(pi.hProcess, INFINITE);
5359 
5360     GetExitCodeProcess(pi.hProcess, &amp;exit_code);
5361 
5362     // Close process and thread handles.
5363     CloseHandle(pi.hProcess);
5364     CloseHandle(pi.hThread);
5365   } else {
5366     exit_code = -1;
5367   }
5368 
5369   FREE_C_HEAP_ARRAY(char, cmd_string);
5370   return (int)exit_code;
5371 }
5372 
5373 bool os::find(address addr, outputStream* st) {
5374   int offset = -1;
5375   bool result = false;
5376   char buf[256];
5377   if (os::dll_address_to_library_name(addr, buf, sizeof(buf), &amp;offset)) {
5378     st-&gt;print(PTR_FORMAT &quot; &quot;, addr);
5379     if (strlen(buf) &lt; sizeof(buf) - 1) {
5380       char* p = strrchr(buf, &#39;\\&#39;);
5381       if (p) {
5382         st-&gt;print(&quot;%s&quot;, p + 1);
5383       } else {
5384         st-&gt;print(&quot;%s&quot;, buf);
5385       }
5386     } else {
5387         // The library name is probably truncated. Let&#39;s omit the library name.
5388         // See also JDK-8147512.
5389     }
5390     if (os::dll_address_to_function_name(addr, buf, sizeof(buf), &amp;offset)) {
5391       st-&gt;print(&quot;::%s + 0x%x&quot;, buf, offset);
5392     }
5393     st-&gt;cr();
5394     result = true;
5395   }
5396   return result;
5397 }
5398 
5399 static jint initSock() {
5400   WSADATA wsadata;
5401 
5402   if (WSAStartup(MAKEWORD(2,2), &amp;wsadata) != 0) {
5403     jio_fprintf(stderr, &quot;Could not initialize Winsock (error: %d)\n&quot;,
5404                 ::GetLastError());
5405     return JNI_ERR;
5406   }
5407   return JNI_OK;
5408 }
5409 
5410 struct hostent* os::get_host_by_name(char* name) {
5411   return (struct hostent*)gethostbyname(name);
5412 }
5413 
5414 int os::socket_close(int fd) {
5415   return ::closesocket(fd);
5416 }
5417 
5418 int os::socket(int domain, int type, int protocol) {
5419   return ::socket(domain, type, protocol);
5420 }
5421 
5422 int os::connect(int fd, struct sockaddr* him, socklen_t len) {
5423   return ::connect(fd, him, len);
5424 }
5425 
5426 int os::recv(int fd, char* buf, size_t nBytes, uint flags) {
5427   return ::recv(fd, buf, (int)nBytes, flags);
5428 }
5429 
5430 int os::send(int fd, char* buf, size_t nBytes, uint flags) {
5431   return ::send(fd, buf, (int)nBytes, flags);
5432 }
5433 
5434 int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {
5435   return ::send(fd, buf, (int)nBytes, flags);
5436 }
5437 
5438 // WINDOWS CONTEXT Flags for THREAD_SAMPLING
5439 #if defined(IA32)
5440   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS)
<a name="43" id="anc43"></a><span class="line-modified">5441 #elif defined(AMD64) || defined(_M_ARM64)</span>
5442   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
5443 #endif
5444 
5445 // returns true if thread could be suspended,
5446 // false otherwise
5447 static bool do_suspend(HANDLE* h) {
5448   if (h != NULL) {
5449     if (SuspendThread(*h) != ~0) {
5450       return true;
5451     }
5452   }
5453   return false;
5454 }
5455 
5456 // resume the thread
5457 // calling resume on an active thread is a no-op
5458 static void do_resume(HANDLE* h) {
5459   if (h != NULL) {
5460     ResumeThread(*h);
5461   }
5462 }
5463 
5464 // retrieve a suspend/resume context capable handle
5465 // from the tid. Caller validates handle return value.
5466 void get_thread_handle_for_extended_context(HANDLE* h,
5467                                             OSThread::thread_id_t tid) {
5468   if (h != NULL) {
5469     *h = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);
5470   }
5471 }
5472 
5473 // Thread sampling implementation
5474 //
5475 void os::SuspendedThreadTask::internal_do_task() {
5476   CONTEXT    ctxt;
5477   HANDLE     h = NULL;
5478 
5479   // get context capable handle for thread
5480   get_thread_handle_for_extended_context(&amp;h, _thread-&gt;osthread()-&gt;thread_id());
5481 
5482   // sanity
5483   if (h == NULL || h == INVALID_HANDLE_VALUE) {
5484     return;
5485   }
5486 
5487   // suspend the thread
5488   if (do_suspend(&amp;h)) {
5489     ctxt.ContextFlags = sampling_context_flags;
5490     // get thread context
5491     GetThreadContext(h, &amp;ctxt);
5492     SuspendedThreadTaskContext context(_thread, &amp;ctxt);
5493     // pass context to Thread Sampling impl
5494     do_task(context);
5495     // resume thread
5496     do_resume(&amp;h);
5497   }
5498 
5499   // close handle
5500   CloseHandle(h);
5501 }
5502 
5503 bool os::start_debugging(char *buf, int buflen) {
5504   int len = (int)strlen(buf);
5505   char *p = &amp;buf[len];
5506 
5507   jio_snprintf(p, buflen-len,
5508              &quot;\n\n&quot;
5509              &quot;Do you want to debug the problem?\n\n&quot;
5510              &quot;To debug, attach Visual Studio to process %d; then switch to thread 0x%x\n&quot;
5511              &quot;Select &#39;Yes&#39; to launch Visual Studio automatically (PATH must include msdev)\n&quot;
5512              &quot;Otherwise, select &#39;No&#39; to abort...&quot;,
5513              os::current_process_id(), os::current_thread_id());
5514 
5515   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
5516 
5517   if (yes) {
5518     // os::breakpoint() calls DebugBreak(), which causes a breakpoint
5519     // exception. If VM is running inside a debugger, the debugger will
5520     // catch the exception. Otherwise, the breakpoint exception will reach
5521     // the default windows exception handler, which can spawn a debugger and
5522     // automatically attach to the dying VM.
5523     os::breakpoint();
5524     yes = false;
5525   }
5526   return yes;
5527 }
5528 
5529 void* os::get_default_process_handle() {
5530   return (void*)GetModuleHandle(NULL);
5531 }
5532 
5533 // Builds a platform dependent Agent_OnLoad_&lt;lib_name&gt; function name
5534 // which is used to find statically linked in agents.
5535 // Additionally for windows, takes into account __stdcall names.
5536 // Parameters:
5537 //            sym_name: Symbol in library we are looking for
5538 //            lib_name: Name of library to look in, NULL for shared libs.
5539 //            is_absolute_path == true if lib_name is absolute path to agent
5540 //                                     such as &quot;C:/a/b/L.dll&quot;
5541 //            == false if only the base name of the library is passed in
5542 //               such as &quot;L&quot;
5543 char* os::build_agent_function_name(const char *sym_name, const char *lib_name,
5544                                     bool is_absolute_path) {
5545   char *agent_entry_name;
5546   size_t len;
5547   size_t name_len;
5548   size_t prefix_len = strlen(JNI_LIB_PREFIX);
5549   size_t suffix_len = strlen(JNI_LIB_SUFFIX);
5550   const char *start;
5551 
5552   if (lib_name != NULL) {
5553     len = name_len = strlen(lib_name);
5554     if (is_absolute_path) {
5555       // Need to strip path, prefix and suffix
5556       if ((start = strrchr(lib_name, *os::file_separator())) != NULL) {
5557         lib_name = ++start;
5558       } else {
5559         // Need to check for drive prefix
5560         if ((start = strchr(lib_name, &#39;:&#39;)) != NULL) {
5561           lib_name = ++start;
5562         }
5563       }
5564       if (len &lt;= (prefix_len + suffix_len)) {
5565         return NULL;
5566       }
5567       lib_name += prefix_len;
5568       name_len = strlen(lib_name) - suffix_len;
5569     }
5570   }
5571   len = (lib_name != NULL ? name_len : 0) + strlen(sym_name) + 2;
5572   agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);
5573   if (agent_entry_name == NULL) {
5574     return NULL;
5575   }
5576   if (lib_name != NULL) {
5577     const char *p = strrchr(sym_name, &#39;@&#39;);
5578     if (p != NULL &amp;&amp; p != sym_name) {
5579       // sym_name == _Agent_OnLoad@XX
5580       strncpy(agent_entry_name, sym_name, (p - sym_name));
5581       agent_entry_name[(p-sym_name)] = &#39;\0&#39;;
5582       // agent_entry_name == _Agent_OnLoad
5583       strcat(agent_entry_name, &quot;_&quot;);
5584       strncat(agent_entry_name, lib_name, name_len);
5585       strcat(agent_entry_name, p);
5586       // agent_entry_name == _Agent_OnLoad_lib_name@XX
5587     } else {
5588       strcpy(agent_entry_name, sym_name);
5589       strcat(agent_entry_name, &quot;_&quot;);
5590       strncat(agent_entry_name, lib_name, name_len);
5591     }
5592   } else {
5593     strcpy(agent_entry_name, sym_name);
5594   }
5595   return agent_entry_name;
5596 }
5597 
5598 #ifndef PRODUCT
5599 
5600 // test the code path in reserve_memory_special() that tries to allocate memory in a single
5601 // contiguous memory block at a particular address.
5602 // The test first tries to find a good approximate address to allocate at by using the same
5603 // method to allocate some memory at any address. The test then tries to allocate memory in
5604 // the vicinity (not directly after it to avoid possible by-chance use of that location)
5605 // This is of course only some dodgy assumption, there is no guarantee that the vicinity of
5606 // the previously allocated memory is available for allocation. The only actual failure
5607 // that is reported is when the test tries to allocate at a particular location but gets a
5608 // different valid one. A NULL return value at this point is not considered an error but may
5609 // be legitimate.
5610 void TestReserveMemorySpecial_test() {
5611   if (!UseLargePages) {
5612     return;
5613   }
5614   // save current value of globals
5615   bool old_use_large_pages_individual_allocation = UseLargePagesIndividualAllocation;
5616   bool old_use_numa_interleaving = UseNUMAInterleaving;
5617 
5618   // set globals to make sure we hit the correct code path
5619   UseLargePagesIndividualAllocation = UseNUMAInterleaving = false;
5620 
5621   // do an allocation at an address selected by the OS to get a good one.
5622   const size_t large_allocation_size = os::large_page_size() * 4;
5623   char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), NULL, false);
5624   if (result == NULL) {
5625   } else {
5626     os::release_memory_special(result, large_allocation_size);
5627 
5628     // allocate another page within the recently allocated memory area which seems to be a good location. At least
5629     // we managed to get it once.
5630     const size_t expected_allocation_size = os::large_page_size();
5631     char* expected_location = result + os::large_page_size();
5632     char* actual_location = os::reserve_memory_special(expected_allocation_size, os::large_page_size(), expected_location, false);
5633     if (actual_location == NULL) {
5634     } else {
5635       // release memory
5636       os::release_memory_special(actual_location, expected_allocation_size);
5637       // only now check, after releasing any memory to avoid any leaks.
5638       assert(actual_location == expected_location,
5639              &quot;Failed to allocate memory at requested location &quot; PTR_FORMAT &quot; of size &quot; SIZE_FORMAT &quot;, is &quot; PTR_FORMAT &quot; instead&quot;,
5640              expected_location, expected_allocation_size, actual_location);
5641     }
5642   }
5643 
5644   // restore globals
5645   UseLargePagesIndividualAllocation = old_use_large_pages_individual_allocation;
5646   UseNUMAInterleaving = old_use_numa_interleaving;
5647 }
5648 #endif // PRODUCT
5649 
5650 /*
5651   All the defined signal names for Windows.
5652 
5653   NOTE that not all of these names are accepted by FindSignal!
5654 
5655   For various reasons some of these may be rejected at runtime.
5656 
5657   Here are the names currently accepted by a user of sun.misc.Signal with
5658   1.4.1 (ignoring potential interaction with use of chaining, etc):
5659 
5660      (LIST TBD)
5661 
5662 */
5663 int os::get_signal_number(const char* name) {
5664   static const struct {
5665     const char* name;
5666     int         number;
5667   } siglabels [] =
5668     // derived from version 6.0 VC98/include/signal.h
5669   {&quot;ABRT&quot;,      SIGABRT,        // abnormal termination triggered by abort cl
5670   &quot;FPE&quot;,        SIGFPE,         // floating point exception
5671   &quot;SEGV&quot;,       SIGSEGV,        // segment violation
5672   &quot;INT&quot;,        SIGINT,         // interrupt
5673   &quot;TERM&quot;,       SIGTERM,        // software term signal from kill
5674   &quot;BREAK&quot;,      SIGBREAK,       // Ctrl-Break sequence
5675   &quot;ILL&quot;,        SIGILL};        // illegal instruction
5676   for (unsigned i = 0; i &lt; ARRAY_SIZE(siglabels); ++i) {
5677     if (strcmp(name, siglabels[i].name) == 0) {
5678       return siglabels[i].number;
5679     }
5680   }
5681   return -1;
5682 }
5683 
5684 // Fast current thread access
5685 
5686 int os::win32::_thread_ptr_offset = 0;
5687 
5688 static void call_wrapper_dummy() {}
5689 
5690 // We need to call the os_exception_wrapper once so that it sets
5691 // up the offset from FS of the thread pointer.
5692 void os::win32::initialize_thread_ptr_offset() {
5693   os::os_exception_wrapper((java_call_t)call_wrapper_dummy,
5694                            NULL, methodHandle(), NULL, NULL);
5695 }
5696 
5697 bool os::supports_map_sync() {
5698   return false;
5699 }
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>