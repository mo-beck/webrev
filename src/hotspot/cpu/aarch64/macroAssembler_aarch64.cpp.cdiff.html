<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src\hotspot\cpu\aarch64\macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="..\..\..\..\style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="..\..\..\..\index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src\hotspot\cpu\aarch64\macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 69,12 ***</span>
  
  // Patch any kind of instruction; there may be several instructions.
  // Return the total length (in bytes) of the instructions.
  int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
    int instructions = 1;
<span class="line-modified">!   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);</span>
<span class="line-modified">!   long offset = (target - branch) &gt;&gt; 2;</span>
    unsigned insn = *(unsigned*)branch;
    if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
      // Load register (literal)
      Instruction_aarch64::spatch(branch, 23, 5, offset);
    } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
<span class="line-new-header">--- 69,12 ---</span>
  
  // Patch any kind of instruction; there may be several instructions.
  // Return the total length (in bytes) of the instructions.
  int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
    int instructions = 1;
<span class="line-modified">!   assert((uint64_t)target &lt; ((uint64_t)1 &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);</span>
<span class="line-modified">!   int64_t offset = (target - branch) &gt;&gt; 2;</span>
    unsigned insn = *(unsigned*)branch;
    if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
      // Load register (literal)
      Instruction_aarch64::spatch(branch, 23, 5, offset);
    } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,11 ***</span>
    } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
      // PC-rel. addressing
      offset = target-branch;
      int shift = Instruction_aarch64::extract(insn, 31, 31);
      if (shift) {
<span class="line-modified">!       u_int64_t dest = (u_int64_t)target;</span>
        uint64_t pc_page = (uint64_t)branch &gt;&gt; 12;
        uint64_t adr_page = (uint64_t)target &gt;&gt; 12;
        unsigned offset_lo = dest &amp; 0xfff;
        offset = adr_page - pc_page;
  
<span class="line-new-header">--- 92,11 ---</span>
    } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
      // PC-rel. addressing
      offset = target-branch;
      int shift = Instruction_aarch64::extract(insn, 31, 31);
      if (shift) {
<span class="line-modified">!       uint64_t dest = (uint64_t)target;</span>
        uint64_t pc_page = (uint64_t)branch &gt;&gt; 12;
        uint64_t adr_page = (uint64_t)target &gt;&gt; 12;
        unsigned offset_lo = dest &amp; 0xfff;
        offset = adr_page - pc_page;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,23 ***</span>
        } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &amp;&amp;
                     Instruction_aarch64::extract(insn, 4, 0) ==
                       Instruction_aarch64::extract(insn2, 4, 0)) {
          // movk #imm16&lt;&lt;32
          Instruction_aarch64::patch(branch + 4, 20, 5, (uint64_t)target &gt;&gt; 32);
<span class="line-modified">!         long dest = ((long)target &amp; 0xffffffffL) | ((long)branch &amp; 0xffff00000000L);</span>
<span class="line-modified">!         long pc_page = (long)branch &gt;&gt; 12;</span>
<span class="line-modified">!         long adr_page = (long)dest &gt;&gt; 12;</span>
          offset = adr_page - pc_page;
          instructions = 2;
        }
      }
      int offset_lo = offset &amp; 3;
      offset &gt;&gt;= 2;
      Instruction_aarch64::spatch(branch, 23, 5, offset);
      Instruction_aarch64::patch(branch, 30, 29, offset_lo);
    } else if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100) {
<span class="line-modified">!     u_int64_t dest = (u_int64_t)target;</span>
      // Move wide constant
      assert(nativeInstruction_at(branch+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
      assert(nativeInstruction_at(branch+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
      Instruction_aarch64::patch(branch, 20, 5, dest &amp; 0xffff);
      Instruction_aarch64::patch(branch+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
<span class="line-new-header">--- 133,23 ---</span>
        } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &amp;&amp;
                     Instruction_aarch64::extract(insn, 4, 0) ==
                       Instruction_aarch64::extract(insn2, 4, 0)) {
          // movk #imm16&lt;&lt;32
          Instruction_aarch64::patch(branch + 4, 20, 5, (uint64_t)target &gt;&gt; 32);
<span class="line-modified">!         int64_t dest = ((int64_t)target &amp; 0xffffffffL) | ((int64_t)branch &amp; 0xffff00000000L);</span>
<span class="line-modified">!         int64_t pc_page = (int64_t)branch &gt;&gt; 12;</span>
<span class="line-modified">!         int64_t adr_page = (int64_t)dest &gt;&gt; 12;</span>
          offset = adr_page - pc_page;
          instructions = 2;
        }
      }
      int offset_lo = offset &amp; 3;
      offset &gt;&gt;= 2;
      Instruction_aarch64::spatch(branch, 23, 5, offset);
      Instruction_aarch64::patch(branch, 30, 29, offset_lo);
    } else if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100) {
<span class="line-modified">!     uint64_t dest = (uint64_t)target;</span>
      // Move wide constant
      assert(nativeInstruction_at(branch+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
      assert(nativeInstruction_at(branch+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
      Instruction_aarch64::patch(branch, 20, 5, dest &amp; 0xffff);
      Instruction_aarch64::patch(branch+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,11 ***</span>
    Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
    return 2 * NativeInstruction::instruction_size;
  }
  
  address MacroAssembler::target_addr_for_insn(address insn_addr, unsigned insn) {
<span class="line-modified">!   long offset = 0;</span>
    if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b011011) == 0b00011000) {
      // Load register (literal)
      offset = Instruction_aarch64::sextract(insn, 23, 5);
      return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
    } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
<span class="line-new-header">--- 204,11 ---</span>
    Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
    return 2 * NativeInstruction::instruction_size;
  }
  
  address MacroAssembler::target_addr_for_insn(address insn_addr, unsigned insn) {
<span class="line-modified">!   int64_t offset = 0;</span>
    if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b011011) == 0b00011000) {
      // Load register (literal)
      offset = Instruction_aarch64::sextract(insn, 23, 5);
      return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
    } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,17 ***</span>
        }
      } else {
        ShouldNotReachHere();
      }
    } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
<span class="line-modified">!     u_int32_t *insns = (u_int32_t *)insn_addr;</span>
      // Move wide constant: movz, movk, movk.  See movptr().
      assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
      assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
<span class="line-modified">!     return address(u_int64_t(Instruction_aarch64::extract(insns[0], 20, 5))</span>
<span class="line-modified">!                    + (u_int64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)</span>
<span class="line-modified">!                    + (u_int64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));</span>
    } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
               Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
      return 0;
    } else {
      ShouldNotReachHere();
<span class="line-new-header">--- 271,17 ---</span>
        }
      } else {
        ShouldNotReachHere();
      }
    } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
<span class="line-modified">!     uint32_t *insns = (uint32_t *)insn_addr;</span>
      // Move wide constant: movz, movk, movk.  See movptr().
      assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
      assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
<span class="line-modified">!     return address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))</span>
<span class="line-modified">!                    + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)</span>
<span class="line-modified">!                    + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));</span>
    } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
               Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
      return 0;
    } else {
      ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,11 ***</span>
  void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
    if (SafepointMechanism::uses_thread_local_poll()) {
      ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));
      tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
    } else {
<span class="line-modified">!     unsigned long offset;</span>
      adrp(rscratch1, ExternalAddress(SafepointSynchronize::address_of_state()), offset);
      ldrw(rscratch1, Address(rscratch1, offset));
      assert(SafepointSynchronize::_not_synchronized == 0, &quot;rewrite this code&quot;);
      cbnz(rscratch1, slow_path);
    }
<span class="line-new-header">--- 292,11 ---</span>
  void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
    if (SafepointMechanism::uses_thread_local_poll()) {
      ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));
      tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
    } else {
<span class="line-modified">!     uint64_t offset;</span>
      adrp(rscratch1, ExternalAddress(SafepointSynchronize::address_of_state()), offset);
      ldrw(rscratch1, Address(rscratch1, offset));
      assert(SafepointSynchronize::_not_synchronized == 0, &quot;rewrite this code&quot;);
      cbnz(rscratch1, slow_path);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 400,11 ***</span>
  void MacroAssembler::far_call(Address entry, CodeBuffer *cbuf, Register tmp) {
    assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
    assert(CodeCache::find_blob(entry.target()) != NULL,
           &quot;destination of far call not found in code cache&quot;);
    if (far_branches()) {
<span class="line-modified">!     unsigned long offset;</span>
      // We can use ADRP here because we know that the total size of
      // the code cache cannot exceed 2Gb.
      adrp(tmp, entry, offset);
      add(tmp, tmp, offset);
      if (cbuf) cbuf-&gt;set_insts_mark();
<span class="line-new-header">--- 400,11 ---</span>
  void MacroAssembler::far_call(Address entry, CodeBuffer *cbuf, Register tmp) {
    assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
    assert(CodeCache::find_blob(entry.target()) != NULL,
           &quot;destination of far call not found in code cache&quot;);
    if (far_branches()) {
<span class="line-modified">!     uint64_t offset;</span>
      // We can use ADRP here because we know that the total size of
      // the code cache cannot exceed 2Gb.
      adrp(tmp, entry, offset);
      add(tmp, tmp, offset);
      if (cbuf) cbuf-&gt;set_insts_mark();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 418,11 ***</span>
  void MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {
    assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
    assert(CodeCache::find_blob(entry.target()) != NULL,
           &quot;destination of far call not found in code cache&quot;);
    if (far_branches()) {
<span class="line-modified">!     unsigned long offset;</span>
      // We can use ADRP here because we know that the total size of
      // the code cache cannot exceed 2Gb.
      adrp(tmp, entry, offset);
      add(tmp, tmp, offset);
      if (cbuf) cbuf-&gt;set_insts_mark();
<span class="line-new-header">--- 418,11 ---</span>
  void MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {
    assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
    assert(CodeCache::find_blob(entry.target()) != NULL,
           &quot;destination of far call not found in code cache&quot;);
    if (far_branches()) {
<span class="line-modified">!     uint64_t offset;</span>
      // We can use ADRP here because we know that the total size of
      // the code cache cannot exceed 2Gb.
      adrp(tmp, entry, offset);
      add(tmp, tmp, offset);
      if (cbuf) cbuf-&gt;set_insts_mark();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1400,12 ***</span>
  #ifdef ASSERT
    int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
    assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
  #endif
    if (arg_slot.is_constant()) {
<span class="line-modified">!     return Address(esp, arg_slot.as_constant() * stackElementSize</span>
<span class="line-modified">!                    + offset);</span>
    } else {
      add(rscratch1, esp, arg_slot.as_register(),
          ext::uxtx, exact_log2(stackElementSize));
      return Address(rscratch1, offset);
    }
<span class="line-new-header">--- 1400,12 ---</span>
  #ifdef ASSERT
    int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
    assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
  #endif
    if (arg_slot.is_constant()) {
<span class="line-modified">!     int calc_offset = arg_slot.as_constant() * stackElementSize + offset;</span>
<span class="line-modified">!     return Address(esp, calc_offset);</span>
    } else {
      add(rscratch1, esp, arg_slot.as_register(),
          ext::uxtx, exact_log2(stackElementSize));
      return Address(rscratch1, offset);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1502,11 ***</span>
  // MacroAssembler protected routines needed to implement
  // public methods
  
  void MacroAssembler::mov(Register r, Address dest) {
    code_section()-&gt;relocate(pc(), dest.rspec());
<span class="line-modified">!   u_int64_t imm64 = (u_int64_t)dest.target();</span>
    movptr(r, imm64);
  }
  
  // Move a constant pointer into r.  In AArch64 mode the virtual
  // address space is 48 bits in size, so we only need three
<span class="line-new-header">--- 1502,11 ---</span>
  // MacroAssembler protected routines needed to implement
  // public methods
  
  void MacroAssembler::mov(Register r, Address dest) {
    code_section()-&gt;relocate(pc(), dest.rspec());
<span class="line-modified">!   uint64_t imm64 = (uint64_t)dest.target();</span>
    movptr(r, imm64);
  }
  
  // Move a constant pointer into r.  In AArch64 mode the virtual
  // address space is 48 bits in size, so we only need three
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1518,11 ***</span>
      char buffer[64];
      snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
      block_comment(buffer);
    }
  #endif
<span class="line-modified">!   assert(imm64 &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);</span>
    movz(r, imm64 &amp; 0xffff);
    imm64 &gt;&gt;= 16;
    movk(r, imm64 &amp; 0xffff, 16);
    imm64 &gt;&gt;= 16;
    movk(r, imm64 &amp; 0xffff, 32);
<span class="line-new-header">--- 1518,11 ---</span>
      char buffer[64];
      snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
      block_comment(buffer);
    }
  #endif
<span class="line-modified">!   assert(imm64 &lt; (1ull &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);</span>
    movz(r, imm64 &amp; 0xffff);
    imm64 &gt;&gt;= 16;
    movk(r, imm64 &amp; 0xffff, 16);
    imm64 &gt;&gt;= 16;
    movk(r, imm64 &amp; 0xffff, 32);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1535,24 ***</span>
  //   imm32 == hex 0000efgh  T4H:  Vd = efghefghefghefgh
  //   imm32 == hex 0000efgh  T8H:  Vd = efghefghefghefghefghefghefghefgh
  //   imm32 == hex abcdefgh  T2S:  Vd = abcdefghabcdefgh
  //   imm32 == hex abcdefgh  T4S:  Vd = abcdefghabcdefghabcdefghabcdefgh
  //   T1D/T2D: invalid
<span class="line-modified">! void MacroAssembler::mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32) {</span>
    assert(T != T1D &amp;&amp; T != T2D, &quot;invalid arrangement&quot;);
    if (T == T8B || T == T16B) {
      assert((imm32 &amp; ~0xff) == 0, &quot;extraneous bits in unsigned imm32 (T8B/T16B)&quot;);
      movi(Vd, T, imm32 &amp; 0xff, 0);
      return;
    }
<span class="line-modified">!   u_int32_t nimm32 = ~imm32;</span>
    if (T == T4H || T == T8H) {
      assert((imm32  &amp; ~0xffff) == 0, &quot;extraneous bits in unsigned imm32 (T4H/T8H)&quot;);
      imm32 &amp;= 0xffff;
      nimm32 &amp;= 0xffff;
    }
<span class="line-modified">!   u_int32_t x = imm32;</span>
    int movi_cnt = 0;
    int movn_cnt = 0;
    while (x) { if (x &amp; 0xff) movi_cnt++; x &gt;&gt;= 8; }
    x = nimm32;
    while (x) { if (x &amp; 0xff) movn_cnt++; x &gt;&gt;= 8; }
<span class="line-new-header">--- 1535,24 ---</span>
  //   imm32 == hex 0000efgh  T4H:  Vd = efghefghefghefgh
  //   imm32 == hex 0000efgh  T8H:  Vd = efghefghefghefghefghefghefghefgh
  //   imm32 == hex abcdefgh  T2S:  Vd = abcdefghabcdefgh
  //   imm32 == hex abcdefgh  T4S:  Vd = abcdefghabcdefghabcdefghabcdefgh
  //   T1D/T2D: invalid
<span class="line-modified">! void MacroAssembler::mov(FloatRegister Vd, SIMD_Arrangement T, uint32_t imm32) {</span>
    assert(T != T1D &amp;&amp; T != T2D, &quot;invalid arrangement&quot;);
    if (T == T8B || T == T16B) {
      assert((imm32 &amp; ~0xff) == 0, &quot;extraneous bits in unsigned imm32 (T8B/T16B)&quot;);
      movi(Vd, T, imm32 &amp; 0xff, 0);
      return;
    }
<span class="line-modified">!   uint32_t nimm32 = ~imm32;</span>
    if (T == T4H || T == T8H) {
      assert((imm32  &amp; ~0xffff) == 0, &quot;extraneous bits in unsigned imm32 (T4H/T8H)&quot;);
      imm32 &amp;= 0xffff;
      nimm32 &amp;= 0xffff;
    }
<span class="line-modified">!   uint32_t x = imm32;</span>
    int movi_cnt = 0;
    int movn_cnt = 0;
    while (x) { if (x &amp; 0xff) movi_cnt++; x &gt;&gt;= 8; }
    x = nimm32;
    while (x) { if (x &amp; 0xff) movn_cnt++; x &gt;&gt;= 8; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1572,11 ***</span>
        orri(Vd, T, imm32 &amp; 0xff, lsl);
      lsl += 8; imm32 &gt;&gt;= 8;
    }
  }
  
<span class="line-modified">! void MacroAssembler::mov_immediate64(Register dst, u_int64_t imm64)</span>
  {
  #ifndef PRODUCT
    {
      char buffer[64];
      snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
<span class="line-new-header">--- 1572,11 ---</span>
        orri(Vd, T, imm32 &amp; 0xff, lsl);
      lsl += 8; imm32 &gt;&gt;= 8;
    }
  }
  
<span class="line-modified">! void MacroAssembler::mov_immediate64(Register dst, uint64_t imm64)</span>
  {
  #ifndef PRODUCT
    {
      char buffer[64];
      snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1586,11 ***</span>
    if (operand_valid_for_logical_immediate(false, imm64)) {
      orr(dst, zr, imm64);
    } else {
      // we can use a combination of MOVZ or MOVN with
      // MOVK to build up the constant
<span class="line-modified">!     u_int64_t imm_h[4];</span>
      int zero_count = 0;
      int neg_count = 0;
      int i;
      for (i = 0; i &lt; 4; i++) {
        imm_h[i] = ((imm64 &gt;&gt; (i * 16)) &amp; 0xffffL);
<span class="line-new-header">--- 1586,11 ---</span>
    if (operand_valid_for_logical_immediate(false, imm64)) {
      orr(dst, zr, imm64);
    } else {
      // we can use a combination of MOVZ or MOVN with
      // MOVK to build up the constant
<span class="line-modified">!     uint64_t imm_h[4];</span>
      int zero_count = 0;
      int neg_count = 0;
      int i;
      for (i = 0; i &lt; 4; i++) {
        imm_h[i] = ((imm64 &gt;&gt; (i * 16)) &amp; 0xffffL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1607,89 ***</span>
        // one MOVN will do
        movn(dst, 0);
      } else if (zero_count == 3) {
        for (i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0L) {
<span class="line-modified">!           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));</span>
            break;
          }
        }
      } else if (neg_count == 3) {
        // one MOVN will do
        for (int i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));</span>
            break;
          }
        }
      } else if (zero_count == 2) {
        // one MOVZ and one MOVK will do
        for (i = 0; i &lt; 3; i++) {
          if (imm_h[i] != 0L) {
<span class="line-modified">!           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));</span>
            i++;
            break;
          }
        }
        for (;i &lt; 4; i++) {
          if (imm_h[i] != 0L) {
<span class="line-modified">!           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));</span>
          }
        }
      } else if (neg_count == 2) {
        // one MOVN and one MOVK will do
        for (i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));</span>
            i++;
            break;
          }
        }
        for (;i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));</span>
          }
        }
      } else if (zero_count == 1) {
        // one MOVZ and two MOVKs will do
        for (i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0L) {
<span class="line-modified">!           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));</span>
            i++;
            break;
          }
        }
        for (;i &lt; 4; i++) {
          if (imm_h[i] != 0x0L) {
<span class="line-modified">!           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));</span>
          }
        }
      } else if (neg_count == 1) {
        // one MOVN and two MOVKs will do
        for (i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));</span>
            i++;
            break;
          }
        }
        for (;i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));</span>
          }
        }
      } else {
        // use a MOVZ and 3 MOVKs (makes it easier to debug)
<span class="line-modified">!       movz(dst, (u_int32_t)imm_h[0], 0);</span>
        for (i = 1; i &lt; 4; i++) {
<span class="line-modified">!         movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));</span>
        }
      }
    }
  }
  
<span class="line-modified">! void MacroAssembler::mov_immediate32(Register dst, u_int32_t imm32)</span>
  {
  #ifndef PRODUCT
      {
        char buffer[64];
        snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX32, imm32);
<span class="line-new-header">--- 1607,89 ---</span>
        // one MOVN will do
        movn(dst, 0);
      } else if (zero_count == 3) {
        for (i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0L) {
<span class="line-modified">!           movz(dst, (uint32_t)imm_h[i], (i &lt;&lt; 4));</span>
            break;
          }
        }
      } else if (neg_count == 3) {
        // one MOVN will do
        for (int i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movn(dst, (uint32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));</span>
            break;
          }
        }
      } else if (zero_count == 2) {
        // one MOVZ and one MOVK will do
        for (i = 0; i &lt; 3; i++) {
          if (imm_h[i] != 0L) {
<span class="line-modified">!           movz(dst, (uint32_t)imm_h[i], (i &lt;&lt; 4));</span>
            i++;
            break;
          }
        }
        for (;i &lt; 4; i++) {
          if (imm_h[i] != 0L) {
<span class="line-modified">!           movk(dst, (uint32_t)imm_h[i], (i &lt;&lt; 4));</span>
          }
        }
      } else if (neg_count == 2) {
        // one MOVN and one MOVK will do
        for (i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movn(dst, (uint32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));</span>
            i++;
            break;
          }
        }
        for (;i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movk(dst, (uint32_t)imm_h[i], (i &lt;&lt; 4));</span>
          }
        }
      } else if (zero_count == 1) {
        // one MOVZ and two MOVKs will do
        for (i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0L) {
<span class="line-modified">!           movz(dst, (uint32_t)imm_h[i], (i &lt;&lt; 4));</span>
            i++;
            break;
          }
        }
        for (;i &lt; 4; i++) {
          if (imm_h[i] != 0x0L) {
<span class="line-modified">!           movk(dst, (uint32_t)imm_h[i], (i &lt;&lt; 4));</span>
          }
        }
      } else if (neg_count == 1) {
        // one MOVN and two MOVKs will do
        for (i = 0; i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movn(dst, (uint32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));</span>
            i++;
            break;
          }
        }
        for (;i &lt; 4; i++) {
          if (imm_h[i] != 0xffffL) {
<span class="line-modified">!           movk(dst, (uint32_t)imm_h[i], (i &lt;&lt; 4));</span>
          }
        }
      } else {
        // use a MOVZ and 3 MOVKs (makes it easier to debug)
<span class="line-modified">!       movz(dst, (uint32_t)imm_h[0], 0);</span>
        for (i = 1; i &lt; 4; i++) {
<span class="line-modified">!         movk(dst, (uint32_t)imm_h[i], (i &lt;&lt; 4));</span>
        }
      }
    }
  }
  
<span class="line-modified">! void MacroAssembler::mov_immediate32(Register dst, uint32_t imm32)</span>
  {
  #ifndef PRODUCT
      {
        char buffer[64];
        snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX32, imm32);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1699,11 ***</span>
    if (operand_valid_for_logical_immediate(true, imm32)) {
      orrw(dst, zr, imm32);
    } else {
      // we can use MOVZ, MOVN or two calls to MOVK to build up the
      // constant
<span class="line-modified">!     u_int32_t imm_h[2];</span>
      imm_h[0] = imm32 &amp; 0xffff;
      imm_h[1] = ((imm32 &gt;&gt; 16) &amp; 0xffff);
      if (imm_h[0] == 0) {
        movzw(dst, imm_h[1], 16);
      } else if (imm_h[0] == 0xffff) {
<span class="line-new-header">--- 1699,11 ---</span>
    if (operand_valid_for_logical_immediate(true, imm32)) {
      orrw(dst, zr, imm32);
    } else {
      // we can use MOVZ, MOVN or two calls to MOVK to build up the
      // constant
<span class="line-modified">!     uint32_t imm_h[2];</span>
      imm_h[0] = imm32 &amp; 0xffff;
      imm_h[1] = ((imm32 &gt;&gt; 16) &amp; 0xffff);
      if (imm_h[0] == 0) {
        movzw(dst, imm_h[1], 16);
      } else if (imm_h[0] == 0xffff) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1722,11 ***</span>
  
  // Form an address from base + offset in Rd.  Rd may or may
  // not actually be used: you must use the Address that is returned.
  // It is up to you to ensure that the shift provided matches the size
  // of your data.
<span class="line-modified">! Address MacroAssembler::form_address(Register Rd, Register base, long byte_offset, int shift) {</span>
    if (Address::offset_ok_for_immed(byte_offset, shift))
      // It fits; no need for any heroics
      return Address(base, byte_offset);
  
    // Don&#39;t do anything clever with negative or misaligned offsets
<span class="line-new-header">--- 1722,11 ---</span>
  
  // Form an address from base + offset in Rd.  Rd may or may
  // not actually be used: you must use the Address that is returned.
  // It is up to you to ensure that the shift provided matches the size
  // of your data.
<span class="line-modified">! Address MacroAssembler::form_address(Register Rd, Register base, int64_t byte_offset, int shift) {</span>
    if (Address::offset_ok_for_immed(byte_offset, shift))
      // It fits; no need for any heroics
      return Address(base, byte_offset);
  
    // Don&#39;t do anything clever with negative or misaligned offsets
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1737,12 ***</span>
      return Address(Rd);
    }
  
    // See if we can do this with two 12-bit offsets
    {
<span class="line-modified">!     unsigned long word_offset = byte_offset &gt;&gt; shift;</span>
<span class="line-modified">!     unsigned long masked_offset = word_offset &amp; 0xfff000;</span>
      if (Address::offset_ok_for_immed(word_offset - masked_offset, 0)
          &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(masked_offset &lt;&lt; shift)) {
        add(Rd, base, masked_offset &lt;&lt; shift);
        word_offset -= masked_offset;
        return Address(Rd, word_offset &lt;&lt; shift);
<span class="line-new-header">--- 1737,12 ---</span>
      return Address(Rd);
    }
  
    // See if we can do this with two 12-bit offsets
    {
<span class="line-modified">!     uint64_t word_offset = byte_offset &gt;&gt; shift;</span>
<span class="line-modified">!     uint64_t masked_offset = word_offset &amp; 0xfff000;</span>
      if (Address::offset_ok_for_immed(word_offset - masked_offset, 0)
          &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(masked_offset &lt;&lt; shift)) {
        add(Rd, base, masked_offset &lt;&lt; shift);
        word_offset -= masked_offset;
        return Address(Rd, word_offset &lt;&lt; shift);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1979,11 ***</span>
    if (value &lt; 0)  { increment(reg, -value);      return; }
    if (value == 0) {                              return; }
    if (value &lt; (1 &lt;&lt; 12)) { sub(reg, reg, value); return; }
    /* else */ {
      assert(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
<span class="line-modified">!     mov(rscratch2, (unsigned long)value);</span>
      sub(reg, reg, rscratch2);
    }
  }
  
  void MacroAssembler::decrementw(Address dst, int value)
<span class="line-new-header">--- 1979,11 ---</span>
    if (value &lt; 0)  { increment(reg, -value);      return; }
    if (value == 0) {                              return; }
    if (value &lt; (1 &lt;&lt; 12)) { sub(reg, reg, value); return; }
    /* else */ {
      assert(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
<span class="line-modified">!     mov(rscratch2, (uint64_t) value);</span>
      sub(reg, reg, rscratch2);
    }
  }
  
  void MacroAssembler::decrementw(Address dst, int value)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2498,11 ***</span>
    if (UseLSE) {                                                         \
      prev = prev-&gt;is_valid() ? prev : zr;                                \
      if (incr.is_register()) {                                           \
        AOP(sz, incr.as_register(), prev, addr);                          \
      } else {                                                            \
<span class="line-modified">!       mov(rscratch2, incr.as_constant());                               \</span>
        AOP(sz, rscratch2, prev, addr);                                   \
      }                                                                   \
      return;                                                             \
    }                                                                     \
    Register result = rscratch2;                                          \
<span class="line-new-header">--- 2498,11 ---</span>
    if (UseLSE) {                                                         \
      prev = prev-&gt;is_valid() ? prev : zr;                                \
      if (incr.is_register()) {                                           \
        AOP(sz, incr.as_register(), prev, addr);                          \
      } else {                                                            \
<span class="line-modified">!       mov(rscratch2, (address)incr.as_constant());                      \</span>
        AOP(sz, rscratch2, prev, addr);                                   \
      }                                                                   \
      return;                                                             \
    }                                                                     \
    Register result = rscratch2;                                          \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2620,11 ***</span>
    fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
  }
  
  void MacroAssembler::push_call_clobbered_registers() {
    int step = 4 * wordSize;
<span class="line-modified">!   push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);</span>
    sub(sp, sp, step);
    mov(rscratch1, -step);
    // Push v0-v7, v16-v31.
    for (int i = 31; i&gt;= 4; i -= 4) {
      if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
<span class="line-new-header">--- 2620,11 ---</span>
    fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
  }
  
  void MacroAssembler::push_call_clobbered_registers() {
    int step = 4 * wordSize;
<span class="line-modified">!   push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) WIN64_ONLY(- r18), sp);</span>
    sub(sp, sp, step);
    mov(rscratch1, -step);
    // Push v0-v7, v16-v31.
    for (int i = 31; i&gt;= 4; i -= 4) {
      if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2639,12 ***</span>
    for (int i = 0; i &lt; 32; i += 4) {
      if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
        ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
            as_FloatRegister(i+3), T1D, Address(post(sp, 4 * wordSize)));
    }
<span class="line-modified">! </span>
<span class="line-removed">-   pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);</span>
  }
  
  void MacroAssembler::push_CPU_state(bool save_vectors) {
    int step = (save_vectors ? 8 : 4) * wordSize;
    push(0x3fffffff, sp);         // integer registers except lr &amp; sp
<span class="line-new-header">--- 2639,11 ---</span>
    for (int i = 0; i &lt; 32; i += 4) {
      if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
        ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
            as_FloatRegister(i+3), T1D, Address(post(sp, 4 * wordSize)));
    }
<span class="line-modified">!   pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) WIN64_ONLY(- r18), sp);</span>
  }
  
  void MacroAssembler::push_CPU_state(bool save_vectors) {
    int step = (save_vectors ? 8 : 4) * wordSize;
    push(0x3fffffff, sp);         // integer registers except lr &amp; sp
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2712,23 ***</span>
  
  // Checks whether offset is aligned.
  // Returns true if it is, else false.
  bool MacroAssembler::merge_alignment_check(Register base,
                                             size_t size,
<span class="line-modified">!                                            long cur_offset,</span>
<span class="line-modified">!                                            long prev_offset) const {</span>
    if (AvoidUnalignedAccesses) {
      if (base == sp) {
        // Checks whether low offset if aligned to pair of registers.
<span class="line-modified">!       long pair_mask = size * 2 - 1;</span>
<span class="line-modified">!       long offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;</span>
        return (offset &amp; pair_mask) == 0;
      } else { // If base is not sp, we can&#39;t guarantee the access is aligned.
        return false;
      }
    } else {
<span class="line-modified">!     long mask = size - 1;</span>
      // Load/store pair instruction only supports element size aligned offset.
      return (cur_offset &amp; mask) == 0 &amp;&amp; (prev_offset &amp; mask) == 0;
    }
  }
  
<span class="line-new-header">--- 2711,23 ---</span>
  
  // Checks whether offset is aligned.
  // Returns true if it is, else false.
  bool MacroAssembler::merge_alignment_check(Register base,
                                             size_t size,
<span class="line-modified">!                                            int64_t cur_offset,</span>
<span class="line-modified">!                                            int64_t prev_offset) const {</span>
    if (AvoidUnalignedAccesses) {
      if (base == sp) {
        // Checks whether low offset if aligned to pair of registers.
<span class="line-modified">!       int64_t pair_mask = size * 2 - 1;</span>
<span class="line-modified">!       int64_t offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;</span>
        return (offset &amp; pair_mask) == 0;
      } else { // If base is not sp, we can&#39;t guarantee the access is aligned.
        return false;
      }
    } else {
<span class="line-modified">!     int64_t mask = size - 1;</span>
      // Load/store pair instruction only supports element size aligned offset.
      return (cur_offset &amp; mask) == 0 &amp;&amp; (prev_offset &amp; mask) == 0;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2757,22 ***</span>
  
    if (cur_size_in_bytes != prev_size_in_bytes || is_store != prev_ldst-&gt;is_store()) {
      return false;
    }
  
<span class="line-modified">!   long max_offset = 63 * prev_size_in_bytes;</span>
<span class="line-modified">!   long min_offset = -64 * prev_size_in_bytes;</span>
  
    assert(prev_ldst-&gt;is_not_pre_post_index(), &quot;pre-index or post-index is not supported to be merged.&quot;);
  
    // Only same base can be merged.
    if (adr.base() != prev_ldst-&gt;base()) {
      return false;
    }
  
<span class="line-modified">!   long cur_offset = adr.offset();</span>
<span class="line-modified">!   long prev_offset = prev_ldst-&gt;offset();</span>
    size_t diff = abs(cur_offset - prev_offset);
    if (diff != prev_size_in_bytes) {
      return false;
    }
  
<span class="line-new-header">--- 2756,22 ---</span>
  
    if (cur_size_in_bytes != prev_size_in_bytes || is_store != prev_ldst-&gt;is_store()) {
      return false;
    }
  
<span class="line-modified">!   int64_t max_offset = 63 * prev_size_in_bytes;</span>
<span class="line-modified">!   int64_t min_offset = -64 * prev_size_in_bytes;</span>
  
    assert(prev_ldst-&gt;is_not_pre_post_index(), &quot;pre-index or post-index is not supported to be merged.&quot;);
  
    // Only same base can be merged.
    if (adr.base() != prev_ldst-&gt;base()) {
      return false;
    }
  
<span class="line-modified">!   int64_t cur_offset = adr.offset();</span>
<span class="line-modified">!   int64_t prev_offset = prev_ldst-&gt;offset();</span>
    size_t diff = abs(cur_offset - prev_offset);
    if (diff != prev_size_in_bytes) {
      return false;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2785,11 ***</span>
    // If t1 and t2 is the same in &quot;ldp t1, t2, [xn, #imm]&quot;, we&#39;ll get SIGILL.
    if (!is_store &amp;&amp; (adr.base() == prev_ldst-&gt;target() || rt == prev_ldst-&gt;target())) {
      return false;
    }
  
<span class="line-modified">!   long low_offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;</span>
    // Offset range must be in ldp/stp instruction&#39;s range.
    if (low_offset &gt; max_offset || low_offset &lt; min_offset) {
      return false;
    }
  
<span class="line-new-header">--- 2784,11 ---</span>
    // If t1 and t2 is the same in &quot;ldp t1, t2, [xn, #imm]&quot;, we&#39;ll get SIGILL.
    if (!is_store &amp;&amp; (adr.base() == prev_ldst-&gt;target() || rt == prev_ldst-&gt;target())) {
      return false;
    }
  
<span class="line-modified">!   int64_t low_offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;</span>
    // Offset range must be in ldp/stp instruction&#39;s range.
    if (low_offset &gt; max_offset || low_offset &lt; min_offset) {
      return false;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2810,11 ***</span>
  
    Register rt_low, rt_high;
    address prev = pc() - NativeInstruction::instruction_size;
    NativeLdSt* prev_ldst = NativeLdSt_at(prev);
  
<span class="line-modified">!   long offset;</span>
  
    if (adr.offset() &lt; prev_ldst-&gt;offset()) {
      offset = adr.offset();
      rt_low = rt;
      rt_high = prev_ldst-&gt;target();
<span class="line-new-header">--- 2809,11 ---</span>
  
    Register rt_low, rt_high;
    address prev = pc() - NativeInstruction::instruction_size;
    NativeLdSt* prev_ldst = NativeLdSt_at(prev);
  
<span class="line-modified">!   int64_t offset;</span>
  
    if (adr.offset() &lt; prev_ldst-&gt;offset()) {
      offset = adr.offset();
      rt_low = rt;
      rt_high = prev_ldst-&gt;target();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3356,11 ***</span>
   */
  void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,
          Register table0, Register table1, Register table2, Register table3,
          Register tmp, Register tmp2, Register tmp3) {
    Label L_by16, L_by16_loop, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;
<span class="line-modified">!   unsigned long offset;</span>
  
    if (UseCRC32) {
        kernel_crc32_using_crc32(crc, buf, len, table0, table1, table2, table3);
        return;
    }
<span class="line-new-header">--- 3355,11 ---</span>
   */
  void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,
          Register table0, Register table1, Register table2, Register table3,
          Register tmp, Register tmp2, Register tmp3) {
    Label L_by16, L_by16_loop, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;
<span class="line-modified">!   uint64_t offset;</span>
  
    if (UseCRC32) {
        kernel_crc32_using_crc32(crc, buf, len, table0, table1, table2, table3);
        return;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3658,11 ***</span>
  
  
  SkipIfEqual::SkipIfEqual(
      MacroAssembler* masm, const bool* flag_addr, bool value) {
    _masm = masm;
<span class="line-modified">!   unsigned long offset;</span>
    _masm-&gt;adrp(rscratch1, ExternalAddress((address)flag_addr), offset);
    _masm-&gt;ldrb(rscratch1, Address(rscratch1, offset));
    _masm-&gt;cbzw(rscratch1, _label);
  }
  
<span class="line-new-header">--- 3657,11 ---</span>
  
  
  SkipIfEqual::SkipIfEqual(
      MacroAssembler* masm, const bool* flag_addr, bool value) {
    _masm = masm;
<span class="line-modified">!   uint64_t offset;</span>
    _masm-&gt;adrp(rscratch1, ExternalAddress((address)flag_addr), offset);
    _masm-&gt;ldrb(rscratch1, Address(rscratch1, offset));
    _masm-&gt;cbzw(rscratch1, _label);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3687,11 ***</span>
    add(rscratch1, rscratch1, src);
    str(rscratch1, adr);
  }
  
  void MacroAssembler::cmpptr(Register src1, Address src2) {
<span class="line-modified">!   unsigned long offset;</span>
    adrp(rscratch1, src2, offset);
    ldr(rscratch1, Address(rscratch1, offset));
    cmp(src1, rscratch1);
  }
  
<span class="line-new-header">--- 3686,11 ---</span>
    add(rscratch1, rscratch1, src);
    str(rscratch1, adr);
  }
  
  void MacroAssembler::cmpptr(Register src1, Address src2) {
<span class="line-modified">!   uint64_t offset;</span>
    adrp(rscratch1, src2, offset);
    ldr(rscratch1, Address(rscratch1, offset));
    cmp(src1, rscratch1);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4308,11 ***</span>
  // Move the address of the polling page into dest.
  void MacroAssembler::get_polling_page(Register dest, address page, relocInfo::relocType rtype) {
    if (SafepointMechanism::uses_thread_local_poll()) {
      ldr(dest, Address(rthread, Thread::polling_page_offset()));
    } else {
<span class="line-modified">!     unsigned long off;</span>
      adrp(dest, Address(page, rtype), off);
      assert(off == 0, &quot;polling page must be page aligned&quot;);
    }
  }
  
<span class="line-new-header">--- 4307,11 ---</span>
  // Move the address of the polling page into dest.
  void MacroAssembler::get_polling_page(Register dest, address page, relocInfo::relocType rtype) {
    if (SafepointMechanism::uses_thread_local_poll()) {
      ldr(dest, Address(rthread, Thread::polling_page_offset()));
    } else {
<span class="line-modified">!     uint64_t off;</span>
      adrp(dest, Address(page, rtype), off);
      assert(off == 0, &quot;polling page must be page aligned&quot;);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4330,17 ***</span>
    code_section()-&gt;relocate(inst_mark(), rtype);
    ldrw(zr, Address(r, 0));
    return inst_mark();
  }
  
<span class="line-modified">! void MacroAssembler::adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset) {</span>
    relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
<span class="line-modified">!   unsigned long low_page = (unsigned long)CodeCache::low_bound() &gt;&gt; 12;</span>
<span class="line-modified">!   unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) &gt;&gt; 12;</span>
<span class="line-modified">!   unsigned long dest_page = (unsigned long)dest.target() &gt;&gt; 12;</span>
<span class="line-modified">!   long offset_low = dest_page - low_page;</span>
<span class="line-modified">!   long offset_high = dest_page - high_page;</span>
  
    assert(is_valid_AArch64_address(dest.target()), &quot;bad address&quot;);
    assert(dest.getMode() == Address::literal, &quot;ADRP must be applied to a literal address&quot;);
  
    InstructionMark im(this);
<span class="line-new-header">--- 4329,17 ---</span>
    code_section()-&gt;relocate(inst_mark(), rtype);
    ldrw(zr, Address(r, 0));
    return inst_mark();
  }
  
<span class="line-modified">! void MacroAssembler::adrp(Register reg1, const Address &amp;dest, uint64_t &amp;byte_offset) {</span>
    relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
<span class="line-modified">!   uint64_t low_page = (uint64_t)CodeCache::low_bound() &gt;&gt; 12;</span>
<span class="line-modified">!   uint64_t high_page = (uint64_t)(CodeCache::high_bound() - 1) &gt;&gt; 12;</span>
<span class="line-modified">!   uint64_t dest_page = (uint64_t)dest.target() &gt;&gt; 12;</span>
<span class="line-modified">!   int64_t offset_low = dest_page - low_page;</span>
<span class="line-modified">!   int64_t offset_high = dest_page - high_page;</span>
  
    assert(is_valid_AArch64_address(dest.target()), &quot;bad address&quot;);
    assert(dest.getMode() == Address::literal, &quot;ADRP must be applied to a literal address&quot;);
  
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4348,28 ***</span>
    // 8143067: Ensure that the adrp can reach the dest from anywhere within
    // the code cache so that if it is relocated we know it will still reach
    if (offset_high &gt;= -(1&lt;&lt;20) &amp;&amp; offset_low &lt; (1&lt;&lt;20)) {
      _adrp(reg1, dest.target());
    } else {
<span class="line-modified">!     unsigned long target = (unsigned long)dest.target();</span>
<span class="line-modified">!     unsigned long adrp_target</span>
<span class="line-modified">!       = (target &amp; 0xffffffffUL) | ((unsigned long)pc() &amp; 0xffff00000000UL);</span>
  
      _adrp(reg1, (address)adrp_target);
      movk(reg1, target &gt;&gt; 32, 32);
    }
<span class="line-modified">!   byte_offset = (unsigned long)dest.target() &amp; 0xfff;</span>
  }
  
  void MacroAssembler::load_byte_map_base(Register reg) {
    CardTable::CardValue* byte_map_base =
      ((CardTableBarrierSet*)(BarrierSet::barrier_set()))-&gt;card_table()-&gt;byte_map_base();
  
    if (is_valid_AArch64_address((address)byte_map_base)) {
      // Strictly speaking the byte_map_base isn&#39;t an address at all,
      // and it might even be negative.
<span class="line-modified">!     unsigned long offset;</span>
      adrp(reg, ExternalAddress((address)byte_map_base), offset);
      // We expect offset to be zero with most collectors.
      if (offset != 0) {
        add(reg, reg, offset);
      }
<span class="line-new-header">--- 4347,28 ---</span>
    // 8143067: Ensure that the adrp can reach the dest from anywhere within
    // the code cache so that if it is relocated we know it will still reach
    if (offset_high &gt;= -(1&lt;&lt;20) &amp;&amp; offset_low &lt; (1&lt;&lt;20)) {
      _adrp(reg1, dest.target());
    } else {
<span class="line-modified">!     uint64_t target = (uint64_t)dest.target();</span>
<span class="line-modified">!     uint64_t adrp_target</span>
<span class="line-modified">!       = (target &amp; 0xffffffffUL) | ((uint64_t)pc() &amp; 0xffff00000000UL);</span>
  
      _adrp(reg1, (address)adrp_target);
      movk(reg1, target &gt;&gt; 32, 32);
    }
<span class="line-modified">!   byte_offset = (uint64_t)dest.target() &amp; 0xfff;</span>
  }
  
  void MacroAssembler::load_byte_map_base(Register reg) {
    CardTable::CardValue* byte_map_base =
      ((CardTableBarrierSet*)(BarrierSet::barrier_set()))-&gt;card_table()-&gt;byte_map_base();
  
    if (is_valid_AArch64_address((address)byte_map_base)) {
      // Strictly speaking the byte_map_base isn&#39;t an address at all,
      // and it might even be negative.
<span class="line-modified">!     uint64_t offset;</span>
      adrp(reg, ExternalAddress((address)byte_map_base), offset);
      // We expect offset to be zero with most collectors.
      if (offset != 0) {
        add(reg, reg, offset);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4796,11 ***</span>
          cmp(cnt2, (u1)8);
          br(LT, DO1_SHORT);
  
          sub(result_tmp, cnt2, 8/str2_chr_size);
          sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);
<span class="line-modified">!         mov(tmp3, str2_isL ? 0x0101010101010101 : 0x0001000100010001);</span>
          lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));
  
          if (str2_isL) {
            orr(ch1, ch1, ch1, LSL, 8);
          }
<span class="line-new-header">--- 4795,11 ---</span>
          cmp(cnt2, (u1)8);
          br(LT, DO1_SHORT);
  
          sub(result_tmp, cnt2, 8/str2_chr_size);
          sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);
<span class="line-modified">!         mov(tmp3, (uint64_t)(str2_isL ? 0x0101010101010101 : 0x0001000100010001));</span>
          lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));
  
          if (str2_isL) {
            orr(ch1, ch1, ch1, LSL, 8);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4868,11 ***</span>
    sub(cnt1, cnt1, 4);
    mov(result_tmp, cnt1);
    lea(str1, Address(str1, cnt1, Address::uxtw(1)));
    sub(cnt1_neg, zr, cnt1, LSL, 1);
  
<span class="line-modified">!   mov(tmp3, 0x0001000100010001);</span>
  
    BIND(CH1_LOOP);
      ldr(ch1, Address(str1, cnt1_neg));
      eor(ch1, ch, ch1);
      sub(tmp1, ch1, tmp3);
<span class="line-new-header">--- 4867,11 ---</span>
    sub(cnt1, cnt1, 4);
    mov(result_tmp, cnt1);
    lea(str1, Address(str1, cnt1, Address::uxtw(1)));
    sub(cnt1_neg, zr, cnt1, LSL, 1);
  
<span class="line-modified">!   mov(tmp3, (uint64_t)0x0001000100010001);</span>
  
    BIND(CH1_LOOP);
      ldr(ch1, Address(str1, cnt1_neg));
      eor(ch1, ch, ch1);
      sub(tmp1, ch1, tmp3);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4914,11 ***</span>
  // Compare strings.
  void MacroAssembler::string_compare(Register str1, Register str2,
      Register cnt1, Register cnt2, Register result, Register tmp1, Register tmp2,
      FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {
    Label DONE, SHORT_LOOP, SHORT_STRING, SHORT_LAST, TAIL, STUB,
<span class="line-modified">!       DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,</span>
        SHORT_LOOP_START, TAIL_CHECK;
  
    bool isLL = ae == StrIntrinsicNode::LL;
    bool isLU = ae == StrIntrinsicNode::LU;
    bool isUL = ae == StrIntrinsicNode::UL;
<span class="line-new-header">--- 4913,11 ---</span>
  // Compare strings.
  void MacroAssembler::string_compare(Register str1, Register str2,
      Register cnt1, Register cnt2, Register result, Register tmp1, Register tmp2,
      FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {
    Label DONE, SHORT_LOOP, SHORT_STRING, SHORT_LAST, TAIL, STUB,
<span class="line-modified">!       DIFF, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,</span>
        SHORT_LOOP_START, TAIL_CHECK;
  
    bool isLL = ae == StrIntrinsicNode::LL;
    bool isLU = ae == StrIntrinsicNode::LU;
    bool isUL = ae == StrIntrinsicNode::UL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5009,11 ***</span>
        fmovd(tmp2, vtmp);
      }
      adds(cnt2, cnt2, isUL ? 4 : 8);
      br(GE, TAIL);
      eor(rscratch2, tmp1, tmp2);
<span class="line-modified">!     cbnz(rscratch2, DIFFERENCE);</span>
      // main loop
      bind(NEXT_WORD);
      if (str1_isL == str2_isL) {
        ldr(tmp1, Address(str1, cnt2));
        ldr(tmp2, Address(str2, cnt2));
<span class="line-new-header">--- 5008,11 ---</span>
        fmovd(tmp2, vtmp);
      }
      adds(cnt2, cnt2, isUL ? 4 : 8);
      br(GE, TAIL);
      eor(rscratch2, tmp1, tmp2);
<span class="line-modified">!     cbnz(rscratch2, DIFF);</span>
      // main loop
      bind(NEXT_WORD);
      if (str1_isL == str2_isL) {
        ldr(tmp1, Address(str1, cnt2));
        ldr(tmp2, Address(str2, cnt2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5035,14 ***</span>
      }
      br(GE, TAIL);
  
      eor(rscratch2, tmp1, tmp2);
      cbz(rscratch2, NEXT_WORD);
<span class="line-modified">!     b(DIFFERENCE);</span>
      bind(TAIL);
      eor(rscratch2, tmp1, tmp2);
<span class="line-modified">!     cbnz(rscratch2, DIFFERENCE);</span>
      // Last longword.  In the case where length == 4 we compare the
      // same longword twice, but that&#39;s still faster than another
      // conditional branch.
      if (str1_isL == str2_isL) {
        ldr(tmp1, Address(str1));
<span class="line-new-header">--- 5034,14 ---</span>
      }
      br(GE, TAIL);
  
      eor(rscratch2, tmp1, tmp2);
      cbz(rscratch2, NEXT_WORD);
<span class="line-modified">!     b(DIFF);</span>
      bind(TAIL);
      eor(rscratch2, tmp1, tmp2);
<span class="line-modified">!     cbnz(rscratch2, DIFF);</span>
      // Last longword.  In the case where length == 4 we compare the
      // same longword twice, but that&#39;s still faster than another
      // conditional branch.
      if (str1_isL == str2_isL) {
        ldr(tmp1, Address(str1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5062,11 ***</span>
      eor(rscratch2, tmp1, tmp2);
      cbz(rscratch2, DONE);
  
      // Find the first different characters in the longwords and
      // compute their difference.
<span class="line-modified">!     bind(DIFFERENCE);</span>
      rev(rscratch2, rscratch2);
      clz(rscratch2, rscratch2);
      andr(rscratch2, rscratch2, isLL ? -8 : -16);
      lsrv(tmp1, tmp1, rscratch2);
      (this-&gt;*ext_chr)(tmp1, tmp1);
<span class="line-new-header">--- 5061,11 ---</span>
      eor(rscratch2, tmp1, tmp2);
      cbz(rscratch2, DONE);
  
      // Find the first different characters in the longwords and
      // compute their difference.
<span class="line-modified">!     bind(DIFF);</span>
      rev(rscratch2, rscratch2);
      clz(rscratch2, rscratch2);
      andr(rscratch2, rscratch2, isLL ? -8 : -16);
      lsrv(tmp1, tmp1, rscratch2);
      (this-&gt;*ext_chr)(tmp1, tmp1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5541,11 ***</span>
  }
  
  // base:         Address of a buffer to be zeroed, 8 bytes aligned.
  // cnt:          Immediate count in HeapWords.
  #define SmallArraySize (18 * BytesPerLong)
<span class="line-modified">! void MacroAssembler::zero_words(Register base, u_int64_t cnt)</span>
  {
    BLOCK_COMMENT(&quot;zero_words {&quot;);
    int i = cnt &amp; 1;  // store any odd word to start
    if (i) str(zr, Address(base));
  
<span class="line-new-header">--- 5540,11 ---</span>
  }
  
  // base:         Address of a buffer to be zeroed, 8 bytes aligned.
  // cnt:          Immediate count in HeapWords.
  #define SmallArraySize (18 * BytesPerLong)
<span class="line-modified">! void MacroAssembler::zero_words(Register base, uint64_t cnt)</span>
  {
    BLOCK_COMMENT(&quot;zero_words {&quot;);
    int i = cnt &amp; 1;  // store any odd word to start
    if (i) str(zr, Address(base));
  
</pre>
<center><a href="jvmciCodeInstaller_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="..\..\..\..\index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>