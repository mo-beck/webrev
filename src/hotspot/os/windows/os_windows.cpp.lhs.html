<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src\hotspot\os\windows\os_windows.cpp</title>
    <link rel="stylesheet" href="..\..\..\..\style.css" />
    <script type="text/javascript" src="..\..\..\..\navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // Must be at least Windows Vista or Server 2008 to use InitOnceExecuteOnce
  26 #define _WIN32_WINNT 0x0600
  27 
  28 // no precompiled headers
  29 #include &quot;jvm.h&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
<a name="1" id="anc1"></a>
  34 #include &quot;code/vtableStubs.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;compiler/disassembler.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/allocation.inline.hpp&quot;
  41 #include &quot;memory/filemap.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;os_share_windows.hpp&quot;
  44 #include &quot;os_windows.inline.hpp&quot;
  45 #include &quot;prims/jniFastGetField.hpp&quot;
  46 #include &quot;prims/jvm_misc.hpp&quot;
  47 #include &quot;runtime/arguments.hpp&quot;
  48 #include &quot;runtime/atomic.hpp&quot;
  49 #include &quot;runtime/extendedPC.hpp&quot;
  50 #include &quot;runtime/globals.hpp&quot;
  51 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  52 #include &quot;runtime/java.hpp&quot;
  53 #include &quot;runtime/javaCalls.hpp&quot;
  54 #include &quot;runtime/mutexLocker.hpp&quot;
  55 #include &quot;runtime/objectMonitor.hpp&quot;
  56 #include &quot;runtime/orderAccess.hpp&quot;
  57 #include &quot;runtime/osThread.hpp&quot;
  58 #include &quot;runtime/perfMemory.hpp&quot;
  59 #include &quot;runtime/sharedRuntime.hpp&quot;
  60 #include &quot;runtime/statSampler.hpp&quot;
  61 #include &quot;runtime/stubRoutines.hpp&quot;
  62 #include &quot;runtime/thread.inline.hpp&quot;
  63 #include &quot;runtime/threadCritical.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
  65 #include &quot;runtime/vm_version.hpp&quot;
  66 #include &quot;services/attachListener.hpp&quot;
  67 #include &quot;services/memTracker.hpp&quot;
  68 #include &quot;services/runtimeService.hpp&quot;
  69 #include &quot;utilities/align.hpp&quot;
  70 #include &quot;utilities/decoder.hpp&quot;
  71 #include &quot;utilities/defaultStream.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/growableArray.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;
  75 #include &quot;utilities/vmError.hpp&quot;
  76 #include &quot;symbolengine.hpp&quot;
  77 #include &quot;windbghelp.hpp&quot;
  78 
  79 
  80 #ifdef _DEBUG
  81 #include &lt;crtdbg.h&gt;
  82 #endif
  83 
  84 
  85 #include &lt;windows.h&gt;
  86 #include &lt;sys/types.h&gt;
  87 #include &lt;sys/stat.h&gt;
  88 #include &lt;sys/timeb.h&gt;
  89 #include &lt;objidl.h&gt;
  90 #include &lt;shlobj.h&gt;
  91 
  92 #include &lt;malloc.h&gt;
  93 #include &lt;signal.h&gt;
  94 #include &lt;direct.h&gt;
  95 #include &lt;errno.h&gt;
  96 #include &lt;fcntl.h&gt;
  97 #include &lt;io.h&gt;
  98 #include &lt;process.h&gt;              // For _beginthreadex(), _endthreadex()
  99 #include &lt;imagehlp.h&gt;             // For os::dll_address_to_function_name
 100 // for enumerating dll libraries
 101 #include &lt;vdmdbg.h&gt;
 102 #include &lt;psapi.h&gt;
 103 #include &lt;mmsystem.h&gt;
 104 #include &lt;winsock2.h&gt;
 105 
 106 // for timer info max values which include all bits
 107 #define ALL_64_BITS CONST64(-1)
 108 
 109 // For DLL loading/load error detection
 110 // Values of PE COFF
 111 #define IMAGE_FILE_PTR_TO_SIGNATURE 0x3c
 112 #define IMAGE_FILE_SIGNATURE_LENGTH 4
 113 
 114 static HANDLE main_process;
 115 static HANDLE main_thread;
 116 static int    main_thread_id;
 117 
 118 static FILETIME process_creation_time;
 119 static FILETIME process_exit_time;
 120 static FILETIME process_user_time;
 121 static FILETIME process_kernel_time;
 122 
 123 #ifdef _M_AMD64
 124   #define __CPU__ amd64
<a name="2" id="anc2"></a>

 125 #else
 126   #define __CPU__ i486
 127 #endif
 128 
<a name="3" id="anc3"></a><span class="line-removed"> 129 #if INCLUDE_AOT</span>
 130 PVOID  topLevelVectoredExceptionHandler = NULL;
<a name="4" id="anc4"></a><span class="line-removed"> 131 LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);</span>
<span class="line-removed"> 132 #endif</span>
 133 
 134 // save DLL module handle, used by GetModuleFileName
 135 
 136 HINSTANCE vm_lib_handle;
 137 
 138 BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved) {
 139   switch (reason) {
 140   case DLL_PROCESS_ATTACH:
 141     vm_lib_handle = hinst;
 142     if (ForceTimeHighResolution) {
 143       timeBeginPeriod(1L);
 144     }
 145     WindowsDbgHelp::pre_initialize();
 146     SymbolEngine::pre_initialize();
 147     break;
 148   case DLL_PROCESS_DETACH:
 149     if (ForceTimeHighResolution) {
 150       timeEndPeriod(1L);
 151     }
<a name="5" id="anc5"></a><span class="line-removed"> 152 #if INCLUDE_AOT</span>
 153     if (topLevelVectoredExceptionHandler != NULL) {
 154       RemoveVectoredExceptionHandler(topLevelVectoredExceptionHandler);
 155       topLevelVectoredExceptionHandler = NULL;
 156     }
<a name="6" id="anc6"></a><span class="line-removed"> 157 #endif</span>
 158     break;
 159   default:
 160     break;
 161   }
 162   return true;
 163 }
 164 
 165 static inline double fileTimeAsDouble(FILETIME* time) {
 166   const double high  = (double) ((unsigned int) ~0);
 167   const double split = 10000000.0;
 168   double result = (time-&gt;dwLowDateTime / split) +
 169                    time-&gt;dwHighDateTime * (high/split);
 170   return result;
 171 }
 172 
 173 // Implementation of os
 174 
 175 bool os::unsetenv(const char* name) {
 176   assert(name != NULL, &quot;Null pointer&quot;);
 177   return (SetEnvironmentVariable(name, NULL) == TRUE);
 178 }
 179 
 180 // No setuid programs under Windows.
 181 bool os::have_special_privileges() {
 182   return false;
 183 }
 184 
 185 
 186 // This method is  a periodic task to check for misbehaving JNI applications
 187 // under CheckJNI, we can add any periodic checks here.
 188 // For Windows at the moment does nothing
 189 void os::run_periodic_checks() {
 190   return;
 191 }
 192 
 193 // previous UnhandledExceptionFilter, if there is one
 194 static LPTOP_LEVEL_EXCEPTION_FILTER prev_uef_handler = NULL;
 195 
 196 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo);
 197 
 198 void os::init_system_properties_values() {
 199   // sysclasspath, java_home, dll_dir
 200   {
 201     char *home_path;
 202     char *dll_path;
 203     char *pslash;
 204     const char *bin = &quot;\\bin&quot;;
 205     char home_dir[MAX_PATH + 1];
 206     char *alt_home_dir = ::getenv(&quot;_ALT_JAVA_HOME_DIR&quot;);
 207 
 208     if (alt_home_dir != NULL)  {
 209       strncpy(home_dir, alt_home_dir, MAX_PATH + 1);
 210       home_dir[MAX_PATH] = &#39;\0&#39;;
 211     } else {
 212       os::jvm_path(home_dir, sizeof(home_dir));
 213       // Found the full path to jvm.dll.
 214       // Now cut the path to &lt;java_home&gt;/jre if we can.
 215       *(strrchr(home_dir, &#39;\\&#39;)) = &#39;\0&#39;;  // get rid of \jvm.dll
 216       pslash = strrchr(home_dir, &#39;\\&#39;);
 217       if (pslash != NULL) {
 218         *pslash = &#39;\0&#39;;                   // get rid of \{client|server}
 219         pslash = strrchr(home_dir, &#39;\\&#39;);
 220         if (pslash != NULL) {
 221           *pslash = &#39;\0&#39;;                 // get rid of \bin
 222         }
 223       }
 224     }
 225 
 226     home_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + 1, mtInternal);
 227     strcpy(home_path, home_dir);
 228     Arguments::set_java_home(home_path);
 229     FREE_C_HEAP_ARRAY(char, home_path);
 230 
 231     dll_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + strlen(bin) + 1,
 232                                 mtInternal);
 233     strcpy(dll_path, home_dir);
 234     strcat(dll_path, bin);
 235     Arguments::set_dll_dir(dll_path);
 236     FREE_C_HEAP_ARRAY(char, dll_path);
 237 
 238     if (!set_boot_path(&#39;\\&#39;, &#39;;&#39;)) {
 239       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 240     }
 241   }
 242 
 243 // library_path
 244 #define EXT_DIR &quot;\\lib\\ext&quot;
 245 #define BIN_DIR &quot;\\bin&quot;
 246 #define PACKAGE_DIR &quot;\\Sun\\Java&quot;
 247   {
 248     // Win32 library search order (See the documentation for LoadLibrary):
 249     //
 250     // 1. The directory from which application is loaded.
 251     // 2. The system wide Java Extensions directory (Java only)
 252     // 3. System directory (GetSystemDirectory)
 253     // 4. Windows directory (GetWindowsDirectory)
 254     // 5. The PATH environment variable
 255     // 6. The current directory
 256 
 257     char *library_path;
 258     char tmp[MAX_PATH];
 259     char *path_str = ::getenv(&quot;PATH&quot;);
 260 
 261     library_path = NEW_C_HEAP_ARRAY(char, MAX_PATH * 5 + sizeof(PACKAGE_DIR) +
 262                                     sizeof(BIN_DIR) + (path_str ? strlen(path_str) : 0) + 10, mtInternal);
 263 
 264     library_path[0] = &#39;\0&#39;;
 265 
 266     GetModuleFileName(NULL, tmp, sizeof(tmp));
 267     *(strrchr(tmp, &#39;\\&#39;)) = &#39;\0&#39;;
 268     strcat(library_path, tmp);
 269 
 270     GetWindowsDirectory(tmp, sizeof(tmp));
 271     strcat(library_path, &quot;;&quot;);
 272     strcat(library_path, tmp);
 273     strcat(library_path, PACKAGE_DIR BIN_DIR);
 274 
 275     GetSystemDirectory(tmp, sizeof(tmp));
 276     strcat(library_path, &quot;;&quot;);
 277     strcat(library_path, tmp);
 278 
 279     GetWindowsDirectory(tmp, sizeof(tmp));
 280     strcat(library_path, &quot;;&quot;);
 281     strcat(library_path, tmp);
 282 
 283     if (path_str) {
 284       strcat(library_path, &quot;;&quot;);
 285       strcat(library_path, path_str);
 286     }
 287 
 288     strcat(library_path, &quot;;.&quot;);
 289 
 290     Arguments::set_library_path(library_path);
 291     FREE_C_HEAP_ARRAY(char, library_path);
 292   }
 293 
 294   // Default extensions directory
 295   {
 296     char path[MAX_PATH];
 297     char buf[2 * MAX_PATH + 2 * sizeof(EXT_DIR) + sizeof(PACKAGE_DIR) + 1];
 298     GetWindowsDirectory(path, MAX_PATH);
 299     sprintf(buf, &quot;%s%s;%s%s%s&quot;, Arguments::get_java_home(), EXT_DIR,
 300             path, PACKAGE_DIR, EXT_DIR);
 301     Arguments::set_ext_dirs(buf);
 302   }
 303   #undef EXT_DIR
 304   #undef BIN_DIR
 305   #undef PACKAGE_DIR
 306 
 307 #ifndef _WIN64
 308   // set our UnhandledExceptionFilter and save any previous one
 309   prev_uef_handler = SetUnhandledExceptionFilter(Handle_FLT_Exception);
 310 #endif
 311 
 312   // Done
 313   return;
 314 }
 315 
 316 void os::breakpoint() {
 317   DebugBreak();
 318 }
 319 
 320 // Invoked from the BREAKPOINT Macro
 321 extern &quot;C&quot; void breakpoint() {
 322   os::breakpoint();
 323 }
 324 
 325 // RtlCaptureStackBackTrace Windows API may not exist prior to Windows XP.
 326 // So far, this method is only used by Native Memory Tracking, which is
 327 // only supported on Windows XP or later.
 328 //
 329 int os::get_native_stack(address* stack, int frames, int toSkip) {
 330   int captured = RtlCaptureStackBackTrace(toSkip + 1, frames, (PVOID*)stack, NULL);
 331   for (int index = captured; index &lt; frames; index ++) {
 332     stack[index] = NULL;
 333   }
 334   return captured;
 335 }
 336 
 337 
 338 // os::current_stack_base()
 339 //
 340 //   Returns the base of the stack, which is the stack&#39;s
 341 //   starting address.  This function must be called
 342 //   while running on the stack of the thread being queried.
 343 
 344 address os::current_stack_base() {
 345   MEMORY_BASIC_INFORMATION minfo;
 346   address stack_bottom;
 347   size_t stack_size;
 348 
 349   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 350   stack_bottom =  (address)minfo.AllocationBase;
 351   stack_size = minfo.RegionSize;
 352 
 353   // Add up the sizes of all the regions with the same
 354   // AllocationBase.
 355   while (1) {
 356     VirtualQuery(stack_bottom+stack_size, &amp;minfo, sizeof(minfo));
 357     if (stack_bottom == (address)minfo.AllocationBase) {
 358       stack_size += minfo.RegionSize;
 359     } else {
 360       break;
 361     }
 362   }
 363   return stack_bottom + stack_size;
 364 }
 365 
 366 size_t os::current_stack_size() {
 367   size_t sz;
 368   MEMORY_BASIC_INFORMATION minfo;
 369   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 370   sz = (size_t)os::current_stack_base() - (size_t)minfo.AllocationBase;
 371   return sz;
 372 }
 373 
 374 bool os::committed_in_range(address start, size_t size, address&amp; committed_start, size_t&amp; committed_size) {
 375   MEMORY_BASIC_INFORMATION minfo;
 376   committed_start = NULL;
 377   committed_size = 0;
 378   address top = start + size;
 379   const address start_addr = start;
 380   while (start &lt; top) {
 381     VirtualQuery(start, &amp;minfo, sizeof(minfo));
 382     if ((minfo.State &amp; MEM_COMMIT) == 0) {  // not committed
 383       if (committed_start != NULL) {
 384         break;
 385       }
 386     } else {  // committed
 387       if (committed_start == NULL) {
 388         committed_start = start;
 389       }
 390       size_t offset = start - (address)minfo.BaseAddress;
 391       committed_size += minfo.RegionSize - offset;
 392     }
 393     start = (address)minfo.BaseAddress + minfo.RegionSize;
 394   }
 395 
 396   if (committed_start == NULL) {
 397     assert(committed_size == 0, &quot;Sanity&quot;);
 398     return false;
 399   } else {
 400     assert(committed_start &gt;= start_addr &amp;&amp; committed_start &lt; top, &quot;Out of range&quot;);
 401     // current region may go beyond the limit, trim to the limit
 402     committed_size = MIN2(committed_size, size_t(top - committed_start));
 403     return true;
 404   }
 405 }
 406 
 407 struct tm* os::localtime_pd(const time_t* clock, struct tm* res) {
 408   const struct tm* time_struct_ptr = localtime(clock);
 409   if (time_struct_ptr != NULL) {
 410     *res = *time_struct_ptr;
 411     return res;
 412   }
 413   return NULL;
 414 }
 415 
 416 struct tm* os::gmtime_pd(const time_t* clock, struct tm* res) {
 417   const struct tm* time_struct_ptr = gmtime(clock);
 418   if (time_struct_ptr != NULL) {
 419     *res = *time_struct_ptr;
 420     return res;
 421   }
 422   return NULL;
 423 }
 424 
<a name="7" id="anc7"></a><span class="line-removed"> 425 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);</span>
<span class="line-removed"> 426 </span>
 427 // Thread start routine for all newly created threads
 428 static unsigned __stdcall thread_native_entry(Thread* thread) {
 429 
 430   thread-&gt;record_stack_base_and_size();
 431 
 432   // Try to randomize the cache line index of hot stack frames.
 433   // This helps when threads of the same stack traces evict each other&#39;s
 434   // cache lines. The threads can be either from the same JVM instance, or
 435   // from different JVM instances. The benefit is especially true for
 436   // processors with hyperthreading technology.
 437   static int counter = 0;
 438   int pid = os::current_process_id();
 439   _alloca(((pid ^ counter++) &amp; 7) * 128);
 440 
 441   thread-&gt;initialize_thread_current();
 442 
 443   OSThread* osthr = thread-&gt;osthread();
 444   assert(osthr-&gt;get_state() == RUNNABLE, &quot;invalid os thread state&quot;);
 445 
 446   if (UseNUMA) {
 447     int lgrp_id = os::numa_get_group_id();
 448     if (lgrp_id != -1) {
 449       thread-&gt;set_lgrp_id(lgrp_id);
 450     }
 451   }
 452 
 453   // Diagnostic code to investigate JDK-6573254
 454   int res = 30115;  // non-java thread
 455   if (thread-&gt;is_Java_thread()) {
 456     res = 20115;    // java thread
 457   }
 458 
 459   log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 460 
<a name="8" id="anc8"></a><span class="line-modified"> 461   // Install a win32 structured exception handler around every thread created</span>
<span class="line-modified"> 462   // by VM, so VM can generate error dump when an exception occurred in non-</span>
<span class="line-modified"> 463   // Java thread (e.g. VM thread).</span>
<span class="line-modified"> 464   __try {</span>
<span class="line-removed"> 465     thread-&gt;call_run();</span>
<span class="line-removed"> 466   } __except(topLevelExceptionFilter(</span>
<span class="line-removed"> 467                                      (_EXCEPTION_POINTERS*)_exception_info())) {</span>
<span class="line-removed"> 468     // Nothing to do.</span>
<span class="line-removed"> 469   }</span>
 470 
 471   // Note: at this point the thread object may already have deleted itself.
 472   // Do not dereference it from here on out.
 473 
 474   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 475 
 476   // One less thread is executing
 477   // When the VMThread gets here, the main thread may have already exited
 478   // which frees the CodeHeap containing the Atomic::add code
 479   if (thread != VMThread::vm_thread() &amp;&amp; VMThread::vm_thread() != NULL) {
 480     Atomic::dec(&amp;os::win32::_os_thread_count);
 481   }
 482 
 483   // Thread must not return from exit_process_or_thread(), but if it does,
 484   // let it proceed to exit normally
 485   return (unsigned)os::win32::exit_process_or_thread(os::win32::EPT_THREAD, res);
 486 }
 487 
 488 static OSThread* create_os_thread(Thread* thread, HANDLE thread_handle,
 489                                   int thread_id) {
 490   // Allocate the OSThread object
 491   OSThread* osthread = new OSThread(NULL, NULL);
 492   if (osthread == NULL) return NULL;
 493 
 494   // Initialize the JDK library&#39;s interrupt event.
 495   // This should really be done when OSThread is constructed,
 496   // but there is no way for a constructor to report failure to
 497   // allocate the event.
 498   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 499   if (interrupt_event == NULL) {
 500     delete osthread;
 501     return NULL;
 502   }
 503   osthread-&gt;set_interrupt_event(interrupt_event);
 504 
 505   // Store info on the Win32 thread into the OSThread
 506   osthread-&gt;set_thread_handle(thread_handle);
 507   osthread-&gt;set_thread_id(thread_id);
 508 
 509   if (UseNUMA) {
 510     int lgrp_id = os::numa_get_group_id();
 511     if (lgrp_id != -1) {
 512       thread-&gt;set_lgrp_id(lgrp_id);
 513     }
 514   }
 515 
 516   // Initial thread state is INITIALIZED, not SUSPENDED
 517   osthread-&gt;set_state(INITIALIZED);
 518 
 519   return osthread;
 520 }
 521 
 522 
 523 bool os::create_attached_thread(JavaThread* thread) {
 524 #ifdef ASSERT
 525   thread-&gt;verify_not_published();
 526 #endif
 527   HANDLE thread_h;
 528   if (!DuplicateHandle(main_process, GetCurrentThread(), GetCurrentProcess(),
 529                        &amp;thread_h, THREAD_ALL_ACCESS, false, 0)) {
 530     fatal(&quot;DuplicateHandle failed\n&quot;);
 531   }
 532   OSThread* osthread = create_os_thread(thread, thread_h,
 533                                         (int)current_thread_id());
 534   if (osthread == NULL) {
 535     return false;
 536   }
 537 
 538   // Initial thread state is RUNNABLE
 539   osthread-&gt;set_state(RUNNABLE);
 540 
 541   thread-&gt;set_osthread(osthread);
 542 
 543   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;).&quot;,
 544     os::current_thread_id());
 545 
 546   return true;
 547 }
 548 
 549 bool os::create_main_thread(JavaThread* thread) {
 550 #ifdef ASSERT
 551   thread-&gt;verify_not_published();
 552 #endif
 553   if (_starting_thread == NULL) {
 554     _starting_thread = create_os_thread(thread, main_thread, main_thread_id);
 555     if (_starting_thread == NULL) {
 556       return false;
 557     }
 558   }
 559 
 560   // The primordial thread is runnable from the start)
 561   _starting_thread-&gt;set_state(RUNNABLE);
 562 
 563   thread-&gt;set_osthread(_starting_thread);
 564   return true;
 565 }
 566 
 567 // Helper function to trace _beginthreadex attributes,
 568 //  similar to os::Posix::describe_pthread_attr()
 569 static char* describe_beginthreadex_attributes(char* buf, size_t buflen,
 570                                                size_t stacksize, unsigned initflag) {
 571   stringStream ss(buf, buflen);
 572   if (stacksize == 0) {
 573     ss.print(&quot;stacksize: default, &quot;);
 574   } else {
 575     ss.print(&quot;stacksize: &quot; SIZE_FORMAT &quot;k, &quot;, stacksize / 1024);
 576   }
 577   ss.print(&quot;flags: &quot;);
 578   #define PRINT_FLAG(f) if (initflag &amp; f) ss.print( #f &quot; &quot;);
 579   #define ALL(X) \
 580     X(CREATE_SUSPENDED) \
 581     X(STACK_SIZE_PARAM_IS_A_RESERVATION)
 582   ALL(PRINT_FLAG)
 583   #undef ALL
 584   #undef PRINT_FLAG
 585   return buf;
 586 }
 587 
 588 // Allocate and initialize a new OSThread
 589 bool os::create_thread(Thread* thread, ThreadType thr_type,
 590                        size_t stack_size) {
 591   unsigned thread_id;
 592 
 593   // Allocate the OSThread object
 594   OSThread* osthread = new OSThread(NULL, NULL);
 595   if (osthread == NULL) {
 596     return false;
 597   }
 598 
 599   // Initialize the JDK library&#39;s interrupt event.
 600   // This should really be done when OSThread is constructed,
 601   // but there is no way for a constructor to report failure to
 602   // allocate the event.
 603   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 604   if (interrupt_event == NULL) {
 605     delete osthread;
 606     return false;
 607   }
 608   osthread-&gt;set_interrupt_event(interrupt_event);
 609   // We don&#39;t call set_interrupted(false) as it will trip the assert in there
 610   // as we are not operating on the current thread. We don&#39;t need to call it
 611   // because the initial state is already correct.
 612 
 613   thread-&gt;set_osthread(osthread);
 614 
 615   if (stack_size == 0) {
 616     switch (thr_type) {
 617     case os::java_thread:
 618       // Java threads use ThreadStackSize which default value can be changed with the flag -Xss
 619       if (JavaThread::stack_size_at_create() &gt; 0) {
 620         stack_size = JavaThread::stack_size_at_create();
 621       }
 622       break;
 623     case os::compiler_thread:
 624       if (CompilerThreadStackSize &gt; 0) {
 625         stack_size = (size_t)(CompilerThreadStackSize * K);
 626         break;
 627       } // else fall through:
 628         // use VMThreadStackSize if CompilerThreadStackSize is not defined
 629     case os::vm_thread:
 630     case os::pgc_thread:
 631     case os::cgc_thread:
 632     case os::watcher_thread:
 633       if (VMThreadStackSize &gt; 0) stack_size = (size_t)(VMThreadStackSize * K);
 634       break;
 635     }
 636   }
 637 
 638   // Create the Win32 thread
 639   //
 640   // Contrary to what MSDN document says, &quot;stack_size&quot; in _beginthreadex()
 641   // does not specify stack size. Instead, it specifies the size of
 642   // initially committed space. The stack size is determined by
 643   // PE header in the executable. If the committed &quot;stack_size&quot; is larger
 644   // than default value in the PE header, the stack is rounded up to the
 645   // nearest multiple of 1MB. For example if the launcher has default
 646   // stack size of 320k, specifying any size less than 320k does not
 647   // affect the actual stack size at all, it only affects the initial
 648   // commitment. On the other hand, specifying &#39;stack_size&#39; larger than
 649   // default value may cause significant increase in memory usage, because
 650   // not only the stack space will be rounded up to MB, but also the
 651   // entire space is committed upfront.
 652   //
 653   // Finally Windows XP added a new flag &#39;STACK_SIZE_PARAM_IS_A_RESERVATION&#39;
 654   // for CreateThread() that can treat &#39;stack_size&#39; as stack size. However we
 655   // are not supposed to call CreateThread() directly according to MSDN
 656   // document because JVM uses C runtime library. The good news is that the
 657   // flag appears to work with _beginthredex() as well.
 658 
 659   const unsigned initflag = CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION;
 660   HANDLE thread_handle =
 661     (HANDLE)_beginthreadex(NULL,
 662                            (unsigned)stack_size,
 663                            (unsigned (__stdcall *)(void*)) thread_native_entry,
 664                            thread,
 665                            initflag,
 666                            &amp;thread_id);
 667 
 668   char buf[64];
 669   if (thread_handle != NULL) {
 670     log_info(os, thread)(&quot;Thread started (tid: %u, attributes: %s)&quot;,
 671       thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 672   } else {
 673     log_warning(os, thread)(&quot;Failed to start thread - _beginthreadex failed (%s) for attributes: %s.&quot;,
 674       os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 675     // Log some OS information which might explain why creating the thread failed.
 676     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());
 677     LogStream st(Log(os, thread)::info());
 678     os::print_memory_info(&amp;st);
 679   }
 680 
 681   if (thread_handle == NULL) {
 682     // Need to clean up stuff we&#39;ve allocated so far
 683     thread-&gt;set_osthread(NULL);
 684     delete osthread;
 685     return false;
 686   }
 687 
 688   Atomic::inc(&amp;os::win32::_os_thread_count);
 689 
 690   // Store info on the Win32 thread into the OSThread
 691   osthread-&gt;set_thread_handle(thread_handle);
 692   osthread-&gt;set_thread_id(thread_id);
 693 
 694   // Initial thread state is INITIALIZED, not SUSPENDED
 695   osthread-&gt;set_state(INITIALIZED);
 696 
 697   // The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain
 698   return true;
 699 }
 700 
 701 
 702 // Free Win32 resources related to the OSThread
 703 void os::free_thread(OSThread* osthread) {
 704   assert(osthread != NULL, &quot;osthread not set&quot;);
 705 
 706   // We are told to free resources of the argument thread,
 707   // but we can only really operate on the current thread.
 708   assert(Thread::current()-&gt;osthread() == osthread,
 709          &quot;os::free_thread but not current thread&quot;);
 710 
 711   CloseHandle(osthread-&gt;thread_handle());
 712   delete osthread;
 713 }
 714 
 715 static jlong first_filetime;
 716 static jlong initial_performance_count;
 717 static jlong performance_frequency;
 718 
 719 
 720 jlong as_long(LARGE_INTEGER x) {
 721   jlong result = 0; // initialization to avoid warning
 722   set_high(&amp;result, x.HighPart);
 723   set_low(&amp;result, x.LowPart);
 724   return result;
 725 }
 726 
 727 
 728 jlong os::elapsed_counter() {
 729   LARGE_INTEGER count;
 730   QueryPerformanceCounter(&amp;count);
 731   return as_long(count) - initial_performance_count;
 732 }
 733 
 734 
 735 jlong os::elapsed_frequency() {
 736   return performance_frequency;
 737 }
 738 
 739 
 740 julong os::available_memory() {
 741   return win32::available_memory();
 742 }
 743 
 744 julong os::win32::available_memory() {
 745   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
 746   // value if total memory is larger than 4GB
 747   MEMORYSTATUSEX ms;
 748   ms.dwLength = sizeof(ms);
 749   GlobalMemoryStatusEx(&amp;ms);
 750 
 751   return (julong)ms.ullAvailPhys;
 752 }
 753 
 754 julong os::physical_memory() {
 755   return win32::physical_memory();
 756 }
 757 
 758 bool os::has_allocatable_memory_limit(julong* limit) {
 759   MEMORYSTATUSEX ms;
 760   ms.dwLength = sizeof(ms);
 761   GlobalMemoryStatusEx(&amp;ms);
 762 #ifdef _LP64
 763   *limit = (julong)ms.ullAvailVirtual;
 764   return true;
 765 #else
 766   // Limit to 1400m because of the 2gb address space wall
 767   *limit = MIN2((julong)1400*M, (julong)ms.ullAvailVirtual);
 768   return true;
 769 #endif
 770 }
 771 
 772 int os::active_processor_count() {
 773   // User has overridden the number of active processors
 774   if (ActiveProcessorCount &gt; 0) {
 775     log_trace(os)(&quot;active_processor_count: &quot;
 776                   &quot;active processor count set by user : %d&quot;,
 777                   ActiveProcessorCount);
 778     return ActiveProcessorCount;
 779   }
 780 
 781   DWORD_PTR lpProcessAffinityMask = 0;
 782   DWORD_PTR lpSystemAffinityMask = 0;
 783   int proc_count = processor_count();
 784   if (proc_count &lt;= sizeof(UINT_PTR) * BitsPerByte &amp;&amp;
 785       GetProcessAffinityMask(GetCurrentProcess(), &amp;lpProcessAffinityMask, &amp;lpSystemAffinityMask)) {
 786     // Nof active processors is number of bits in process affinity mask
 787     int bitcount = 0;
 788     while (lpProcessAffinityMask != 0) {
 789       lpProcessAffinityMask = lpProcessAffinityMask &amp; (lpProcessAffinityMask-1);
 790       bitcount++;
 791     }
 792     return bitcount;
 793   } else {
 794     return proc_count;
 795   }
 796 }
 797 
 798 uint os::processor_id() {
 799   return (uint)GetCurrentProcessorNumber();
 800 }
 801 
 802 void os::set_native_thread_name(const char *name) {
 803 
 804   // See: http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
 805   //
 806   // Note that unfortunately this only works if the process
 807   // is already attached to a debugger; debugger must observe
 808   // the exception below to show the correct name.
 809 
 810   // If there is no debugger attached skip raising the exception
 811   if (!IsDebuggerPresent()) {
 812     return;
 813   }
 814 
 815   const DWORD MS_VC_EXCEPTION = 0x406D1388;
 816   struct {
 817     DWORD dwType;     // must be 0x1000
 818     LPCSTR szName;    // pointer to name (in user addr space)
 819     DWORD dwThreadID; // thread ID (-1=caller thread)
 820     DWORD dwFlags;    // reserved for future use, must be zero
 821   } info;
 822 
 823   info.dwType = 0x1000;
 824   info.szName = name;
 825   info.dwThreadID = -1;
 826   info.dwFlags = 0;
 827 
 828   __try {
 829     RaiseException (MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(DWORD), (const ULONG_PTR*)&amp;info );
 830   } __except(EXCEPTION_EXECUTE_HANDLER) {}
 831 }
 832 
 833 bool os::bind_to_processor(uint processor_id) {
 834   // Not yet implemented.
 835   return false;
 836 }
 837 
 838 void os::win32::initialize_performance_counter() {
 839   LARGE_INTEGER count;
 840   QueryPerformanceFrequency(&amp;count);
 841   performance_frequency = as_long(count);
 842   QueryPerformanceCounter(&amp;count);
 843   initial_performance_count = as_long(count);
 844 }
 845 
 846 
 847 double os::elapsedTime() {
 848   return (double) elapsed_counter() / (double) elapsed_frequency();
 849 }
 850 
 851 
 852 // Windows format:
 853 //   The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.
 854 // Java format:
 855 //   Java standards require the number of milliseconds since 1/1/1970
 856 
 857 // Constant offset - calculated using offset()
 858 static jlong  _offset   = 116444736000000000;
 859 // Fake time counter for reproducible results when debugging
 860 static jlong  fake_time = 0;
 861 
 862 #ifdef ASSERT
 863 // Just to be safe, recalculate the offset in debug mode
 864 static jlong _calculated_offset = 0;
 865 static int   _has_calculated_offset = 0;
 866 
 867 jlong offset() {
 868   if (_has_calculated_offset) return _calculated_offset;
 869   SYSTEMTIME java_origin;
 870   java_origin.wYear          = 1970;
 871   java_origin.wMonth         = 1;
 872   java_origin.wDayOfWeek     = 0; // ignored
 873   java_origin.wDay           = 1;
 874   java_origin.wHour          = 0;
 875   java_origin.wMinute        = 0;
 876   java_origin.wSecond        = 0;
 877   java_origin.wMilliseconds  = 0;
 878   FILETIME jot;
 879   if (!SystemTimeToFileTime(&amp;java_origin, &amp;jot)) {
 880     fatal(&quot;Error = %d\nWindows error&quot;, GetLastError());
 881   }
 882   _calculated_offset = jlong_from(jot.dwHighDateTime, jot.dwLowDateTime);
 883   _has_calculated_offset = 1;
 884   assert(_calculated_offset == _offset, &quot;Calculated and constant time offsets must be equal&quot;);
 885   return _calculated_offset;
 886 }
 887 #else
 888 jlong offset() {
 889   return _offset;
 890 }
 891 #endif
 892 
 893 jlong windows_to_java_time(FILETIME wt) {
 894   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 895   return (a - offset()) / 10000;
 896 }
 897 
 898 // Returns time ticks in (10th of micro seconds)
 899 jlong windows_to_time_ticks(FILETIME wt) {
 900   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 901   return (a - offset());
 902 }
 903 
 904 FILETIME java_to_windows_time(jlong l) {
 905   jlong a = (l * 10000) + offset();
 906   FILETIME result;
 907   result.dwHighDateTime = high(a);
 908   result.dwLowDateTime  = low(a);
 909   return result;
 910 }
 911 
 912 bool os::supports_vtime() { return true; }
 913 
 914 double os::elapsedVTime() {
 915   FILETIME created;
 916   FILETIME exited;
 917   FILETIME kernel;
 918   FILETIME user;
 919   if (GetThreadTimes(GetCurrentThread(), &amp;created, &amp;exited, &amp;kernel, &amp;user) != 0) {
 920     // the resolution of windows_to_java_time() should be sufficient (ms)
 921     return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) / MILLIUNITS;
 922   } else {
 923     return elapsedTime();
 924   }
 925 }
 926 
 927 jlong os::javaTimeMillis() {
 928   FILETIME wt;
 929   GetSystemTimeAsFileTime(&amp;wt);
 930   return windows_to_java_time(wt);
 931 }
 932 
 933 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
 934   FILETIME wt;
 935   GetSystemTimeAsFileTime(&amp;wt);
 936   jlong ticks = windows_to_time_ticks(wt); // 10th of micros
 937   jlong secs = jlong(ticks / 10000000); // 10000 * 1000
 938   seconds = secs;
 939   nanos = jlong(ticks - (secs*10000000)) * 100;
 940 }
 941 
 942 jlong os::javaTimeNanos() {
 943     LARGE_INTEGER current_count;
 944     QueryPerformanceCounter(&amp;current_count);
 945     double current = as_long(current_count);
 946     double freq = performance_frequency;
 947     jlong time = (jlong)((current/freq) * NANOSECS_PER_SEC);
 948     return time;
 949 }
 950 
 951 void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {
 952   jlong freq = performance_frequency;
 953   if (freq &lt; NANOSECS_PER_SEC) {
 954     // the performance counter is 64 bits and we will
 955     // be multiplying it -- so no wrap in 64 bits
 956     info_ptr-&gt;max_value = ALL_64_BITS;
 957   } else if (freq &gt; NANOSECS_PER_SEC) {
 958     // use the max value the counter can reach to
 959     // determine the max value which could be returned
 960     julong max_counter = (julong)ALL_64_BITS;
 961     info_ptr-&gt;max_value = (jlong)(max_counter / (freq / NANOSECS_PER_SEC));
 962   } else {
 963     // the performance counter is 64 bits and we will
 964     // be using it directly -- so no wrap in 64 bits
 965     info_ptr-&gt;max_value = ALL_64_BITS;
 966   }
 967 
 968   // using a counter, so no skipping
 969   info_ptr-&gt;may_skip_backward = false;
 970   info_ptr-&gt;may_skip_forward = false;
 971 
 972   info_ptr-&gt;kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time
 973 }
 974 
 975 char* os::local_time_string(char *buf, size_t buflen) {
 976   SYSTEMTIME st;
 977   GetLocalTime(&amp;st);
 978   jio_snprintf(buf, buflen, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,
 979                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
 980   return buf;
 981 }
 982 
 983 bool os::getTimesSecs(double* process_real_time,
 984                       double* process_user_time,
 985                       double* process_system_time) {
 986   HANDLE h_process = GetCurrentProcess();
 987   FILETIME create_time, exit_time, kernel_time, user_time;
 988   BOOL result = GetProcessTimes(h_process,
 989                                 &amp;create_time,
 990                                 &amp;exit_time,
 991                                 &amp;kernel_time,
 992                                 &amp;user_time);
 993   if (result != 0) {
 994     FILETIME wt;
 995     GetSystemTimeAsFileTime(&amp;wt);
 996     jlong rtc_millis = windows_to_java_time(wt);
 997     *process_real_time = ((double) rtc_millis) / ((double) MILLIUNITS);
 998     *process_user_time =
 999       (double) jlong_from(user_time.dwHighDateTime, user_time.dwLowDateTime) / (10 * MICROUNITS);
1000     *process_system_time =
1001       (double) jlong_from(kernel_time.dwHighDateTime, kernel_time.dwLowDateTime) / (10 * MICROUNITS);
1002     return true;
1003   } else {
1004     return false;
1005   }
1006 }
1007 
1008 void os::shutdown() {
1009   // allow PerfMemory to attempt cleanup of any persistent resources
1010   perfMemory_exit();
1011 
1012   // flush buffered output, finish log files
1013   ostream_abort();
1014 
1015   // Check for abort hook
1016   abort_hook_t abort_hook = Arguments::abort_hook();
1017   if (abort_hook != NULL) {
1018     abort_hook();
1019   }
1020 }
1021 
1022 
1023 static HANDLE dumpFile = NULL;
1024 
1025 // Check if dump file can be created.
1026 void os::check_dump_limit(char* buffer, size_t buffsz) {
1027   bool status = true;
1028   if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) &amp;&amp; !CreateCoredumpOnCrash) {
1029     jio_snprintf(buffer, buffsz, &quot;CreateCoredumpOnCrash is disabled from command line&quot;);
1030     status = false;
1031   }
1032 
1033 #ifndef ASSERT
1034   if (!os::win32::is_windows_server() &amp;&amp; FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {
1035     jio_snprintf(buffer, buffsz, &quot;Minidumps are not enabled by default on client versions of Windows&quot;);
1036     status = false;
1037   }
1038 #endif
1039 
1040   if (status) {
1041     const char* cwd = get_current_directory(NULL, 0);
1042     int pid = current_process_id();
1043     if (cwd != NULL) {
1044       jio_snprintf(buffer, buffsz, &quot;%s\\hs_err_pid%u.mdmp&quot;, cwd, pid);
1045     } else {
1046       jio_snprintf(buffer, buffsz, &quot;.\\hs_err_pid%u.mdmp&quot;, pid);
1047     }
1048 
1049     if (dumpFile == NULL &amp;&amp;
1050        (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
1051                  == INVALID_HANDLE_VALUE) {
1052       jio_snprintf(buffer, buffsz, &quot;Failed to create minidump file (0x%x).&quot;, GetLastError());
1053       status = false;
1054     }
1055   }
1056   VMError::record_coredump_status(buffer, status);
1057 }
1058 
1059 void os::abort(bool dump_core, void* siginfo, const void* context) {
1060   EXCEPTION_POINTERS ep;
1061   MINIDUMP_EXCEPTION_INFORMATION mei;
1062   MINIDUMP_EXCEPTION_INFORMATION* pmei;
1063 
1064   HANDLE hProcess = GetCurrentProcess();
1065   DWORD processId = GetCurrentProcessId();
1066   MINIDUMP_TYPE dumpType;
1067 
1068   shutdown();
1069   if (!dump_core || dumpFile == NULL) {
1070     if (dumpFile != NULL) {
1071       CloseHandle(dumpFile);
1072     }
1073     win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1074   }
1075 
1076   dumpType = (MINIDUMP_TYPE)(MiniDumpWithFullMemory | MiniDumpWithHandleData |
1077     MiniDumpWithFullMemoryInfo | MiniDumpWithThreadInfo | MiniDumpWithUnloadedModules);
1078 
1079   if (siginfo != NULL &amp;&amp; context != NULL) {
1080     ep.ContextRecord = (PCONTEXT) context;
1081     ep.ExceptionRecord = (PEXCEPTION_RECORD) siginfo;
1082 
1083     mei.ThreadId = GetCurrentThreadId();
1084     mei.ExceptionPointers = &amp;ep;
1085     pmei = &amp;mei;
1086   } else {
1087     pmei = NULL;
1088   }
1089 
1090   // Older versions of dbghelp.dll (the one shipped with Win2003 for example) may not support all
1091   // the dump types we really want. If first call fails, lets fall back to just use MiniDumpWithFullMemory then.
1092   if (!WindowsDbgHelp::miniDumpWriteDump(hProcess, processId, dumpFile, dumpType, pmei, NULL, NULL) &amp;&amp;
1093       !WindowsDbgHelp::miniDumpWriteDump(hProcess, processId, dumpFile, (MINIDUMP_TYPE)MiniDumpWithFullMemory, pmei, NULL, NULL)) {
1094     jio_fprintf(stderr, &quot;Call to MiniDumpWriteDump() failed (Error 0x%x)\n&quot;, GetLastError());
1095   }
1096   CloseHandle(dumpFile);
1097   win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1098 }
1099 
1100 // Die immediately, no exit hook, no abort hook, no cleanup.
1101 void os::die() {
1102   win32::exit_process_or_thread(win32::EPT_PROCESS_DIE, -1);
1103 }
1104 
1105 // Directory routines copied from src/win32/native/java/io/dirent_md.c
1106 //  * dirent_md.c       1.15 00/02/02
1107 //
1108 // The declarations for DIR and struct dirent are in jvm_win32.h.
1109 
1110 // Caller must have already run dirname through JVM_NativePath, which removes
1111 // duplicate slashes and converts all instances of &#39;/&#39; into &#39;\\&#39;.
1112 
1113 DIR * os::opendir(const char *dirname) {
1114   assert(dirname != NULL, &quot;just checking&quot;);   // hotspot change
1115   DIR *dirp = (DIR *)malloc(sizeof(DIR), mtInternal);
1116   DWORD fattr;                                // hotspot change
1117   char alt_dirname[4] = { 0, 0, 0, 0 };
1118 
1119   if (dirp == 0) {
1120     errno = ENOMEM;
1121     return 0;
1122   }
1123 
1124   // Win32 accepts &quot;\&quot; in its POSIX stat(), but refuses to treat it
1125   // as a directory in FindFirstFile().  We detect this case here and
1126   // prepend the current drive name.
1127   //
1128   if (dirname[1] == &#39;\0&#39; &amp;&amp; dirname[0] == &#39;\\&#39;) {
1129     alt_dirname[0] = _getdrive() + &#39;A&#39; - 1;
1130     alt_dirname[1] = &#39;:&#39;;
1131     alt_dirname[2] = &#39;\\&#39;;
1132     alt_dirname[3] = &#39;\0&#39;;
1133     dirname = alt_dirname;
1134   }
1135 
1136   dirp-&gt;path = (char *)malloc(strlen(dirname) + 5, mtInternal);
1137   if (dirp-&gt;path == 0) {
1138     free(dirp);
1139     errno = ENOMEM;
1140     return 0;
1141   }
1142   strcpy(dirp-&gt;path, dirname);
1143 
1144   fattr = GetFileAttributes(dirp-&gt;path);
1145   if (fattr == 0xffffffff) {
1146     free(dirp-&gt;path);
1147     free(dirp);
1148     errno = ENOENT;
1149     return 0;
1150   } else if ((fattr &amp; FILE_ATTRIBUTE_DIRECTORY) == 0) {
1151     free(dirp-&gt;path);
1152     free(dirp);
1153     errno = ENOTDIR;
1154     return 0;
1155   }
1156 
1157   // Append &quot;*.*&quot;, or possibly &quot;\\*.*&quot;, to path
1158   if (dirp-&gt;path[1] == &#39;:&#39; &amp;&amp;
1159       (dirp-&gt;path[2] == &#39;\0&#39; ||
1160       (dirp-&gt;path[2] == &#39;\\&#39; &amp;&amp; dirp-&gt;path[3] == &#39;\0&#39;))) {
1161     // No &#39;\\&#39; needed for cases like &quot;Z:&quot; or &quot;Z:\&quot;
1162     strcat(dirp-&gt;path, &quot;*.*&quot;);
1163   } else {
1164     strcat(dirp-&gt;path, &quot;\\*.*&quot;);
1165   }
1166 
1167   dirp-&gt;handle = FindFirstFile(dirp-&gt;path, &amp;dirp-&gt;find_data);
1168   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1169     if (GetLastError() != ERROR_FILE_NOT_FOUND) {
1170       free(dirp-&gt;path);
1171       free(dirp);
1172       errno = EACCES;
1173       return 0;
1174     }
1175   }
1176   return dirp;
1177 }
1178 
1179 struct dirent * os::readdir(DIR *dirp) {
1180   assert(dirp != NULL, &quot;just checking&quot;);      // hotspot change
1181   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1182     return NULL;
1183   }
1184 
1185   strcpy(dirp-&gt;dirent.d_name, dirp-&gt;find_data.cFileName);
1186 
1187   if (!FindNextFile(dirp-&gt;handle, &amp;dirp-&gt;find_data)) {
1188     if (GetLastError() == ERROR_INVALID_HANDLE) {
1189       errno = EBADF;
1190       return NULL;
1191     }
1192     FindClose(dirp-&gt;handle);
1193     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1194   }
1195 
1196   return &amp;dirp-&gt;dirent;
1197 }
1198 
1199 int os::closedir(DIR *dirp) {
1200   assert(dirp != NULL, &quot;just checking&quot;);      // hotspot change
1201   if (dirp-&gt;handle != INVALID_HANDLE_VALUE) {
1202     if (!FindClose(dirp-&gt;handle)) {
1203       errno = EBADF;
1204       return -1;
1205     }
1206     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1207   }
1208   free(dirp-&gt;path);
1209   free(dirp);
1210   return 0;
1211 }
1212 
1213 // This must be hard coded because it&#39;s the system&#39;s temporary
1214 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1215 const char* os::get_temp_directory() {
1216   static char path_buf[MAX_PATH];
1217   if (GetTempPath(MAX_PATH, path_buf) &gt; 0) {
1218     return path_buf;
1219   } else {
1220     path_buf[0] = &#39;\0&#39;;
1221     return path_buf;
1222   }
1223 }
1224 
1225 // Needs to be in os specific directory because windows requires another
1226 // header file &lt;direct.h&gt;
1227 const char* os::get_current_directory(char *buf, size_t buflen) {
1228   int n = static_cast&lt;int&gt;(buflen);
1229   if (buflen &gt; INT_MAX)  n = INT_MAX;
1230   return _getcwd(buf, n);
1231 }
1232 
1233 //-----------------------------------------------------------
1234 // Helper functions for fatal error handler
1235 #ifdef _WIN64
1236 // Helper routine which returns true if address in
1237 // within the NTDLL address space.
1238 //
1239 static bool _addr_in_ntdll(address addr) {
1240   HMODULE hmod;
1241   MODULEINFO minfo;
1242 
1243   hmod = GetModuleHandle(&quot;NTDLL.DLL&quot;);
1244   if (hmod == NULL) return false;
1245   if (!GetModuleInformation(GetCurrentProcess(), hmod,
1246                                           &amp;minfo, sizeof(MODULEINFO))) {
1247     return false;
1248   }
1249 
1250   if ((addr &gt;= minfo.lpBaseOfDll) &amp;&amp;
1251       (addr &lt; (address)((uintptr_t)minfo.lpBaseOfDll + (uintptr_t)minfo.SizeOfImage))) {
1252     return true;
1253   } else {
1254     return false;
1255   }
1256 }
1257 #endif
1258 
1259 struct _modinfo {
1260   address addr;
1261   char*   full_path;   // point to a char buffer
1262   int     buflen;      // size of the buffer
1263   address base_addr;
1264 };
1265 
1266 static int _locate_module_by_addr(const char * mod_fname, address base_addr,
1267                                   address top_address, void * param) {
1268   struct _modinfo *pmod = (struct _modinfo *)param;
1269   if (!pmod) return -1;
1270 
1271   if (base_addr   &lt;= pmod-&gt;addr &amp;&amp;
1272       top_address &gt; pmod-&gt;addr) {
1273     // if a buffer is provided, copy path name to the buffer
1274     if (pmod-&gt;full_path) {
1275       jio_snprintf(pmod-&gt;full_path, pmod-&gt;buflen, &quot;%s&quot;, mod_fname);
1276     }
1277     pmod-&gt;base_addr = base_addr;
1278     return 1;
1279   }
1280   return 0;
1281 }
1282 
1283 bool os::dll_address_to_library_name(address addr, char* buf,
1284                                      int buflen, int* offset) {
1285   // buf is not optional, but offset is optional
1286   assert(buf != NULL, &quot;sanity check&quot;);
1287 
1288 // NOTE: the reason we don&#39;t use SymGetModuleInfo() is it doesn&#39;t always
1289 //       return the full path to the DLL file, sometimes it returns path
1290 //       to the corresponding PDB file (debug info); sometimes it only
1291 //       returns partial path, which makes life painful.
1292 
1293   struct _modinfo mi;
1294   mi.addr      = addr;
1295   mi.full_path = buf;
1296   mi.buflen    = buflen;
1297   if (get_loaded_modules_info(_locate_module_by_addr, (void *)&amp;mi)) {
1298     // buf already contains path name
1299     if (offset) *offset = addr - mi.base_addr;
1300     return true;
1301   }
1302 
1303   buf[0] = &#39;\0&#39;;
1304   if (offset) *offset = -1;
1305   return false;
1306 }
1307 
1308 bool os::dll_address_to_function_name(address addr, char *buf,
1309                                       int buflen, int *offset,
1310                                       bool demangle) {
1311   // buf is not optional, but offset is optional
1312   assert(buf != NULL, &quot;sanity check&quot;);
1313 
1314   if (Decoder::decode(addr, buf, buflen, offset, demangle)) {
1315     return true;
1316   }
1317   if (offset != NULL)  *offset  = -1;
1318   buf[0] = &#39;\0&#39;;
1319   return false;
1320 }
1321 
1322 // save the start and end address of jvm.dll into param[0] and param[1]
1323 static int _locate_jvm_dll(const char* mod_fname, address base_addr,
1324                            address top_address, void * param) {
1325   if (!param) return -1;
1326 
1327   if (base_addr   &lt;= (address)_locate_jvm_dll &amp;&amp;
1328       top_address &gt; (address)_locate_jvm_dll) {
1329     ((address*)param)[0] = base_addr;
1330     ((address*)param)[1] = top_address;
1331     return 1;
1332   }
1333   return 0;
1334 }
1335 
1336 address vm_lib_location[2];    // start and end address of jvm.dll
1337 
1338 // check if addr is inside jvm.dll
1339 bool os::address_is_in_vm(address addr) {
1340   if (!vm_lib_location[0] || !vm_lib_location[1]) {
1341     if (!get_loaded_modules_info(_locate_jvm_dll, (void *)vm_lib_location)) {
1342       assert(false, &quot;Can&#39;t find jvm module.&quot;);
1343       return false;
1344     }
1345   }
1346 
1347   return (vm_lib_location[0] &lt;= addr) &amp;&amp; (addr &lt; vm_lib_location[1]);
1348 }
1349 
1350 // print module info; param is outputStream*
1351 static int _print_module(const char* fname, address base_address,
1352                          address top_address, void* param) {
1353   if (!param) return -1;
1354 
1355   outputStream* st = (outputStream*)param;
1356 
1357   st-&gt;print(PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; \t%s\n&quot;, base_address, top_address, fname);
1358   return 0;
1359 }
1360 
1361 // Loads .dll/.so and
1362 // in case of error it checks if .dll/.so was built for the
1363 // same architecture as Hotspot is running on
1364 void * os::dll_load(const char *name, char *ebuf, int ebuflen) {
1365   log_info(os)(&quot;attempting shared library load of %s&quot;, name);
1366 
1367   void * result = LoadLibrary(name);
1368   if (result != NULL) {
1369     Events::log(NULL, &quot;Loaded shared library %s&quot;, name);
1370     // Recalculate pdb search path if a DLL was loaded successfully.
1371     SymbolEngine::recalc_search_path();
1372     log_info(os)(&quot;shared library load of %s was successful&quot;, name);
1373     return result;
1374   }
1375   DWORD errcode = GetLastError();
1376   // Read system error message into ebuf
1377   // It may or may not be overwritten below (in the for loop and just above)
1378   lasterror(ebuf, (size_t) ebuflen);
1379   ebuf[ebuflen - 1] = &#39;\0&#39;;
1380   Events::log(NULL, &quot;Loading shared library %s failed, error code %lu&quot;, name, errcode);
1381   log_info(os)(&quot;shared library load of %s failed, error code %lu&quot;, name, errcode);
1382 
1383   if (errcode == ERROR_MOD_NOT_FOUND) {
1384     strncpy(ebuf, &quot;Can&#39;t find dependent libraries&quot;, ebuflen - 1);
1385     ebuf[ebuflen - 1] = &#39;\0&#39;;
1386     return NULL;
1387   }
1388 
1389   // Parsing dll below
1390   // If we can read dll-info and find that dll was built
1391   // for an architecture other than Hotspot is running in
1392   // - then print to buffer &quot;DLL was built for a different architecture&quot;
1393   // else call os::lasterror to obtain system error message
1394   int fd = ::open(name, O_RDONLY | O_BINARY, 0);
1395   if (fd &lt; 0) {
1396     return NULL;
1397   }
1398 
1399   uint32_t signature_offset;
1400   uint16_t lib_arch = 0;
1401   bool failed_to_get_lib_arch =
1402     ( // Go to position 3c in the dll
1403      (os::seek_to_file_offset(fd, IMAGE_FILE_PTR_TO_SIGNATURE) &lt; 0)
1404      ||
1405      // Read location of signature
1406      (sizeof(signature_offset) !=
1407      (os::read(fd, (void*)&amp;signature_offset, sizeof(signature_offset))))
1408      ||
1409      // Go to COFF File Header in dll
1410      // that is located after &quot;signature&quot; (4 bytes long)
1411      (os::seek_to_file_offset(fd,
1412      signature_offset + IMAGE_FILE_SIGNATURE_LENGTH) &lt; 0)
1413      ||
1414      // Read field that contains code of architecture
1415      // that dll was built for
1416      (sizeof(lib_arch) != (os::read(fd, (void*)&amp;lib_arch, sizeof(lib_arch))))
1417     );
1418 
1419   ::close(fd);
1420   if (failed_to_get_lib_arch) {
1421     // file i/o error - report os::lasterror(...) msg
1422     return NULL;
1423   }
1424 
1425   typedef struct {
1426     uint16_t arch_code;
1427     char* arch_name;
1428   } arch_t;
1429 
1430   static const arch_t arch_array[] = {
1431     {IMAGE_FILE_MACHINE_I386,      (char*)&quot;IA 32&quot;},
<a name="9" id="anc9"></a><span class="line-modified">1432     {IMAGE_FILE_MACHINE_AMD64,     (char*)&quot;AMD 64&quot;}</span>

1433   };
1434 #if (defined _M_AMD64)
1435   static const uint16_t running_arch = IMAGE_FILE_MACHINE_AMD64;
1436 #elif (defined _M_IX86)
1437   static const uint16_t running_arch = IMAGE_FILE_MACHINE_I386;
<a name="10" id="anc10"></a>

1438 #else
1439   #error Method os::dll_load requires that one of following \
<a name="11" id="anc11"></a><span class="line-modified">1440          is defined :_M_AMD64 or _M_IX86</span>
1441 #endif
1442 
1443 
1444   // Obtain a string for printf operation
1445   // lib_arch_str shall contain string what platform this .dll was built for
1446   // running_arch_str shall string contain what platform Hotspot was built for
1447   char *running_arch_str = NULL, *lib_arch_str = NULL;
1448   for (unsigned int i = 0; i &lt; ARRAY_SIZE(arch_array); i++) {
1449     if (lib_arch == arch_array[i].arch_code) {
1450       lib_arch_str = arch_array[i].arch_name;
1451     }
1452     if (running_arch == arch_array[i].arch_code) {
1453       running_arch_str = arch_array[i].arch_name;
1454     }
1455   }
1456 
1457   assert(running_arch_str,
1458          &quot;Didn&#39;t find running architecture code in arch_array&quot;);
1459 
1460   // If the architecture is right
1461   // but some other error took place - report os::lasterror(...) msg
1462   if (lib_arch == running_arch) {
1463     return NULL;
1464   }
1465 
1466   if (lib_arch_str != NULL) {
1467     ::_snprintf(ebuf, ebuflen - 1,
1468                 &quot;Can&#39;t load %s-bit .dll on a %s-bit platform&quot;,
1469                 lib_arch_str, running_arch_str);
1470   } else {
1471     // don&#39;t know what architecture this dll was build for
1472     ::_snprintf(ebuf, ebuflen - 1,
1473                 &quot;Can&#39;t load this .dll (machine code=0x%x) on a %s-bit platform&quot;,
1474                 lib_arch, running_arch_str);
1475   }
1476 
1477   return NULL;
1478 }
1479 
1480 void os::print_dll_info(outputStream *st) {
1481   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
1482   get_loaded_modules_info(_print_module, (void *)st);
1483 }
1484 
1485 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1486   HANDLE   hProcess;
1487 
1488 # define MAX_NUM_MODULES 128
1489   HMODULE     modules[MAX_NUM_MODULES];
1490   static char filename[MAX_PATH];
1491   int         result = 0;
1492 
1493   int pid = os::current_process_id();
1494   hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
1495                          FALSE, pid);
1496   if (hProcess == NULL) return 0;
1497 
1498   DWORD size_needed;
1499   if (!EnumProcessModules(hProcess, modules, sizeof(modules), &amp;size_needed)) {
1500     CloseHandle(hProcess);
1501     return 0;
1502   }
1503 
1504   // number of modules that are currently loaded
1505   int num_modules = size_needed / sizeof(HMODULE);
1506 
1507   for (int i = 0; i &lt; MIN2(num_modules, MAX_NUM_MODULES); i++) {
1508     // Get Full pathname:
1509     if (!GetModuleFileNameEx(hProcess, modules[i], filename, sizeof(filename))) {
1510       filename[0] = &#39;\0&#39;;
1511     }
1512 
1513     MODULEINFO modinfo;
1514     if (!GetModuleInformation(hProcess, modules[i], &amp;modinfo, sizeof(modinfo))) {
1515       modinfo.lpBaseOfDll = NULL;
1516       modinfo.SizeOfImage = 0;
1517     }
1518 
1519     // Invoke callback function
1520     result = callback(filename, (address)modinfo.lpBaseOfDll,
1521                       (address)((u8)modinfo.lpBaseOfDll + (u8)modinfo.SizeOfImage), param);
1522     if (result) break;
1523   }
1524 
1525   CloseHandle(hProcess);
1526   return result;
1527 }
1528 
1529 bool os::get_host_name(char* buf, size_t buflen) {
1530   DWORD size = (DWORD)buflen;
1531   return (GetComputerNameEx(ComputerNameDnsHostname, buf, &amp;size) == TRUE);
1532 }
1533 
1534 void os::get_summary_os_info(char* buf, size_t buflen) {
1535   stringStream sst(buf, buflen);
1536   os::win32::print_windows_version(&amp;sst);
1537   // chop off newline character
1538   char* nl = strchr(buf, &#39;\n&#39;);
1539   if (nl != NULL) *nl = &#39;\0&#39;;
1540 }
1541 
1542 int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {
1543 #if _MSC_VER &gt;= 1900
1544   // Starting with Visual Studio 2015, vsnprint is C99 compliant.
1545   int result = ::vsnprintf(buf, len, fmt, args);
1546   // If an encoding error occurred (result &lt; 0) then it&#39;s not clear
1547   // whether the buffer is NUL terminated, so ensure it is.
1548   if ((result &lt; 0) &amp;&amp; (len &gt; 0)) {
1549     buf[len - 1] = &#39;\0&#39;;
1550   }
1551   return result;
1552 #else
1553   // Before Visual Studio 2015, vsnprintf is not C99 compliant, so use
1554   // _vsnprintf, whose behavior seems to be *mostly* consistent across
1555   // versions.  However, when len == 0, avoid _vsnprintf too, and just
1556   // go straight to _vscprintf.  The output is going to be truncated in
1557   // that case, except in the unusual case of empty output.  More
1558   // importantly, the documentation for various versions of Visual Studio
1559   // are inconsistent about the behavior of _vsnprintf when len == 0,
1560   // including it possibly being an error.
1561   int result = -1;
1562   if (len &gt; 0) {
1563     result = _vsnprintf(buf, len, fmt, args);
1564     // If output (including NUL terminator) is truncated, the buffer
1565     // won&#39;t be NUL terminated.  Add the trailing NUL specified by C99.
1566     if ((result &lt; 0) || ((size_t)result &gt;= len)) {
1567       buf[len - 1] = &#39;\0&#39;;
1568     }
1569   }
1570   if (result &lt; 0) {
1571     result = _vscprintf(fmt, args);
1572   }
1573   return result;
1574 #endif // _MSC_VER dispatch
1575 }
1576 
1577 static inline time_t get_mtime(const char* filename) {
1578   struct stat st;
1579   int ret = os::stat(filename, &amp;st);
1580   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
1581   return st.st_mtime;
1582 }
1583 
1584 int os::compare_file_modified_times(const char* file1, const char* file2) {
1585   time_t t1 = get_mtime(file1);
1586   time_t t2 = get_mtime(file2);
1587   return t1 - t2;
1588 }
1589 
1590 void os::print_os_info_brief(outputStream* st) {
1591   os::print_os_info(st);
1592 }
1593 
1594 void os::win32::print_uptime_info(outputStream* st) {
1595   unsigned long long ticks = GetTickCount64();
1596   os::print_dhm(st, &quot;OS uptime:&quot;, ticks/1000);
1597 }
1598 
1599 void os::print_os_info(outputStream* st) {
1600 #ifdef ASSERT
1601   char buffer[1024];
1602   st-&gt;print(&quot;HostName: &quot;);
1603   if (get_host_name(buffer, sizeof(buffer))) {
1604     st-&gt;print(&quot;%s &quot;, buffer);
1605   } else {
1606     st-&gt;print(&quot;N/A &quot;);
1607   }
1608 #endif
1609   st-&gt;print(&quot;OS:&quot;);
1610   os::win32::print_windows_version(st);
1611 
1612   os::win32::print_uptime_info(st);
1613 
1614 #ifdef _LP64
1615   VM_Version::print_platform_virtualization_info(st);
1616 #endif
1617 }
1618 
1619 void os::win32::print_windows_version(outputStream* st) {
1620   OSVERSIONINFOEX osvi;
1621   VS_FIXEDFILEINFO *file_info;
1622   TCHAR kernel32_path[MAX_PATH];
1623   UINT len, ret;
1624 
1625   // Use the GetVersionEx information to see if we&#39;re on a server or
1626   // workstation edition of Windows. Starting with Windows 8.1 we can&#39;t
1627   // trust the OS version information returned by this API.
1628   ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
1629   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
1630   if (!GetVersionEx((OSVERSIONINFO *)&amp;osvi)) {
1631     st-&gt;print_cr(&quot;Call to GetVersionEx failed&quot;);
1632     return;
1633   }
1634   bool is_workstation = (osvi.wProductType == VER_NT_WORKSTATION);
1635 
1636   // Get the full path to \Windows\System32\kernel32.dll and use that for
1637   // determining what version of Windows we&#39;re running on.
1638   len = MAX_PATH - (UINT)strlen(&quot;\\kernel32.dll&quot;) - 1;
1639   ret = GetSystemDirectory(kernel32_path, len);
1640   if (ret == 0 || ret &gt; len) {
1641     st-&gt;print_cr(&quot;Call to GetSystemDirectory failed&quot;);
1642     return;
1643   }
1644   strncat(kernel32_path, &quot;\\kernel32.dll&quot;, MAX_PATH - ret);
1645 
1646   DWORD version_size = GetFileVersionInfoSize(kernel32_path, NULL);
1647   if (version_size == 0) {
1648     st-&gt;print_cr(&quot;Call to GetFileVersionInfoSize failed&quot;);
1649     return;
1650   }
1651 
1652   LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);
1653   if (version_info == NULL) {
1654     st-&gt;print_cr(&quot;Failed to allocate version_info&quot;);
1655     return;
1656   }
1657 
1658   if (!GetFileVersionInfo(kernel32_path, NULL, version_size, version_info)) {
1659     os::free(version_info);
1660     st-&gt;print_cr(&quot;Call to GetFileVersionInfo failed&quot;);
1661     return;
1662   }
1663 
1664   if (!VerQueryValue(version_info, TEXT(&quot;\\&quot;), (LPVOID*)&amp;file_info, &amp;len)) {
1665     os::free(version_info);
1666     st-&gt;print_cr(&quot;Call to VerQueryValue failed&quot;);
1667     return;
1668   }
1669 
1670   int major_version = HIWORD(file_info-&gt;dwProductVersionMS);
1671   int minor_version = LOWORD(file_info-&gt;dwProductVersionMS);
1672   int build_number = HIWORD(file_info-&gt;dwProductVersionLS);
1673   int build_minor = LOWORD(file_info-&gt;dwProductVersionLS);
1674   int os_vers = major_version * 1000 + minor_version;
1675   os::free(version_info);
1676 
1677   st-&gt;print(&quot; Windows &quot;);
1678   switch (os_vers) {
1679 
1680   case 6000:
1681     if (is_workstation) {
1682       st-&gt;print(&quot;Vista&quot;);
1683     } else {
1684       st-&gt;print(&quot;Server 2008&quot;);
1685     }
1686     break;
1687 
1688   case 6001:
1689     if (is_workstation) {
1690       st-&gt;print(&quot;7&quot;);
1691     } else {
1692       st-&gt;print(&quot;Server 2008 R2&quot;);
1693     }
1694     break;
1695 
1696   case 6002:
1697     if (is_workstation) {
1698       st-&gt;print(&quot;8&quot;);
1699     } else {
1700       st-&gt;print(&quot;Server 2012&quot;);
1701     }
1702     break;
1703 
1704   case 6003:
1705     if (is_workstation) {
1706       st-&gt;print(&quot;8.1&quot;);
1707     } else {
1708       st-&gt;print(&quot;Server 2012 R2&quot;);
1709     }
1710     break;
1711 
1712   case 10000:
1713     if (is_workstation) {
1714       st-&gt;print(&quot;10&quot;);
1715     } else {
1716       // distinguish Windows Server 2016 and 2019 by build number
1717       // Windows server 2019 GA 10/2018 build number is 17763
1718       if (build_number &gt; 17762) {
1719         st-&gt;print(&quot;Server 2019&quot;);
1720       } else {
1721         st-&gt;print(&quot;Server 2016&quot;);
1722       }
1723     }
1724     break;
1725 
1726   default:
1727     // Unrecognized windows, print out its major and minor versions
1728     st-&gt;print(&quot;%d.%d&quot;, major_version, minor_version);
1729     break;
1730   }
1731 
1732   // Retrieve SYSTEM_INFO from GetNativeSystemInfo call so that we could
1733   // find out whether we are running on 64 bit processor or not
1734   SYSTEM_INFO si;
1735   ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
1736   GetNativeSystemInfo(&amp;si);
<a name="12" id="anc12"></a><span class="line-modified">1737   if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {</span>

1738     st-&gt;print(&quot; , 64 bit&quot;);
1739   }
1740 
1741   st-&gt;print(&quot; Build %d&quot;, build_number);
1742   st-&gt;print(&quot; (%d.%d.%d.%d)&quot;, major_version, minor_version, build_number, build_minor);
1743   st-&gt;cr();
1744 }
1745 
1746 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1747   // Nothing to do for now.
1748 }
1749 
1750 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1751   HKEY key;
1752   DWORD status = RegOpenKey(HKEY_LOCAL_MACHINE,
1753                &quot;HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0&quot;, &amp;key);
1754   if (status == ERROR_SUCCESS) {
1755     DWORD size = (DWORD)buflen;
1756     status = RegQueryValueEx(key, &quot;ProcessorNameString&quot;, NULL, NULL, (byte*)buf, &amp;size);
1757     if (status != ERROR_SUCCESS) {
1758         strncpy(buf, &quot;## __CPU__&quot;, buflen);
1759     }
1760     RegCloseKey(key);
1761   } else {
1762     // Put generic cpu info to return
1763     strncpy(buf, &quot;## __CPU__&quot;, buflen);
1764   }
1765 }
1766 
1767 void os::print_memory_info(outputStream* st) {
1768   st-&gt;print(&quot;Memory:&quot;);
1769   st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
1770 
1771   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
1772   // value if total memory is larger than 4GB
1773   MEMORYSTATUSEX ms;
1774   ms.dwLength = sizeof(ms);
1775   int r1 = GlobalMemoryStatusEx(&amp;ms);
1776 
1777   if (r1 != 0) {
1778     st-&gt;print(&quot;, system-wide physical &quot; INT64_FORMAT &quot;M &quot;,
1779              (int64_t) ms.ullTotalPhys &gt;&gt; 20);
1780     st-&gt;print(&quot;(&quot; INT64_FORMAT &quot;M free)\n&quot;, (int64_t) ms.ullAvailPhys &gt;&gt; 20);
1781 
1782     st-&gt;print(&quot;TotalPageFile size &quot; INT64_FORMAT &quot;M &quot;,
1783              (int64_t) ms.ullTotalPageFile &gt;&gt; 20);
1784     st-&gt;print(&quot;(AvailPageFile size &quot; INT64_FORMAT &quot;M)&quot;,
1785              (int64_t) ms.ullAvailPageFile &gt;&gt; 20);
1786 
1787     // on 32bit Total/AvailVirtual are interesting (show us how close we get to 2-4 GB per process borders)
1788 #if defined(_M_IX86)
1789     st-&gt;print(&quot;, user-mode portion of virtual address-space &quot; INT64_FORMAT &quot;M &quot;,
1790              (int64_t) ms.ullTotalVirtual &gt;&gt; 20);
1791     st-&gt;print(&quot;(&quot; INT64_FORMAT &quot;M free)&quot;, (int64_t) ms.ullAvailVirtual &gt;&gt; 20);
1792 #endif
1793   } else {
1794     st-&gt;print(&quot;, GlobalMemoryStatusEx did not succeed so we miss some memory values.&quot;);
1795   }
1796 
1797   // extended memory statistics for a process
1798   PROCESS_MEMORY_COUNTERS_EX pmex;
1799   ZeroMemory(&amp;pmex, sizeof(PROCESS_MEMORY_COUNTERS_EX));
1800   pmex.cb = sizeof(pmex);
1801   int r2 = GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*) &amp;pmex, sizeof(pmex));
1802 
1803   if (r2 != 0) {
1804     st-&gt;print(&quot;\ncurrent process WorkingSet (physical memory assigned to process): &quot; INT64_FORMAT &quot;M, &quot;,
1805              (int64_t) pmex.WorkingSetSize &gt;&gt; 20);
1806     st-&gt;print(&quot;peak: &quot; INT64_FORMAT &quot;M\n&quot;, (int64_t) pmex.PeakWorkingSetSize &gt;&gt; 20);
1807 
1808     st-&gt;print(&quot;current process commit charge (\&quot;private bytes\&quot;): &quot; INT64_FORMAT &quot;M, &quot;,
1809              (int64_t) pmex.PrivateUsage &gt;&gt; 20);
1810     st-&gt;print(&quot;peak: &quot; INT64_FORMAT &quot;M&quot;, (int64_t) pmex.PeakPagefileUsage &gt;&gt; 20);
1811   } else {
1812     st-&gt;print(&quot;\nGetProcessMemoryInfo did not succeed so we miss some memory values.&quot;);
1813   }
1814 
1815   st-&gt;cr();
1816 }
1817 
1818 bool os::signal_sent_by_kill(const void* siginfo) {
1819   // TODO: Is this possible?
1820   return false;
1821 }
1822 
1823 void os::print_siginfo(outputStream *st, const void* siginfo) {
1824   const EXCEPTION_RECORD* const er = (EXCEPTION_RECORD*)siginfo;
1825   st-&gt;print(&quot;siginfo:&quot;);
1826 
1827   char tmp[64];
1828   if (os::exception_name(er-&gt;ExceptionCode, tmp, sizeof(tmp)) == NULL) {
1829     strcpy(tmp, &quot;EXCEPTION_??&quot;);
1830   }
1831   st-&gt;print(&quot; %s (0x%x)&quot;, tmp, er-&gt;ExceptionCode);
1832 
1833   if ((er-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||
1834        er-&gt;ExceptionCode == EXCEPTION_IN_PAGE_ERROR) &amp;&amp;
1835        er-&gt;NumberParameters &gt;= 2) {
1836     switch (er-&gt;ExceptionInformation[0]) {
1837     case 0: st-&gt;print(&quot;, reading address&quot;); break;
1838     case 1: st-&gt;print(&quot;, writing address&quot;); break;
1839     case 8: st-&gt;print(&quot;, data execution prevention violation at address&quot;); break;
1840     default: st-&gt;print(&quot;, ExceptionInformation=&quot; INTPTR_FORMAT,
1841                        er-&gt;ExceptionInformation[0]);
1842     }
1843     st-&gt;print(&quot; &quot; INTPTR_FORMAT, er-&gt;ExceptionInformation[1]);
1844   } else {
1845     int num = er-&gt;NumberParameters;
1846     if (num &gt; 0) {
1847       st-&gt;print(&quot;, ExceptionInformation=&quot;);
1848       for (int i = 0; i &lt; num; i++) {
1849         st-&gt;print(INTPTR_FORMAT &quot; &quot;, er-&gt;ExceptionInformation[i]);
1850       }
1851     }
1852   }
1853   st-&gt;cr();
1854 }
1855 
1856 bool os::signal_thread(Thread* thread, int sig, const char* reason) {
1857   // TODO: Can we kill thread?
1858   return false;
1859 }
1860 
1861 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1862   // do nothing
1863 }
1864 
1865 static char saved_jvm_path[MAX_PATH] = {0};
1866 
1867 // Find the full path to the current module, jvm.dll
1868 void os::jvm_path(char *buf, jint buflen) {
1869   // Error checking.
1870   if (buflen &lt; MAX_PATH) {
1871     assert(false, &quot;must use a large-enough buffer&quot;);
1872     buf[0] = &#39;\0&#39;;
1873     return;
1874   }
1875   // Lazy resolve the path to current module.
1876   if (saved_jvm_path[0] != 0) {
1877     strcpy(buf, saved_jvm_path);
1878     return;
1879   }
1880 
1881   buf[0] = &#39;\0&#39;;
1882   if (Arguments::sun_java_launcher_is_altjvm()) {
1883     // Support for the java launcher&#39;s &#39;-XXaltjvm=&lt;path&gt;&#39; option. Check
1884     // for a JAVA_HOME environment variable and fix up the path so it
1885     // looks like jvm.dll is installed there (append a fake suffix
1886     // hotspot/jvm.dll).
1887     char* java_home_var = ::getenv(&quot;JAVA_HOME&quot;);
1888     if (java_home_var != NULL &amp;&amp; java_home_var[0] != 0 &amp;&amp;
1889         strlen(java_home_var) &lt; (size_t)buflen) {
1890       strncpy(buf, java_home_var, buflen);
1891 
1892       // determine if this is a legacy image or modules image
1893       // modules image doesn&#39;t have &quot;jre&quot; subdirectory
1894       size_t len = strlen(buf);
1895       char* jrebin_p = buf + len;
1896       jio_snprintf(jrebin_p, buflen-len, &quot;\\jre\\bin\\&quot;);
1897       if (0 != _access(buf, 0)) {
1898         jio_snprintf(jrebin_p, buflen-len, &quot;\\bin\\&quot;);
1899       }
1900       len = strlen(buf);
1901       jio_snprintf(buf + len, buflen-len, &quot;hotspot\\jvm.dll&quot;);
1902     }
1903   }
1904 
1905   if (buf[0] == &#39;\0&#39;) {
1906     GetModuleFileName(vm_lib_handle, buf, buflen);
1907   }
1908   strncpy(saved_jvm_path, buf, MAX_PATH);
1909   saved_jvm_path[MAX_PATH - 1] = &#39;\0&#39;;
1910 }
1911 
1912 
1913 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1914 #ifndef _WIN64
1915   st-&gt;print(&quot;_&quot;);
1916 #endif
1917 }
1918 
1919 
1920 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1921 #ifndef _WIN64
1922   st-&gt;print(&quot;@%d&quot;, args_size  * sizeof(int));
1923 #endif
1924 }
1925 
1926 // This method is a copy of JDK&#39;s sysGetLastErrorString
1927 // from src/windows/hpi/src/system_md.c
1928 
1929 size_t os::lasterror(char* buf, size_t len) {
1930   DWORD errval;
1931 
1932   if ((errval = GetLastError()) != 0) {
1933     // DOS error
1934     size_t n = (size_t)FormatMessage(
1935                                      FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
1936                                      NULL,
1937                                      errval,
1938                                      0,
1939                                      buf,
1940                                      (DWORD)len,
1941                                      NULL);
1942     if (n &gt; 3) {
1943       // Drop final &#39;.&#39;, CR, LF
1944       if (buf[n - 1] == &#39;\n&#39;) n--;
1945       if (buf[n - 1] == &#39;\r&#39;) n--;
1946       if (buf[n - 1] == &#39;.&#39;) n--;
1947       buf[n] = &#39;\0&#39;;
1948     }
1949     return n;
1950   }
1951 
1952   if (errno != 0) {
1953     // C runtime error that has no corresponding DOS error code
1954     const char* s = os::strerror(errno);
1955     size_t n = strlen(s);
1956     if (n &gt;= len) n = len - 1;
1957     strncpy(buf, s, n);
1958     buf[n] = &#39;\0&#39;;
1959     return n;
1960   }
1961 
1962   return 0;
1963 }
1964 
1965 int os::get_last_error() {
1966   DWORD error = GetLastError();
1967   if (error == 0) {
1968     error = errno;
1969   }
1970   return (int)error;
1971 }
1972 
1973 // sun.misc.Signal
1974 // NOTE that this is a workaround for an apparent kernel bug where if
1975 // a signal handler for SIGBREAK is installed then that signal handler
1976 // takes priority over the console control handler for CTRL_CLOSE_EVENT.
1977 // See bug 4416763.
1978 static void (*sigbreakHandler)(int) = NULL;
1979 
1980 static void UserHandler(int sig, void *siginfo, void *context) {
1981   os::signal_notify(sig);
1982   // We need to reinstate the signal handler each time...
1983   os::signal(sig, (void*)UserHandler);
1984 }
1985 
1986 void* os::user_handler() {
1987   return (void*) UserHandler;
1988 }
1989 
1990 void* os::signal(int signal_number, void* handler) {
1991   if ((signal_number == SIGBREAK) &amp;&amp; (!ReduceSignalUsage)) {
1992     void (*oldHandler)(int) = sigbreakHandler;
1993     sigbreakHandler = (void (*)(int)) handler;
1994     return (void*) oldHandler;
1995   } else {
1996     return (void*)::signal(signal_number, (void (*)(int))handler);
1997   }
1998 }
1999 
2000 void os::signal_raise(int signal_number) {
2001   raise(signal_number);
2002 }
2003 
2004 // The Win32 C runtime library maps all console control events other than ^C
2005 // into SIGBREAK, which makes it impossible to distinguish ^BREAK from close,
2006 // logoff, and shutdown events.  We therefore install our own console handler
2007 // that raises SIGTERM for the latter cases.
2008 //
2009 static BOOL WINAPI consoleHandler(DWORD event) {
2010   switch (event) {
2011   case CTRL_C_EVENT:
2012     if (VMError::is_error_reported()) {
2013       // Ctrl-C is pressed during error reporting, likely because the error
2014       // handler fails to abort. Let VM die immediately.
2015       os::die();
2016     }
2017 
2018     os::signal_raise(SIGINT);
2019     return TRUE;
2020     break;
2021   case CTRL_BREAK_EVENT:
2022     if (sigbreakHandler != NULL) {
2023       (*sigbreakHandler)(SIGBREAK);
2024     }
2025     return TRUE;
2026     break;
2027   case CTRL_LOGOFF_EVENT: {
2028     // Don&#39;t terminate JVM if it is running in a non-interactive session,
2029     // such as a service process.
2030     USEROBJECTFLAGS flags;
2031     HANDLE handle = GetProcessWindowStation();
2032     if (handle != NULL &amp;&amp;
2033         GetUserObjectInformation(handle, UOI_FLAGS, &amp;flags,
2034         sizeof(USEROBJECTFLAGS), NULL)) {
2035       // If it is a non-interactive session, let next handler to deal
2036       // with it.
2037       if ((flags.dwFlags &amp; WSF_VISIBLE) == 0) {
2038         return FALSE;
2039       }
2040     }
2041   }
2042   case CTRL_CLOSE_EVENT:
2043   case CTRL_SHUTDOWN_EVENT:
2044     os::signal_raise(SIGTERM);
2045     return TRUE;
2046     break;
2047   default:
2048     break;
2049   }
2050   return FALSE;
2051 }
2052 
2053 // The following code is moved from os.cpp for making this
2054 // code platform specific, which it is by its very nature.
2055 
2056 // Return maximum OS signal used + 1 for internal use only
2057 // Used as exit signal for signal_thread
2058 int os::sigexitnum_pd() {
2059   return NSIG;
2060 }
2061 
2062 // a counter for each possible signal value, including signal_thread exit signal
2063 static volatile jint pending_signals[NSIG+1] = { 0 };
2064 static Semaphore* sig_sem = NULL;
2065 
2066 static void jdk_misc_signal_init() {
2067   // Initialize signal structures
2068   memset((void*)pending_signals, 0, sizeof(pending_signals));
2069 
2070   // Initialize signal semaphore
2071   sig_sem = new Semaphore();
2072 
2073   // Programs embedding the VM do not want it to attempt to receive
2074   // events like CTRL_LOGOFF_EVENT, which are used to implement the
2075   // shutdown hooks mechanism introduced in 1.3.  For example, when
2076   // the VM is run as part of a Windows NT service (i.e., a servlet
2077   // engine in a web server), the correct behavior is for any console
2078   // control handler to return FALSE, not TRUE, because the OS&#39;s
2079   // &quot;final&quot; handler for such events allows the process to continue if
2080   // it is a service (while terminating it if it is not a service).
2081   // To make this behavior uniform and the mechanism simpler, we
2082   // completely disable the VM&#39;s usage of these console events if -Xrs
2083   // (=ReduceSignalUsage) is specified.  This means, for example, that
2084   // the CTRL-BREAK thread dump mechanism is also disabled in this
2085   // case.  See bugs 4323062, 4345157, and related bugs.
2086 
2087   // Add a CTRL-C handler
2088   SetConsoleCtrlHandler(consoleHandler, TRUE);
2089 }
2090 
2091 void os::signal_notify(int sig) {
2092   if (sig_sem != NULL) {
2093     Atomic::inc(&amp;pending_signals[sig]);
2094     sig_sem-&gt;signal();
2095   } else {
2096     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
2097     // initialization isn&#39;t called.
2098     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
2099   }
2100 }
2101 
2102 static int check_pending_signals() {
2103   while (true) {
2104     for (int i = 0; i &lt; NSIG + 1; i++) {
2105       jint n = pending_signals[i];
2106       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {
2107         return i;
2108       }
2109     }
2110     JavaThread *thread = JavaThread::current();
2111 
2112     ThreadBlockInVM tbivm(thread);
2113 
2114     bool threadIsSuspended;
2115     do {
2116       thread-&gt;set_suspend_equivalent();
2117       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2118       sig_sem-&gt;wait();
2119 
2120       // were we externally suspended while we were waiting?
2121       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2122       if (threadIsSuspended) {
2123         // The semaphore has been incremented, but while we were waiting
2124         // another thread suspended us. We don&#39;t want to continue running
2125         // while suspended because that would surprise the thread that
2126         // suspended us.
2127         sig_sem-&gt;signal();
2128 
2129         thread-&gt;java_suspend_self();
2130       }
2131     } while (threadIsSuspended);
2132   }
2133 }
2134 
2135 int os::signal_wait() {
2136   return check_pending_signals();
2137 }
2138 
2139 // Implicit OS exception handling
2140 
2141 LONG Handle_Exception(struct _EXCEPTION_POINTERS* exceptionInfo,
2142                       address handler) {
2143   JavaThread* thread = (JavaThread*) Thread::current_or_null();
2144   // Save pc in thread
2145 #ifdef _M_AMD64
2146   // Do not blow up if no thread info available.
2147   if (thread) {
2148     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Rip);
2149   }
2150   // Set pc to handler
2151   exceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)handler;
<a name="13" id="anc13"></a>






2152 #else
2153   // Do not blow up if no thread info available.
2154   if (thread) {
2155     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Eip);
2156   }
2157   // Set pc to handler
2158   exceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)(DWORD_PTR)handler;
2159 #endif
2160 
2161   // Continue the execution
2162   return EXCEPTION_CONTINUE_EXECUTION;
2163 }
2164 
2165 
2166 // Used for PostMortemDump
2167 extern &quot;C&quot; void safepoints();
2168 extern &quot;C&quot; void find(int x);
2169 extern &quot;C&quot; void events();
2170 
2171 // According to Windows API documentation, an illegal instruction sequence should generate
2172 // the 0xC000001C exception code. However, real world experience shows that occasionnaly
2173 // the execution of an illegal instruction can generate the exception code 0xC000001E. This
2174 // seems to be an undocumented feature of Win NT 4.0 (and probably other Windows systems).
2175 
2176 #define EXCEPTION_ILLEGAL_INSTRUCTION_2 0xC000001E
2177 
2178 // From &quot;Execution Protection in the Windows Operating System&quot; draft 0.35
2179 // Once a system header becomes available, the &quot;real&quot; define should be
2180 // included or copied here.
2181 #define EXCEPTION_INFO_EXEC_VIOLATION 0x08
2182 
2183 // Windows Vista/2008 heap corruption check
2184 #define EXCEPTION_HEAP_CORRUPTION        0xC0000374
2185 
2186 // All Visual C++ exceptions thrown from code generated by the Microsoft Visual
2187 // C++ compiler contain this error code. Because this is a compiler-generated
2188 // error, the code is not listed in the Win32 API header files.
2189 // The code is actually a cryptic mnemonic device, with the initial &quot;E&quot;
2190 // standing for &quot;exception&quot; and the final 3 bytes (0x6D7363) representing the
2191 // ASCII values of &quot;msc&quot;.
2192 
2193 #define EXCEPTION_UNCAUGHT_CXX_EXCEPTION    0xE06D7363
2194 
2195 #define def_excpt(val) { #val, (val) }
2196 
2197 static const struct { const char* name; uint number; } exceptlabels[] = {
2198     def_excpt(EXCEPTION_ACCESS_VIOLATION),
2199     def_excpt(EXCEPTION_DATATYPE_MISALIGNMENT),
2200     def_excpt(EXCEPTION_BREAKPOINT),
2201     def_excpt(EXCEPTION_SINGLE_STEP),
2202     def_excpt(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
2203     def_excpt(EXCEPTION_FLT_DENORMAL_OPERAND),
2204     def_excpt(EXCEPTION_FLT_DIVIDE_BY_ZERO),
2205     def_excpt(EXCEPTION_FLT_INEXACT_RESULT),
2206     def_excpt(EXCEPTION_FLT_INVALID_OPERATION),
2207     def_excpt(EXCEPTION_FLT_OVERFLOW),
2208     def_excpt(EXCEPTION_FLT_STACK_CHECK),
2209     def_excpt(EXCEPTION_FLT_UNDERFLOW),
2210     def_excpt(EXCEPTION_INT_DIVIDE_BY_ZERO),
2211     def_excpt(EXCEPTION_INT_OVERFLOW),
2212     def_excpt(EXCEPTION_PRIV_INSTRUCTION),
2213     def_excpt(EXCEPTION_IN_PAGE_ERROR),
2214     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION),
2215     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION_2),
2216     def_excpt(EXCEPTION_NONCONTINUABLE_EXCEPTION),
2217     def_excpt(EXCEPTION_STACK_OVERFLOW),
2218     def_excpt(EXCEPTION_INVALID_DISPOSITION),
2219     def_excpt(EXCEPTION_GUARD_PAGE),
2220     def_excpt(EXCEPTION_INVALID_HANDLE),
2221     def_excpt(EXCEPTION_UNCAUGHT_CXX_EXCEPTION),
2222     def_excpt(EXCEPTION_HEAP_CORRUPTION)
2223 };
2224 
2225 #undef def_excpt
2226 
2227 const char* os::exception_name(int exception_code, char *buf, size_t size) {
2228   uint code = static_cast&lt;uint&gt;(exception_code);
2229   for (uint i = 0; i &lt; ARRAY_SIZE(exceptlabels); ++i) {
2230     if (exceptlabels[i].number == code) {
2231       jio_snprintf(buf, size, &quot;%s&quot;, exceptlabels[i].name);
2232       return buf;
2233     }
2234   }
2235 
2236   return NULL;
2237 }
2238 
2239 //-----------------------------------------------------------------------------
2240 LONG Handle_IDiv_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2241   // handle exception caused by idiv; should only happen for -MinInt/-1
2242   // (division by zero is handled explicitly)
2243 #ifdef  _M_AMD64
2244   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2245   address pc = (address)ctx-&gt;Rip;
2246   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; pc[1] == 0xF7 || pc[0] == 0xF7, &quot;not an idiv opcode&quot;);
2247   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; (pc[2] &amp; ~0x7) == 0xF8 || (pc[1] &amp; ~0x7) == 0xF8, &quot;cannot handle non-register operands&quot;);
2248   if (pc[0] == 0xF7) {
2249     // set correct result values and continue after idiv instruction
2250     ctx-&gt;Rip = (DWORD64)pc + 2;        // idiv reg, reg  is 2 bytes
2251   } else {
2252     ctx-&gt;Rip = (DWORD64)pc + 3;        // REX idiv reg, reg  is 3 bytes
2253   }
2254   // Do not set ctx-&gt;Rax as it already contains the correct value (either 32 or 64 bit, depending on the operation)
2255   // this is the case because the exception only happens for -MinValue/-1 and -MinValue is always in rax because of the
2256   // idiv opcode (0xF7).
2257   ctx-&gt;Rdx = (DWORD)0;             // remainder
2258   // Continue the execution
<a name="14" id="anc14"></a>









2259 #else
2260   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2261   address pc = (address)ctx-&gt;Eip;
2262   assert(pc[0] == 0xF7, &quot;not an idiv opcode&quot;);
2263   assert((pc[1] &amp; ~0x7) == 0xF8, &quot;cannot handle non-register operands&quot;);
2264   assert(ctx-&gt;Eax == min_jint, &quot;unexpected idiv exception&quot;);
2265   // set correct result values and continue after idiv instruction
2266   ctx-&gt;Eip = (DWORD)pc + 2;        // idiv reg, reg  is 2 bytes
2267   ctx-&gt;Eax = (DWORD)min_jint;      // result
2268   ctx-&gt;Edx = (DWORD)0;             // remainder
2269   // Continue the execution
2270 #endif
2271   return EXCEPTION_CONTINUE_EXECUTION;
2272 }
2273 
<a name="15" id="anc15"></a>
2274 //-----------------------------------------------------------------------------
2275 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2276   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2277 #ifndef  _WIN64
2278   // handle exception caused by native method modifying control word
2279   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2280 
2281   switch (exception_code) {
2282   case EXCEPTION_FLT_DENORMAL_OPERAND:
2283   case EXCEPTION_FLT_DIVIDE_BY_ZERO:
2284   case EXCEPTION_FLT_INEXACT_RESULT:
2285   case EXCEPTION_FLT_INVALID_OPERATION:
2286   case EXCEPTION_FLT_OVERFLOW:
2287   case EXCEPTION_FLT_STACK_CHECK:
2288   case EXCEPTION_FLT_UNDERFLOW:
2289     jint fp_control_word = (* (jint*) StubRoutines::addr_fpu_cntrl_wrd_std());
2290     if (fp_control_word != ctx-&gt;FloatSave.ControlWord) {
2291       // Restore FPCW and mask out FLT exceptions
2292       ctx-&gt;FloatSave.ControlWord = fp_control_word | 0xffffffc0;
2293       // Mask out pending FLT exceptions
2294       ctx-&gt;FloatSave.StatusWord &amp;=  0xffffff00;
2295       return EXCEPTION_CONTINUE_EXECUTION;
2296     }
2297   }
2298 
2299   if (prev_uef_handler != NULL) {
2300     // We didn&#39;t handle this exception so pass it to the previous
2301     // UnhandledExceptionFilter.
2302     return (prev_uef_handler)(exceptionInfo);
2303   }
2304 #else // !_WIN64
2305   // On Windows, the mxcsr control bits are non-volatile across calls
2306   // See also CR 6192333
2307   //
2308   jint MxCsr = INITIAL_MXCSR;
2309   // we can&#39;t use StubRoutines::addr_mxcsr_std()
2310   // because in Win64 mxcsr is not saved there
2311   if (MxCsr != ctx-&gt;MxCsr) {
2312     ctx-&gt;MxCsr = MxCsr;
2313     return EXCEPTION_CONTINUE_EXECUTION;
2314   }
2315 #endif // !_WIN64
2316 
2317   return EXCEPTION_CONTINUE_SEARCH;
2318 }
<a name="16" id="anc16"></a>
2319 
<a name="17" id="anc17"></a><span class="line-modified">2320 static inline void report_error(Thread* t, DWORD exception_code,</span>


2321                                 address addr, void* siginfo, void* context) {
2322   VMError::report_and_die(t, exception_code, addr, siginfo, context);
2323 
2324   // If UseOsErrorReporting, this will return here and save the error file
2325   // somewhere where we can find it in the minidump.
2326 }
2327 
<a name="18" id="anc18"></a><span class="line-removed">2328 bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,</span>
<span class="line-removed">2329         struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {</span>
<span class="line-removed">2330   PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="line-removed">2331   address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
<span class="line-removed">2332   if (Interpreter::contains(pc)) {</span>
<span class="line-removed">2333     *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);</span>
<span class="line-removed">2334     if (!fr-&gt;is_first_java_frame()) {</span>
<span class="line-removed">2335       // get_frame_at_stack_banging_point() is only called when we</span>
<span class="line-removed">2336       // have well defined stacks so java_sender() calls do not need</span>
<span class="line-removed">2337       // to assert safe_for_sender() first.</span>
<span class="line-removed">2338       *fr = fr-&gt;java_sender();</span>
<span class="line-removed">2339     }</span>
<span class="line-removed">2340   } else {</span>
<span class="line-removed">2341     // more complex code with compiled code</span>
<span class="line-removed">2342     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);</span>
<span class="line-removed">2343     CodeBlob* cb = CodeCache::find_blob(pc);</span>
<span class="line-removed">2344     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {</span>
<span class="line-removed">2345       // Not sure where the pc points to, fallback to default</span>
<span class="line-removed">2346       // stack overflow handling</span>
<span class="line-removed">2347       return false;</span>
<span class="line-removed">2348     } else {</span>
<span class="line-removed">2349       *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);</span>
<span class="line-removed">2350       // in compiled code, the stack banging is performed just after the return pc</span>
<span class="line-removed">2351       // has been pushed on the stack</span>
<span class="line-removed">2352       *fr = frame(fr-&gt;sp() + 1, fr-&gt;fp(), (address)*(fr-&gt;sp()));</span>
<span class="line-removed">2353       if (!fr-&gt;is_java_frame()) {</span>
<span class="line-removed">2354         // See java_sender() comment above.</span>
<span class="line-removed">2355         *fr = fr-&gt;java_sender();</span>
<span class="line-removed">2356       }</span>
<span class="line-removed">2357     }</span>
<span class="line-removed">2358   }</span>
<span class="line-removed">2359   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);</span>
<span class="line-removed">2360   return true;</span>
<span class="line-removed">2361 }</span>
<span class="line-removed">2362 </span>
<span class="line-removed">2363 #if INCLUDE_AOT</span>
<span class="line-removed">2364 LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {</span>
<span class="line-removed">2365   PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="line-removed">2366   address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
<span class="line-removed">2367   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;</span>
<span class="line-removed">2368 </span>
<span class="line-removed">2369   // Handle the case where we get an implicit exception in AOT generated</span>
<span class="line-removed">2370   // code.  AOT DLL&#39;s loaded are not registered for structured exceptions.</span>
<span class="line-removed">2371   // If the exception occurred in the codeCache or AOT code, pass control</span>
<span class="line-removed">2372   // to our normal exception handler.</span>
<span class="line-removed">2373   CodeBlob* cb = CodeCache::find_blob(pc);</span>
<span class="line-removed">2374   if (cb != NULL) {</span>
<span class="line-removed">2375     return topLevelExceptionFilter(exceptionInfo);</span>
<span class="line-removed">2376   }</span>
<span class="line-removed">2377 </span>
<span class="line-removed">2378   return EXCEPTION_CONTINUE_SEARCH;</span>
<span class="line-removed">2379 }</span>
<span class="line-removed">2380 #endif</span>
<span class="line-removed">2381 </span>
2382 //-----------------------------------------------------------------------------
2383 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2384   if (InterceptOSException) return EXCEPTION_CONTINUE_SEARCH;
2385   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
<a name="19" id="anc19"></a><span class="line-modified">2386 #ifdef _M_AMD64</span>




2387   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;
2388 #else
2389   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2390 #endif
2391   Thread* t = Thread::current_or_null_safe();
2392 
2393   // Handle SafeFetch32 and SafeFetchN exceptions.
2394   if (StubRoutines::is_safefetch_fault(pc)) {
2395     return Handle_Exception(exceptionInfo, StubRoutines::continuation_for_safefetch_fault(pc));
2396   }
2397 
2398 #ifndef _WIN64
2399   // Execution protection violation - win32 running on AMD64 only
2400   // Handled first to avoid misdiagnosis as a &quot;normal&quot; access violation;
2401   // This is safe to do because we have a new/unique ExceptionInformation
2402   // code for this condition.
2403   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
<a name="20" id="anc20"></a><span class="line-modified">2404     PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="line-removed">2405     int exception_subcode = (int) exceptionRecord-&gt;ExceptionInformation[0];</span>
<span class="line-removed">2406     address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
2407 
2408     if (exception_subcode == EXCEPTION_INFO_EXEC_VIOLATION) {
2409       int page_size = os::vm_page_size();
2410 
2411       // Make sure the pc and the faulting address are sane.
2412       //
2413       // If an instruction spans a page boundary, and the page containing
2414       // the beginning of the instruction is executable but the following
2415       // page is not, the pc and the faulting address might be slightly
2416       // different - we still want to unguard the 2nd page in this case.
2417       //
2418       // 15 bytes seems to be a (very) safe value for max instruction size.
2419       bool pc_is_near_addr =
2420         (pointer_delta((void*) addr, (void*) pc, sizeof(char)) &lt; 15);
2421       bool instr_spans_page_boundary =
2422         (align_down((intptr_t) pc ^ (intptr_t) addr,
2423                          (intptr_t) page_size) &gt; 0);
2424 
2425       if (pc == addr || (pc_is_near_addr &amp;&amp; instr_spans_page_boundary)) {
2426         static volatile address last_addr =
2427           (address) os::non_memory_address_word();
2428 
2429         // In conservative mode, don&#39;t unguard unless the address is in the VM
2430         if (UnguardOnExecutionViolation &gt; 0 &amp;&amp; addr != last_addr &amp;&amp;
2431             (UnguardOnExecutionViolation &gt; 1 || os::address_is_in_vm(addr))) {
2432 
2433           // Set memory to RWX and retry
2434           address page_start = align_down(addr, page_size);
2435           bool res = os::protect_memory((char*) page_start, page_size,
2436                                         os::MEM_PROT_RWX);
2437 
2438           log_debug(os)(&quot;Execution protection violation &quot;
2439                         &quot;at &quot; INTPTR_FORMAT
2440                         &quot;, unguarding &quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(addr),
2441                         p2i(page_start), (res ? &quot;success&quot; : os::strerror(errno)));
2442 
2443           // Set last_addr so if we fault again at the same address, we don&#39;t
2444           // end up in an endless loop.
2445           //
2446           // There are two potential complications here.  Two threads trapping
2447           // at the same address at the same time could cause one of the
2448           // threads to think it already unguarded, and abort the VM.  Likely
2449           // very rare.
2450           //
2451           // The other race involves two threads alternately trapping at
2452           // different addresses and failing to unguard the page, resulting in
2453           // an endless loop.  This condition is probably even more unlikely
2454           // than the first.
2455           //
2456           // Although both cases could be avoided by using locks or thread
2457           // local last_addr, these solutions are unnecessary complication:
2458           // this handler is a best-effort safety net, not a complete solution.
2459           // It is disabled by default and should only be used as a workaround
2460           // in case we missed any no-execute-unsafe VM code.
2461 
2462           last_addr = addr;
2463 
2464           return EXCEPTION_CONTINUE_EXECUTION;
2465         }
2466       }
2467 
2468       // Last unguard failed or not unguarding
2469       tty-&gt;print_raw_cr(&quot;Execution protection violation&quot;);
2470       report_error(t, exception_code, addr, exceptionInfo-&gt;ExceptionRecord,
2471                    exceptionInfo-&gt;ContextRecord);
2472       return EXCEPTION_CONTINUE_SEARCH;
2473     }
2474   }
2475 #endif // _WIN64
2476 
<a name="21" id="anc21"></a>
2477   if ((exception_code == EXCEPTION_ACCESS_VIOLATION) &amp;&amp;
2478       VM_Version::is_cpuinfo_segv_addr(pc)) {
2479     // Verify that OS save/restore AVX registers.
2480     return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr());
2481   }
<a name="22" id="anc22"></a>
2482 
2483   if (t != NULL &amp;&amp; t-&gt;is_Java_thread()) {
2484     JavaThread* thread = (JavaThread*) t;
2485     bool in_java = thread-&gt;thread_state() == _thread_in_Java;
<a name="23" id="anc23"></a>


2486 
2487     // Handle potential stack overflows up front.
2488     if (exception_code == EXCEPTION_STACK_OVERFLOW) {
2489       if (thread-&gt;stack_guards_enabled()) {
2490         if (in_java) {
2491           frame fr;
<a name="24" id="anc24"></a><span class="line-removed">2492           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="line-removed">2493           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
2494           if (os::win32::get_frame_at_stack_banging_point(thread, exceptionInfo, pc, &amp;fr)) {
2495             assert(fr.is_java_frame(), &quot;Must be a Java frame&quot;);
2496             SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
2497           }
2498         }
2499         // Yellow zone violation.  The o/s has unprotected the first yellow
2500         // zone page for us.  Note:  must call disable_stack_yellow_zone to
2501         // update the enabled status, even if the zone contains only one page.
<a name="25" id="anc25"></a><span class="line-modified">2502         assert(thread-&gt;thread_state() != _thread_in_vm, &quot;Undersized StackShadowPages&quot;);</span>
2503         thread-&gt;disable_stack_yellow_reserved_zone();
2504         // If not in java code, return and hope for the best.
2505         return in_java
2506             ? Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW))
2507             :  EXCEPTION_CONTINUE_EXECUTION;
2508       } else {
2509         // Fatal red zone violation.
2510         thread-&gt;disable_stack_red_zone();
2511         tty-&gt;print_raw_cr(&quot;An unrecoverable stack overflow has occurred.&quot;);
2512         report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2513                       exceptionInfo-&gt;ContextRecord);
2514         return EXCEPTION_CONTINUE_SEARCH;
2515       }
2516     } else if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
<a name="26" id="anc26"></a><span class="line-removed">2517       // Either stack overflow or null pointer exception.</span>
2518       if (in_java) {
<a name="27" id="anc27"></a><span class="line-modified">2519         PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="line-removed">2520         address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
2521         address stack_end = thread-&gt;stack_end();
2522         if (addr &lt; stack_end &amp;&amp; addr &gt;= stack_end - os::vm_page_size()) {
2523           // Stack overflow.
2524           assert(!os::uses_stack_guard_pages(),
2525                  &quot;should be caught by red zone code above.&quot;);
2526           return Handle_Exception(exceptionInfo,
2527                                   SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW));
2528         }
2529         // Check for safepoint polling and implicit null
2530         // We only expect null pointers in the stubs (vtable)
2531         // the rest are checked explicitly now.
<a name="28" id="anc28"></a><span class="line-removed">2532         CodeBlob* cb = CodeCache::find_blob(pc);</span>
2533         if (cb != NULL) {
2534           if (os::is_poll_address(addr)) {
2535             address stub = SharedRuntime::get_poll_stub(pc);
2536             return Handle_Exception(exceptionInfo, stub);
2537           }
2538         }
<a name="29" id="anc29"></a><span class="line-removed">2539         {</span>
2540 #ifdef _WIN64
<a name="30" id="anc30"></a><span class="line-modified">2541           // If it&#39;s a legal stack address map the entire region in</span>
<span class="line-modified">2542           //</span>
<span class="line-modified">2543           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;</span>
<span class="line-modified">2544           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];</span>
<span class="line-modified">2545           if (addr &gt; thread-&gt;stack_reserved_zone_base() &amp;&amp; addr &lt; thread-&gt;stack_base()) {</span>
<span class="line-modified">2546             addr = (address)((uintptr_t)addr &amp;</span>
<span class="line-modified">2547                              (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));</span>
<span class="line-removed">2548             os::commit_memory((char *)addr, thread-&gt;stack_base() - addr,</span>
<span class="line-removed">2549                               !ExecMem);</span>
<span class="line-removed">2550             return EXCEPTION_CONTINUE_EXECUTION;</span>
<span class="line-removed">2551           } else</span>
2552 #endif
<a name="31" id="anc31"></a><span class="line-modified">2553           {</span>
<span class="line-modified">2554             // Null pointer exception.</span>
<span class="line-modified">2555             if (MacroAssembler::uses_implicit_null_check((void*)addr)) {</span>
<span class="line-modified">2556               address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);</span>
<span class="line-modified">2557               if (stub != NULL) return Handle_Exception(exceptionInfo, stub);</span>
<span class="line-modified">2558             }</span>
<span class="line-modified">2559             report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,</span>
<span class="line-modified">2560                          exceptionInfo-&gt;ContextRecord);</span>
<span class="line-modified">2561             return EXCEPTION_CONTINUE_SEARCH;</span>
<span class="line-modified">2562           }</span>






2563         }
<a name="32" id="anc32"></a>
2564       }
2565 
2566 #ifdef _WIN64
2567       // Special care for fast JNI field accessors.
2568       // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks
2569       // in and the heap gets shrunk before the field access.
<a name="33" id="anc33"></a><span class="line-modified">2570       if (exception_code == EXCEPTION_ACCESS_VIOLATION) {</span>
<span class="line-modified">2571         address addr = JNI_FastGetField::find_slowcase_pc(pc);</span>
<span class="line-modified">2572         if (addr != (address)-1) {</span>
<span class="line-removed">2573           return Handle_Exception(exceptionInfo, addr);</span>
<span class="line-removed">2574         }</span>
2575       }
2576 #endif
2577 
2578       // Stack overflow or null pointer exception in native code.
2579       report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2580                    exceptionInfo-&gt;ContextRecord);
2581       return EXCEPTION_CONTINUE_SEARCH;
<a name="34" id="anc34"></a><span class="line-modified">2582     } // /EXCEPTION_ACCESS_VIOLATION</span>
<span class="line-modified">2583     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="line-modified">2584 </span>
<span class="line-modified">2585     if (exception_code == EXCEPTION_IN_PAGE_ERROR) {</span>
<span class="line-removed">2586       CompiledMethod* nm = NULL;</span>
<span class="line-removed">2587       JavaThread* thread = (JavaThread*)t;</span>
<span class="line-removed">2588       if (in_java) {</span>
<span class="line-removed">2589         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);</span>
<span class="line-removed">2590         nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;</span>
<span class="line-removed">2591       }</span>
<span class="line-removed">2592 </span>
<span class="line-removed">2593       bool is_unsafe_arraycopy = (thread-&gt;thread_state() == _thread_in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);</span>
<span class="line-removed">2594       if (((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-removed">2595            thread-&gt;thread_state() == _thread_in_native ||</span>
<span class="line-removed">2596            is_unsafe_arraycopy) &amp;&amp;</span>
<span class="line-removed">2597           thread-&gt;doing_unsafe_access()) ||</span>
2598           (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {
2599         address next_pc =  Assembler::locate_next_instruction(pc);
2600         if (is_unsafe_arraycopy) {
2601           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
2602         }
2603         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, next_pc));
2604       }
2605     }
2606 
<a name="35" id="anc35"></a>












2607     if (in_java) {
2608       switch (exception_code) {
2609       case EXCEPTION_INT_DIVIDE_BY_ZERO:
2610         return Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO));
2611 
2612       case EXCEPTION_INT_OVERFLOW:
2613         return Handle_IDiv_Exception(exceptionInfo);
2614 
2615       } // switch
2616     }
<a name="36" id="anc36"></a>

2617     if (((thread-&gt;thread_state() == _thread_in_Java) ||
2618          (thread-&gt;thread_state() == _thread_in_native)) &amp;&amp;
2619          exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
2620       LONG result=Handle_FLT_Exception(exceptionInfo);
2621       if (result==EXCEPTION_CONTINUE_EXECUTION) return result;
2622     }
<a name="37" id="anc37"></a>
2623   }
2624 
2625   if (exception_code != EXCEPTION_BREAKPOINT) {
2626     report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2627                  exceptionInfo-&gt;ContextRecord);
2628   }
2629   return EXCEPTION_CONTINUE_SEARCH;
2630 }
2631 
2632 #ifndef _WIN64
2633 // Special care for fast JNI accessors.
2634 // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in and
2635 // the heap gets shrunk before the field access.
2636 // Need to install our own structured exception handler since native code may
2637 // install its own.
2638 LONG WINAPI fastJNIAccessorExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2639   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2640   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2641     address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2642     address addr = JNI_FastGetField::find_slowcase_pc(pc);
2643     if (addr != (address)-1) {
2644       return Handle_Exception(exceptionInfo, addr);
2645     }
2646   }
2647   return EXCEPTION_CONTINUE_SEARCH;
2648 }
2649 
2650 #define DEFINE_FAST_GETFIELD(Return, Fieldname, Result)                     \
2651   Return JNICALL jni_fast_Get##Result##Field_wrapper(JNIEnv *env,           \
2652                                                      jobject obj,           \
2653                                                      jfieldID fieldID) {    \
2654     __try {                                                                 \
2655       return (*JNI_FastGetField::jni_fast_Get##Result##Field_fp)(env,       \
2656                                                                  obj,       \
2657                                                                  fieldID);  \
2658     } __except(fastJNIAccessorExceptionFilter((_EXCEPTION_POINTERS*)        \
2659                                               _exception_info())) {         \
2660     }                                                                       \
2661     return 0;                                                               \
2662   }
2663 
2664 DEFINE_FAST_GETFIELD(jboolean, bool,   Boolean)
2665 DEFINE_FAST_GETFIELD(jbyte,    byte,   Byte)
2666 DEFINE_FAST_GETFIELD(jchar,    char,   Char)
2667 DEFINE_FAST_GETFIELD(jshort,   short,  Short)
2668 DEFINE_FAST_GETFIELD(jint,     int,    Int)
2669 DEFINE_FAST_GETFIELD(jlong,    long,   Long)
2670 DEFINE_FAST_GETFIELD(jfloat,   float,  Float)
2671 DEFINE_FAST_GETFIELD(jdouble,  double, Double)
2672 
2673 address os::win32::fast_jni_accessor_wrapper(BasicType type) {
2674   switch (type) {
2675   case T_BOOLEAN: return (address)jni_fast_GetBooleanField_wrapper;
2676   case T_BYTE:    return (address)jni_fast_GetByteField_wrapper;
2677   case T_CHAR:    return (address)jni_fast_GetCharField_wrapper;
2678   case T_SHORT:   return (address)jni_fast_GetShortField_wrapper;
2679   case T_INT:     return (address)jni_fast_GetIntField_wrapper;
2680   case T_LONG:    return (address)jni_fast_GetLongField_wrapper;
2681   case T_FLOAT:   return (address)jni_fast_GetFloatField_wrapper;
2682   case T_DOUBLE:  return (address)jni_fast_GetDoubleField_wrapper;
2683   default:        ShouldNotReachHere();
2684   }
2685   return (address)-1;
2686 }
2687 #endif
2688 
2689 // Virtual Memory
2690 
2691 int os::vm_page_size() { return os::win32::vm_page_size(); }
2692 int os::vm_allocation_granularity() {
2693   return os::win32::vm_allocation_granularity();
2694 }
2695 
2696 // Windows large page support is available on Windows 2003. In order to use
2697 // large page memory, the administrator must first assign additional privilege
2698 // to the user:
2699 //   + select Control Panel -&gt; Administrative Tools -&gt; Local Security Policy
2700 //   + select Local Policies -&gt; User Rights Assignment
2701 //   + double click &quot;Lock pages in memory&quot;, add users and/or groups
2702 //   + reboot
2703 // Note the above steps are needed for administrator as well, as administrators
2704 // by default do not have the privilege to lock pages in memory.
2705 //
2706 // Note about Windows 2003: although the API supports committing large page
2707 // memory on a page-by-page basis and VirtualAlloc() returns success under this
2708 // scenario, I found through experiment it only uses large page if the entire
2709 // memory region is reserved and committed in a single VirtualAlloc() call.
2710 // This makes Windows large page support more or less like Solaris ISM, in
2711 // that the entire heap must be committed upfront. This probably will change
2712 // in the future, if so the code below needs to be revisited.
2713 
2714 #ifndef MEM_LARGE_PAGES
2715   #define MEM_LARGE_PAGES 0x20000000
2716 #endif
2717 
2718 static HANDLE    _hProcess;
2719 static HANDLE    _hToken;
2720 
2721 // Container for NUMA node list info
2722 class NUMANodeListHolder {
2723  private:
2724   int *_numa_used_node_list;  // allocated below
2725   int _numa_used_node_count;
2726 
2727   void free_node_list() {
2728     FREE_C_HEAP_ARRAY(int, _numa_used_node_list);
2729   }
2730 
2731  public:
2732   NUMANodeListHolder() {
2733     _numa_used_node_count = 0;
2734     _numa_used_node_list = NULL;
2735     // do rest of initialization in build routine (after function pointers are set up)
2736   }
2737 
2738   ~NUMANodeListHolder() {
2739     free_node_list();
2740   }
2741 
2742   bool build() {
2743     DWORD_PTR proc_aff_mask;
2744     DWORD_PTR sys_aff_mask;
2745     if (!GetProcessAffinityMask(GetCurrentProcess(), &amp;proc_aff_mask, &amp;sys_aff_mask)) return false;
2746     ULONG highest_node_number;
2747     if (!GetNumaHighestNodeNumber(&amp;highest_node_number)) return false;
2748     free_node_list();
2749     _numa_used_node_list = NEW_C_HEAP_ARRAY(int, highest_node_number + 1, mtInternal);
2750     for (unsigned int i = 0; i &lt;= highest_node_number; i++) {
2751       ULONGLONG proc_mask_numa_node;
2752       if (!GetNumaNodeProcessorMask(i, &amp;proc_mask_numa_node)) return false;
2753       if ((proc_aff_mask &amp; proc_mask_numa_node)!=0) {
2754         _numa_used_node_list[_numa_used_node_count++] = i;
2755       }
2756     }
2757     return (_numa_used_node_count &gt; 1);
2758   }
2759 
2760   int get_count() { return _numa_used_node_count; }
2761   int get_node_list_entry(int n) {
2762     // for indexes out of range, returns -1
2763     return (n &lt; _numa_used_node_count ? _numa_used_node_list[n] : -1);
2764   }
2765 
2766 } numa_node_list_holder;
2767 
2768 
2769 
2770 static size_t _large_page_size = 0;
2771 
2772 static bool request_lock_memory_privilege() {
2773   _hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
2774                           os::current_process_id());
2775 
2776   LUID luid;
2777   if (_hProcess != NULL &amp;&amp;
2778       OpenProcessToken(_hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;_hToken) &amp;&amp;
2779       LookupPrivilegeValue(NULL, &quot;SeLockMemoryPrivilege&quot;, &amp;luid)) {
2780 
2781     TOKEN_PRIVILEGES tp;
2782     tp.PrivilegeCount = 1;
2783     tp.Privileges[0].Luid = luid;
2784     tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
2785 
2786     // AdjustTokenPrivileges() may return TRUE even when it couldn&#39;t change the
2787     // privilege. Check GetLastError() too. See MSDN document.
2788     if (AdjustTokenPrivileges(_hToken, false, &amp;tp, sizeof(tp), NULL, NULL) &amp;&amp;
2789         (GetLastError() == ERROR_SUCCESS)) {
2790       return true;
2791     }
2792   }
2793 
2794   return false;
2795 }
2796 
2797 static void cleanup_after_large_page_init() {
2798   if (_hProcess) CloseHandle(_hProcess);
2799   _hProcess = NULL;
2800   if (_hToken) CloseHandle(_hToken);
2801   _hToken = NULL;
2802 }
2803 
2804 static bool numa_interleaving_init() {
2805   bool success = false;
2806   bool use_numa_interleaving_specified = !FLAG_IS_DEFAULT(UseNUMAInterleaving);
2807 
2808   // print a warning if UseNUMAInterleaving flag is specified on command line
2809   bool warn_on_failure = use_numa_interleaving_specified;
2810 #define WARN(msg) if (warn_on_failure) { warning(msg); }
2811 
2812   // NUMAInterleaveGranularity cannot be less than vm_allocation_granularity (or _large_page_size if using large pages)
2813   size_t min_interleave_granularity = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2814   NUMAInterleaveGranularity = align_up(NUMAInterleaveGranularity, min_interleave_granularity);
2815 
2816   if (numa_node_list_holder.build()) {
2817     if (log_is_enabled(Debug, os, cpu)) {
2818       Log(os, cpu) log;
2819       log.debug(&quot;NUMA UsedNodeCount=%d, namely &quot;, numa_node_list_holder.get_count());
2820       for (int i = 0; i &lt; numa_node_list_holder.get_count(); i++) {
2821         log.debug(&quot;  %d &quot;, numa_node_list_holder.get_node_list_entry(i));
2822       }
2823     }
2824     success = true;
2825   } else {
2826     WARN(&quot;Process does not cover multiple NUMA nodes.&quot;);
2827   }
2828   if (!success) {
2829     if (use_numa_interleaving_specified) WARN(&quot;...Ignoring UseNUMAInterleaving flag.&quot;);
2830   }
2831   return success;
2832 #undef WARN
2833 }
2834 
2835 // this routine is used whenever we need to reserve a contiguous VA range
2836 // but we need to make separate VirtualAlloc calls for each piece of the range
2837 // Reasons for doing this:
2838 //  * UseLargePagesIndividualAllocation was set (normally only needed on WS2003 but possible to be set otherwise)
2839 //  * UseNUMAInterleaving requires a separate node for each piece
2840 static char* allocate_pages_individually(size_t bytes, char* addr, DWORD flags,
2841                                          DWORD prot,
2842                                          bool should_inject_error = false) {
2843   char * p_buf;
2844   // note: at setup time we guaranteed that NUMAInterleaveGranularity was aligned up to a page size
2845   size_t page_size = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2846   size_t chunk_size = UseNUMAInterleaving ? NUMAInterleaveGranularity : page_size;
2847 
2848   // first reserve enough address space in advance since we want to be
2849   // able to break a single contiguous virtual address range into multiple
2850   // large page commits but WS2003 does not allow reserving large page space
2851   // so we just use 4K pages for reserve, this gives us a legal contiguous
2852   // address space. then we will deallocate that reservation, and re alloc
2853   // using large pages
2854   const size_t size_of_reserve = bytes + chunk_size;
2855   if (bytes &gt; size_of_reserve) {
2856     // Overflowed.
2857     return NULL;
2858   }
2859   p_buf = (char *) VirtualAlloc(addr,
2860                                 size_of_reserve,  // size of Reserve
2861                                 MEM_RESERVE,
2862                                 PAGE_READWRITE);
2863   // If reservation failed, return NULL
2864   if (p_buf == NULL) return NULL;
2865   MemTracker::record_virtual_memory_reserve((address)p_buf, size_of_reserve, CALLER_PC);
2866   os::release_memory(p_buf, bytes + chunk_size);
2867 
2868   // we still need to round up to a page boundary (in case we are using large pages)
2869   // but not to a chunk boundary (in case InterleavingGranularity doesn&#39;t align with page size)
2870   // instead we handle this in the bytes_to_rq computation below
2871   p_buf = align_up(p_buf, page_size);
2872 
2873   // now go through and allocate one chunk at a time until all bytes are
2874   // allocated
2875   size_t  bytes_remaining = bytes;
2876   // An overflow of align_up() would have been caught above
2877   // in the calculation of size_of_reserve.
2878   char * next_alloc_addr = p_buf;
2879   HANDLE hProc = GetCurrentProcess();
2880 
2881 #ifdef ASSERT
2882   // Variable for the failure injection
2883   int ran_num = os::random();
2884   size_t fail_after = ran_num % bytes;
2885 #endif
2886 
2887   int count=0;
2888   while (bytes_remaining) {
2889     // select bytes_to_rq to get to the next chunk_size boundary
2890 
2891     size_t bytes_to_rq = MIN2(bytes_remaining, chunk_size - ((size_t)next_alloc_addr % chunk_size));
2892     // Note allocate and commit
2893     char * p_new;
2894 
2895 #ifdef ASSERT
2896     bool inject_error_now = should_inject_error &amp;&amp; (bytes_remaining &lt;= fail_after);
2897 #else
2898     const bool inject_error_now = false;
2899 #endif
2900 
2901     if (inject_error_now) {
2902       p_new = NULL;
2903     } else {
2904       if (!UseNUMAInterleaving) {
2905         p_new = (char *) VirtualAlloc(next_alloc_addr,
2906                                       bytes_to_rq,
2907                                       flags,
2908                                       prot);
2909       } else {
2910         // get the next node to use from the used_node_list
2911         assert(numa_node_list_holder.get_count() &gt; 0, &quot;Multiple NUMA nodes expected&quot;);
2912         DWORD node = numa_node_list_holder.get_node_list_entry(count % numa_node_list_holder.get_count());
2913         p_new = (char *)VirtualAllocExNuma(hProc, next_alloc_addr, bytes_to_rq, flags, prot, node);
2914       }
2915     }
2916 
2917     if (p_new == NULL) {
2918       // Free any allocated pages
2919       if (next_alloc_addr &gt; p_buf) {
2920         // Some memory was committed so release it.
2921         size_t bytes_to_release = bytes - bytes_remaining;
2922         // NMT has yet to record any individual blocks, so it
2923         // need to create a dummy &#39;reserve&#39; record to match
2924         // the release.
2925         MemTracker::record_virtual_memory_reserve((address)p_buf,
2926                                                   bytes_to_release, CALLER_PC);
2927         os::release_memory(p_buf, bytes_to_release);
2928       }
2929 #ifdef ASSERT
2930       if (should_inject_error) {
2931         log_develop_debug(pagesize)(&quot;Reserving pages individually failed.&quot;);
2932       }
2933 #endif
2934       return NULL;
2935     }
2936 
2937     bytes_remaining -= bytes_to_rq;
2938     next_alloc_addr += bytes_to_rq;
2939     count++;
2940   }
2941   // Although the memory is allocated individually, it is returned as one.
2942   // NMT records it as one block.
2943   if ((flags &amp; MEM_COMMIT) != 0) {
2944     MemTracker::record_virtual_memory_reserve_and_commit((address)p_buf, bytes, CALLER_PC);
2945   } else {
2946     MemTracker::record_virtual_memory_reserve((address)p_buf, bytes, CALLER_PC);
2947   }
2948 
2949   // made it this far, success
2950   return p_buf;
2951 }
2952 
2953 
2954 
2955 void os::large_page_init() {
2956   if (!UseLargePages) return;
2957 
2958   // print a warning if any large page related flag is specified on command line
2959   bool warn_on_failure = !FLAG_IS_DEFAULT(UseLargePages) ||
2960                          !FLAG_IS_DEFAULT(LargePageSizeInBytes);
2961   bool success = false;
2962 
2963 #define WARN(msg) if (warn_on_failure) { warning(msg); }
2964   if (request_lock_memory_privilege()) {
2965     size_t s = GetLargePageMinimum();
2966     if (s) {
2967 #if defined(IA32) || defined(AMD64)
2968       if (s &gt; 4*M || LargePageSizeInBytes &gt; 4*M) {
2969         WARN(&quot;JVM cannot use large pages bigger than 4mb.&quot;);
2970       } else {
2971 #endif
2972         if (LargePageSizeInBytes &amp;&amp; LargePageSizeInBytes % s == 0) {
2973           _large_page_size = LargePageSizeInBytes;
2974         } else {
2975           _large_page_size = s;
2976         }
2977         success = true;
2978 #if defined(IA32) || defined(AMD64)
2979       }
2980 #endif
2981     } else {
2982       WARN(&quot;Large page is not supported by the processor.&quot;);
2983     }
2984   } else {
2985     WARN(&quot;JVM cannot use large page memory because it does not have enough privilege to lock pages in memory.&quot;);
2986   }
2987 #undef WARN
2988 
2989   const size_t default_page_size = (size_t) vm_page_size();
2990   if (success &amp;&amp; _large_page_size &gt; default_page_size) {
2991     _page_sizes[0] = _large_page_size;
2992     _page_sizes[1] = default_page_size;
2993     _page_sizes[2] = 0;
2994   }
2995 
2996   cleanup_after_large_page_init();
2997   UseLargePages = success;
2998 }
2999 
3000 int os::create_file_for_heap(const char* dir) {
3001 
3002   const char name_template[] = &quot;/jvmheap.XXXXXX&quot;;
3003 
3004   size_t fullname_len = strlen(dir) + strlen(name_template);
3005   char *fullname = (char*)os::malloc(fullname_len + 1, mtInternal);
3006   if (fullname == NULL) {
3007     vm_exit_during_initialization(err_msg(&quot;Malloc failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));
3008     return -1;
3009   }
3010   int n = snprintf(fullname, fullname_len + 1, &quot;%s%s&quot;, dir, name_template);
3011   assert((size_t)n == fullname_len, &quot;Unexpected number of characters in string&quot;);
3012 
3013   os::native_path(fullname);
3014 
3015   char *path = _mktemp(fullname);
3016   if (path == NULL) {
3017     warning(&quot;_mktemp could not create file name from template %s (%s)&quot;, fullname, os::strerror(errno));
3018     os::free(fullname);
3019     return -1;
3020   }
3021 
3022   int fd = _open(path, O_RDWR | O_CREAT | O_TEMPORARY | O_EXCL, S_IWRITE | S_IREAD);
3023 
3024   os::free(fullname);
3025   if (fd &lt; 0) {
3026     warning(&quot;Problem opening file for heap (%s)&quot;, os::strerror(errno));
3027     return -1;
3028   }
3029   return fd;
3030 }
3031 
3032 // If &#39;base&#39; is not NULL, function will return NULL if it cannot get &#39;base&#39;
3033 char* os::map_memory_to_file(char* base, size_t size, int fd) {
3034   assert(fd != -1, &quot;File descriptor is not valid&quot;);
3035 
3036   HANDLE fh = (HANDLE)_get_osfhandle(fd);
3037 #ifdef _LP64
3038   HANDLE fileMapping = CreateFileMapping(fh, NULL, PAGE_READWRITE,
3039     (DWORD)(size &gt;&gt; 32), (DWORD)(size &amp; 0xFFFFFFFF), NULL);
3040 #else
3041   HANDLE fileMapping = CreateFileMapping(fh, NULL, PAGE_READWRITE,
3042     0, (DWORD)size, NULL);
3043 #endif
3044   if (fileMapping == NULL) {
3045     if (GetLastError() == ERROR_DISK_FULL) {
3046       vm_exit_during_initialization(err_msg(&quot;Could not allocate sufficient disk space for Java heap&quot;));
3047     }
3048     else {
3049       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
3050     }
3051 
3052     return NULL;
3053   }
3054 
3055   LPVOID addr = MapViewOfFileEx(fileMapping, FILE_MAP_WRITE, 0, 0, size, base);
3056 
3057   CloseHandle(fileMapping);
3058 
3059   return (char*)addr;
3060 }
3061 
3062 char* os::replace_existing_mapping_with_file_mapping(char* base, size_t size, int fd) {
3063   assert(fd != -1, &quot;File descriptor is not valid&quot;);
3064   assert(base != NULL, &quot;Base address cannot be NULL&quot;);
3065 
3066   release_memory(base, size);
3067   return map_memory_to_file(base, size, fd);
3068 }
3069 
3070 // On win32, one cannot release just a part of reserved memory, it&#39;s an
3071 // all or nothing deal.  When we split a reservation, we must break the
3072 // reservation into two reservations.
3073 void os::pd_split_reserved_memory(char *base, size_t size, size_t split,
3074                                   bool realloc) {
3075   if (size &gt; 0) {
3076     release_memory(base, size);
3077     if (realloc) {
3078       reserve_memory(split, base);
3079     }
3080     if (size != split) {
3081       reserve_memory(size - split, base + split);
3082     }
3083   }
3084 }
3085 
3086 // Multiple threads can race in this code but it&#39;s not possible to unmap small sections of
3087 // virtual space to get requested alignment, like posix-like os&#39;s.
3088 // Windows prevents multiple thread from remapping over each other so this loop is thread-safe.
3089 char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {
3090   assert((alignment &amp; (os::vm_allocation_granularity() - 1)) == 0,
3091          &quot;Alignment must be a multiple of allocation granularity (page size)&quot;);
3092   assert((size &amp; (alignment -1)) == 0, &quot;size must be &#39;alignment&#39; aligned&quot;);
3093 
3094   size_t extra_size = size + alignment;
3095   assert(extra_size &gt;= size, &quot;overflow, size is too large to allow alignment&quot;);
3096 
3097   char* aligned_base = NULL;
3098 
3099   do {
3100     char* extra_base = os::reserve_memory(extra_size, NULL, alignment, file_desc);
3101     if (extra_base == NULL) {
3102       return NULL;
3103     }
3104     // Do manual alignment
3105     aligned_base = align_up(extra_base, alignment);
3106 
3107     if (file_desc != -1) {
3108       os::unmap_memory(extra_base, extra_size);
3109     } else {
3110       os::release_memory(extra_base, extra_size);
3111     }
3112 
3113     aligned_base = os::reserve_memory(size, aligned_base, 0, file_desc);
3114 
3115   } while (aligned_base == NULL);
3116 
3117   return aligned_base;
3118 }
3119 
3120 char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint) {
3121   assert((size_t)addr % os::vm_allocation_granularity() == 0,
3122          &quot;reserve alignment&quot;);
3123   assert(bytes % os::vm_page_size() == 0, &quot;reserve page size&quot;);
3124   char* res;
3125   // note that if UseLargePages is on, all the areas that require interleaving
3126   // will go thru reserve_memory_special rather than thru here.
3127   bool use_individual = (UseNUMAInterleaving &amp;&amp; !UseLargePages);
3128   if (!use_individual) {
3129     res = (char*)VirtualAlloc(addr, bytes, MEM_RESERVE, PAGE_READWRITE);
3130   } else {
3131     elapsedTimer reserveTimer;
3132     if (Verbose &amp;&amp; PrintMiscellaneous) reserveTimer.start();
3133     // in numa interleaving, we have to allocate pages individually
3134     // (well really chunks of NUMAInterleaveGranularity size)
3135     res = allocate_pages_individually(bytes, addr, MEM_RESERVE, PAGE_READWRITE);
3136     if (res == NULL) {
3137       warning(&quot;NUMA page allocation failed&quot;);
3138     }
3139     if (Verbose &amp;&amp; PrintMiscellaneous) {
3140       reserveTimer.stop();
3141       tty-&gt;print_cr(&quot;reserve_memory of %Ix bytes took &quot; JLONG_FORMAT &quot; ms (&quot; JLONG_FORMAT &quot; ticks)&quot;, bytes,
3142                     reserveTimer.milliseconds(), reserveTimer.ticks());
3143     }
3144   }
3145   assert(res == NULL || addr == NULL || addr == res,
3146          &quot;Unexpected address from reserve.&quot;);
3147 
3148   return res;
3149 }
3150 
3151 // Reserve memory at an arbitrary address, only if that area is
3152 // available (and not reserved for something else).
3153 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
3154   // Windows os::reserve_memory() fails of the requested address range is
3155   // not avilable.
3156   return reserve_memory(bytes, requested_addr);
3157 }
3158 
3159 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
3160   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
3161   return map_memory_to_file(requested_addr, bytes, file_desc);
3162 }
3163 
3164 size_t os::large_page_size() {
3165   return _large_page_size;
3166 }
3167 
3168 bool os::can_commit_large_page_memory() {
3169   // Windows only uses large page memory when the entire region is reserved
3170   // and committed in a single VirtualAlloc() call. This may change in the
3171   // future, but with Windows 2003 it&#39;s not possible to commit on demand.
3172   return false;
3173 }
3174 
3175 bool os::can_execute_large_page_memory() {
3176   return true;
3177 }
3178 
3179 char* os::reserve_memory_special(size_t bytes, size_t alignment, char* addr,
3180                                  bool exec) {
3181   assert(UseLargePages, &quot;only for large pages&quot;);
3182 
3183   if (!is_aligned(bytes, os::large_page_size()) || alignment &gt; os::large_page_size()) {
3184     return NULL; // Fallback to small pages.
3185   }
3186 
3187   const DWORD prot = exec ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
3188   const DWORD flags = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3189 
3190   // with large pages, there are two cases where we need to use Individual Allocation
3191   // 1) the UseLargePagesIndividualAllocation flag is set (set by default on WS2003)
3192   // 2) NUMA Interleaving is enabled, in which case we use a different node for each page
3193   if (UseLargePagesIndividualAllocation || UseNUMAInterleaving) {
3194     log_debug(pagesize)(&quot;Reserving large pages individually.&quot;);
3195 
3196     char * p_buf = allocate_pages_individually(bytes, addr, flags, prot, LargePagesIndividualAllocationInjectError);
3197     if (p_buf == NULL) {
3198       // give an appropriate warning message
3199       if (UseNUMAInterleaving) {
3200         warning(&quot;NUMA large page allocation failed, UseLargePages flag ignored&quot;);
3201       }
3202       if (UseLargePagesIndividualAllocation) {
3203         warning(&quot;Individually allocated large pages failed, &quot;
3204                 &quot;use -XX:-UseLargePagesIndividualAllocation to turn off&quot;);
3205       }
3206       return NULL;
3207     }
3208 
3209     return p_buf;
3210 
3211   } else {
3212     log_debug(pagesize)(&quot;Reserving large pages in a single large chunk.&quot;);
3213 
3214     // normal policy just allocate it all at once
3215     DWORD flag = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3216     char * res = (char *)VirtualAlloc(addr, bytes, flag, prot);
3217     if (res != NULL) {
3218       MemTracker::record_virtual_memory_reserve_and_commit((address)res, bytes, CALLER_PC);
3219     }
3220 
3221     return res;
3222   }
3223 }
3224 
3225 bool os::release_memory_special(char* base, size_t bytes) {
3226   assert(base != NULL, &quot;Sanity check&quot;);
3227   return release_memory(base, bytes);
3228 }
3229 
3230 void os::print_statistics() {
3231 }
3232 
3233 static void warn_fail_commit_memory(char* addr, size_t bytes, bool exec) {
3234   int err = os::get_last_error();
3235   char buf[256];
3236   size_t buf_len = os::lasterror(buf, sizeof(buf));
3237   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3238           &quot;, %d) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3239           exec, buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3240 }
3241 
3242 bool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {
3243   if (bytes == 0) {
3244     // Don&#39;t bother the OS with noops.
3245     return true;
3246   }
3247   assert((size_t) addr % os::vm_page_size() == 0, &quot;commit on page boundaries&quot;);
3248   assert(bytes % os::vm_page_size() == 0, &quot;commit in page-sized chunks&quot;);
3249   // Don&#39;t attempt to print anything if the OS call fails. We&#39;re
3250   // probably low on resources, so the print itself may cause crashes.
3251 
3252   // unless we have NUMAInterleaving enabled, the range of a commit
3253   // is always within a reserve covered by a single VirtualAlloc
3254   // in that case we can just do a single commit for the requested size
3255   if (!UseNUMAInterleaving) {
3256     if (VirtualAlloc(addr, bytes, MEM_COMMIT, PAGE_READWRITE) == NULL) {
3257       NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3258       return false;
3259     }
3260     if (exec) {
3261       DWORD oldprot;
3262       // Windows doc says to use VirtualProtect to get execute permissions
3263       if (!VirtualProtect(addr, bytes, PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3264         NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3265         return false;
3266       }
3267     }
3268     return true;
3269   } else {
3270 
3271     // when NUMAInterleaving is enabled, the commit might cover a range that
3272     // came from multiple VirtualAlloc reserves (using allocate_pages_individually).
3273     // VirtualQuery can help us determine that.  The RegionSize that VirtualQuery
3274     // returns represents the number of bytes that can be committed in one step.
3275     size_t bytes_remaining = bytes;
3276     char * next_alloc_addr = addr;
3277     while (bytes_remaining &gt; 0) {
3278       MEMORY_BASIC_INFORMATION alloc_info;
3279       VirtualQuery(next_alloc_addr, &amp;alloc_info, sizeof(alloc_info));
3280       size_t bytes_to_rq = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3281       if (VirtualAlloc(next_alloc_addr, bytes_to_rq, MEM_COMMIT,
3282                        PAGE_READWRITE) == NULL) {
3283         NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3284                                             exec);)
3285         return false;
3286       }
3287       if (exec) {
3288         DWORD oldprot;
3289         if (!VirtualProtect(next_alloc_addr, bytes_to_rq,
3290                             PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3291           NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3292                                               exec);)
3293           return false;
3294         }
3295       }
3296       bytes_remaining -= bytes_to_rq;
3297       next_alloc_addr += bytes_to_rq;
3298     }
3299   }
3300   // if we made it this far, return true
3301   return true;
3302 }
3303 
3304 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
3305                           bool exec) {
3306   // alignment_hint is ignored on this OS
3307   return pd_commit_memory(addr, size, exec);
3308 }
3309 
3310 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
3311                                   const char* mesg) {
3312   assert(mesg != NULL, &quot;mesg must be specified&quot;);
3313   if (!pd_commit_memory(addr, size, exec)) {
3314     warn_fail_commit_memory(addr, size, exec);
3315     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
3316   }
3317 }
3318 
3319 void os::pd_commit_memory_or_exit(char* addr, size_t size,
3320                                   size_t alignment_hint, bool exec,
3321                                   const char* mesg) {
3322   // alignment_hint is ignored on this OS
3323   pd_commit_memory_or_exit(addr, size, exec, mesg);
3324 }
3325 
3326 bool os::pd_uncommit_memory(char* addr, size_t bytes) {
3327   if (bytes == 0) {
3328     // Don&#39;t bother the OS with noops.
3329     return true;
3330   }
3331   assert((size_t) addr % os::vm_page_size() == 0, &quot;uncommit on page boundaries&quot;);
3332   assert(bytes % os::vm_page_size() == 0, &quot;uncommit in page-sized chunks&quot;);
3333   return (VirtualFree(addr, bytes, MEM_DECOMMIT) != 0);
3334 }
3335 
3336 bool os::pd_release_memory(char* addr, size_t bytes) {
3337   return VirtualFree(addr, 0, MEM_RELEASE) != 0;
3338 }
3339 
3340 bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
3341   return os::commit_memory(addr, size, !ExecMem);
3342 }
3343 
3344 bool os::remove_stack_guard_pages(char* addr, size_t size) {
3345   return os::uncommit_memory(addr, size);
3346 }
3347 
3348 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
3349   uint count = 0;
3350   bool ret = false;
3351   size_t bytes_remaining = bytes;
3352   char * next_protect_addr = addr;
3353 
3354   // Use VirtualQuery() to get the chunk size.
3355   while (bytes_remaining) {
3356     MEMORY_BASIC_INFORMATION alloc_info;
3357     if (VirtualQuery(next_protect_addr, &amp;alloc_info, sizeof(alloc_info)) == 0) {
3358       return false;
3359     }
3360 
3361     size_t bytes_to_protect = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3362     // We used different API at allocate_pages_individually() based on UseNUMAInterleaving,
3363     // but we don&#39;t distinguish here as both cases are protected by same API.
3364     ret = VirtualProtect(next_protect_addr, bytes_to_protect, p, old_status) != 0;
3365     warning(&quot;Failed protecting pages individually for chunk #%u&quot;, count);
3366     if (!ret) {
3367       return false;
3368     }
3369 
3370     bytes_remaining -= bytes_to_protect;
3371     next_protect_addr += bytes_to_protect;
3372     count++;
3373   }
3374   return ret;
3375 }
3376 
3377 // Set protections specified
3378 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
3379                         bool is_committed) {
3380   unsigned int p = 0;
3381   switch (prot) {
3382   case MEM_PROT_NONE: p = PAGE_NOACCESS; break;
3383   case MEM_PROT_READ: p = PAGE_READONLY; break;
3384   case MEM_PROT_RW:   p = PAGE_READWRITE; break;
3385   case MEM_PROT_RWX:  p = PAGE_EXECUTE_READWRITE; break;
3386   default:
3387     ShouldNotReachHere();
3388   }
3389 
3390   DWORD old_status;
3391 
3392   // Strange enough, but on Win32 one can change protection only for committed
3393   // memory, not a big deal anyway, as bytes less or equal than 64K
3394   if (!is_committed) {
3395     commit_memory_or_exit(addr, bytes, prot == MEM_PROT_RWX,
3396                           &quot;cannot commit protection page&quot;);
3397   }
3398   // One cannot use os::guard_memory() here, as on Win32 guard page
3399   // have different (one-shot) semantics, from MSDN on PAGE_GUARD:
3400   //
3401   // Pages in the region become guard pages. Any attempt to access a guard page
3402   // causes the system to raise a STATUS_GUARD_PAGE exception and turn off
3403   // the guard page status. Guard pages thus act as a one-time access alarm.
3404   bool ret;
3405   if (UseNUMAInterleaving) {
3406     // If UseNUMAInterleaving is enabled, the pages may have been allocated a chunk at a time,
3407     // so we must protect the chunks individually.
3408     ret = protect_pages_individually(addr, bytes, p, &amp;old_status);
3409   } else {
3410     ret = VirtualProtect(addr, bytes, p, &amp;old_status) != 0;
3411   }
3412 #ifdef ASSERT
3413   if (!ret) {
3414     int err = os::get_last_error();
3415     char buf[256];
3416     size_t buf_len = os::lasterror(buf, sizeof(buf));
3417     warning(&quot;INFO: os::protect_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3418           &quot;) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3419           buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3420   }
3421 #endif
3422   return ret;
3423 }
3424 
3425 bool os::guard_memory(char* addr, size_t bytes) {
3426   DWORD old_status;
3427   return VirtualProtect(addr, bytes, PAGE_READWRITE | PAGE_GUARD, &amp;old_status) != 0;
3428 }
3429 
3430 bool os::unguard_memory(char* addr, size_t bytes) {
3431   DWORD old_status;
3432   return VirtualProtect(addr, bytes, PAGE_READWRITE, &amp;old_status) != 0;
3433 }
3434 
3435 void os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3436 void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3437 void os::numa_make_global(char *addr, size_t bytes)    { }
3438 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint)    { }
3439 bool os::numa_topology_changed()                       { return false; }
3440 size_t os::numa_get_groups_num()                       { return MAX2(numa_node_list_holder.get_count(), 1); }
3441 int os::numa_get_group_id()                            { return 0; }
3442 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
3443   if (numa_node_list_holder.get_count() == 0 &amp;&amp; size &gt; 0) {
3444     // Provide an answer for UMA systems
3445     ids[0] = 0;
3446     return 1;
3447   } else {
3448     // check for size bigger than actual groups_num
3449     size = MIN2(size, numa_get_groups_num());
3450     for (int i = 0; i &lt; (int)size; i++) {
3451       ids[i] = numa_node_list_holder.get_node_list_entry(i);
3452     }
3453     return size;
3454   }
3455 }
3456 
3457 int os::numa_get_group_id_for_address(const void* address) {
3458   return 0;
3459 }
3460 
3461 bool os::get_page_info(char *start, page_info* info) {
3462   return false;
3463 }
3464 
3465 char *os::scan_pages(char *start, char* end, page_info* page_expected,
3466                      page_info* page_found) {
3467   return end;
3468 }
3469 
3470 char* os::non_memory_address_word() {
3471   // Must never look like an address returned by reserve_memory,
3472   // even in its subfields (as defined by the CPU immediate fields,
3473   // if the CPU splits constants across multiple instructions).
<a name="38" id="anc38"></a>



3474   return (char*)-1;
<a name="39" id="anc39"></a>
3475 }
3476 
3477 #define MAX_ERROR_COUNT 100
3478 #define SYS_THREAD_ERROR 0xffffffffUL
3479 
3480 void os::pd_start_thread(Thread* thread) {
3481   DWORD ret = ResumeThread(thread-&gt;osthread()-&gt;thread_handle());
3482   // Returns previous suspend state:
3483   // 0:  Thread was not suspended
3484   // 1:  Thread is running now
3485   // &gt;1: Thread is still suspended.
3486   assert(ret != SYS_THREAD_ERROR, &quot;StartThread failed&quot;); // should propagate back
3487 }
3488 
3489 
3490 // Short sleep, direct OS call.
3491 //
3492 // ms = 0, means allow others (if any) to run.
3493 //
3494 void os::naked_short_sleep(jlong ms) {
3495   assert(ms &lt; 1000, &quot;Un-interruptable sleep, short time use only&quot;);
3496   Sleep(ms);
3497 }
3498 
3499 // Windows does not provide sleep functionality with nanosecond resolution, so we
3500 // try to approximate this with spinning combined with yielding if another thread
3501 // is ready to run on the current processor.
3502 void os::naked_short_nanosleep(jlong ns) {
3503   assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
3504 
3505   int64_t start = os::javaTimeNanos();
3506   do {
3507     if (SwitchToThread() == 0) {
3508       // Nothing else is ready to run on this cpu, spin a little
3509       SpinPause();
3510     }
3511   } while (os::javaTimeNanos() - start &lt; ns);
3512 }
3513 
3514 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
3515 void os::infinite_sleep() {
3516   while (true) {    // sleep forever ...
3517     Sleep(100000);  // ... 100 seconds at a time
3518   }
3519 }
3520 
3521 typedef BOOL (WINAPI * STTSignature)(void);
3522 
3523 void os::naked_yield() {
3524   // Consider passing back the return value from SwitchToThread().
3525   SwitchToThread();
3526 }
3527 
3528 // Win32 only gives you access to seven real priorities at a time,
3529 // so we compress Java&#39;s ten down to seven.  It would be better
3530 // if we dynamically adjusted relative priorities.
3531 
3532 int os::java_to_os_priority[CriticalPriority + 1] = {
3533   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3534   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3535   THREAD_PRIORITY_LOWEST,                       // 2
3536   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3537   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3538   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3539   THREAD_PRIORITY_NORMAL,                       // 6
3540   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3541   THREAD_PRIORITY_ABOVE_NORMAL,                 // 8
3542   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3543   THREAD_PRIORITY_HIGHEST,                      // 10 MaxPriority
3544   THREAD_PRIORITY_HIGHEST                       // 11 CriticalPriority
3545 };
3546 
3547 int prio_policy1[CriticalPriority + 1] = {
3548   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3549   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3550   THREAD_PRIORITY_LOWEST,                       // 2
3551   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3552   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3553   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3554   THREAD_PRIORITY_ABOVE_NORMAL,                 // 6
3555   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3556   THREAD_PRIORITY_HIGHEST,                      // 8
3557   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3558   THREAD_PRIORITY_TIME_CRITICAL,                // 10 MaxPriority
3559   THREAD_PRIORITY_TIME_CRITICAL                 // 11 CriticalPriority
3560 };
3561 
3562 static int prio_init() {
3563   // If ThreadPriorityPolicy is 1, switch tables
3564   if (ThreadPriorityPolicy == 1) {
3565     int i;
3566     for (i = 0; i &lt; CriticalPriority + 1; i++) {
3567       os::java_to_os_priority[i] = prio_policy1[i];
3568     }
3569   }
3570   if (UseCriticalJavaThreadPriority) {
3571     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
3572   }
3573   return 0;
3574 }
3575 
3576 OSReturn os::set_native_priority(Thread* thread, int priority) {
3577   if (!UseThreadPriorities) return OS_OK;
3578   bool ret = SetThreadPriority(thread-&gt;osthread()-&gt;thread_handle(), priority) != 0;
3579   return ret ? OS_OK : OS_ERR;
3580 }
3581 
3582 OSReturn os::get_native_priority(const Thread* const thread,
3583                                  int* priority_ptr) {
3584   if (!UseThreadPriorities) {
3585     *priority_ptr = java_to_os_priority[NormPriority];
3586     return OS_OK;
3587   }
3588   int os_prio = GetThreadPriority(thread-&gt;osthread()-&gt;thread_handle());
3589   if (os_prio == THREAD_PRIORITY_ERROR_RETURN) {
3590     assert(false, &quot;GetThreadPriority failed&quot;);
3591     return OS_ERR;
3592   }
3593   *priority_ptr = os_prio;
3594   return OS_OK;
3595 }
3596 
3597 // GetCurrentThreadId() returns DWORD
3598 intx os::current_thread_id()  { return GetCurrentThreadId(); }
3599 
3600 static int _initial_pid = 0;
3601 
3602 int os::current_process_id() {
3603   return (_initial_pid ? _initial_pid : _getpid());
3604 }
3605 
3606 int    os::win32::_vm_page_size              = 0;
3607 int    os::win32::_vm_allocation_granularity = 0;
3608 int    os::win32::_processor_type            = 0;
3609 // Processor level is not available on non-NT systems, use vm_version instead
3610 int    os::win32::_processor_level           = 0;
3611 julong os::win32::_physical_memory           = 0;
3612 size_t os::win32::_default_stack_size        = 0;
3613 
3614 intx          os::win32::_os_thread_limit    = 0;
3615 volatile intx os::win32::_os_thread_count    = 0;
3616 
3617 bool   os::win32::_is_windows_server         = false;
3618 
3619 // 6573254
3620 // Currently, the bug is observed across all the supported Windows releases,
3621 // including the latest one (as of this writing - Windows Server 2012 R2)
3622 bool   os::win32::_has_exit_bug              = true;
3623 
3624 void os::win32::initialize_system_info() {
3625   SYSTEM_INFO si;
3626   GetSystemInfo(&amp;si);
3627   _vm_page_size    = si.dwPageSize;
3628   _vm_allocation_granularity = si.dwAllocationGranularity;
3629   _processor_type  = si.dwProcessorType;
3630   _processor_level = si.wProcessorLevel;
3631   set_processor_count(si.dwNumberOfProcessors);
3632 
3633   MEMORYSTATUSEX ms;
3634   ms.dwLength = sizeof(ms);
3635 
3636   // also returns dwAvailPhys (free physical memory bytes), dwTotalVirtual, dwAvailVirtual,
3637   // dwMemoryLoad (% of memory in use)
3638   GlobalMemoryStatusEx(&amp;ms);
3639   _physical_memory = ms.ullTotalPhys;
3640 
3641   if (FLAG_IS_DEFAULT(MaxRAM)) {
3642     // Adjust MaxRAM according to the maximum virtual address space available.
3643     FLAG_SET_DEFAULT(MaxRAM, MIN2(MaxRAM, (uint64_t) ms.ullTotalVirtual));
3644   }
3645 
3646   OSVERSIONINFOEX oi;
3647   oi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
3648   GetVersionEx((OSVERSIONINFO*)&amp;oi);
3649   switch (oi.dwPlatformId) {
3650   case VER_PLATFORM_WIN32_NT:
3651     {
3652       int os_vers = oi.dwMajorVersion * 1000 + oi.dwMinorVersion;
3653       if (oi.wProductType == VER_NT_DOMAIN_CONTROLLER ||
3654           oi.wProductType == VER_NT_SERVER) {
3655         _is_windows_server = true;
3656       }
3657     }
3658     break;
3659   default: fatal(&quot;Unknown platform&quot;);
3660   }
3661 
3662   _default_stack_size = os::current_stack_size();
3663   assert(_default_stack_size &gt; (size_t) _vm_page_size, &quot;invalid stack size&quot;);
3664   assert((_default_stack_size &amp; (_vm_page_size - 1)) == 0,
3665          &quot;stack size not a multiple of page size&quot;);
3666 
3667   initialize_performance_counter();
3668 }
3669 
<a name="40" id="anc40"></a>



























3670 
3671 HINSTANCE os::win32::load_Windows_dll(const char* name, char *ebuf,
3672                                       int ebuflen) {
3673   char path[MAX_PATH];
3674   DWORD size;
3675   DWORD pathLen = (DWORD)sizeof(path);
3676   HINSTANCE result = NULL;
3677 
3678   // only allow library name without path component
3679   assert(strchr(name, &#39;\\&#39;) == NULL, &quot;path not allowed&quot;);
3680   assert(strchr(name, &#39;:&#39;) == NULL, &quot;path not allowed&quot;);
3681   if (strchr(name, &#39;\\&#39;) != NULL || strchr(name, &#39;:&#39;) != NULL) {
3682     jio_snprintf(ebuf, ebuflen,
3683                  &quot;Invalid parameter while calling os::win32::load_windows_dll(): cannot take path: %s&quot;, name);
3684     return NULL;
3685   }
3686 
3687   // search system directory
3688   if ((size = GetSystemDirectory(path, pathLen)) &gt; 0) {
3689     if (size &gt;= pathLen) {
3690       return NULL; // truncated
3691     }
3692     if (jio_snprintf(path + size, pathLen - size, &quot;\\%s&quot;, name) == -1) {
3693       return NULL; // truncated
3694     }
3695     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3696       return result;
3697     }
3698   }
3699 
3700   // try Windows directory
3701   if ((size = GetWindowsDirectory(path, pathLen)) &gt; 0) {
3702     if (size &gt;= pathLen) {
3703       return NULL; // truncated
3704     }
3705     if (jio_snprintf(path + size, pathLen - size, &quot;\\%s&quot;, name) == -1) {
3706       return NULL; // truncated
3707     }
3708     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3709       return result;
3710     }
3711   }
3712 
3713   jio_snprintf(ebuf, ebuflen,
3714                &quot;os::win32::load_windows_dll() cannot load %s from system directories.&quot;, name);
3715   return NULL;
3716 }
3717 
3718 #define MAXIMUM_THREADS_TO_KEEP (16 * MAXIMUM_WAIT_OBJECTS)
3719 #define EXIT_TIMEOUT 300000 /* 5 minutes */
3720 
3721 static BOOL CALLBACK init_crit_sect_call(PINIT_ONCE, PVOID pcrit_sect, PVOID*) {
3722   InitializeCriticalSection((CRITICAL_SECTION*)pcrit_sect);
3723   return TRUE;
3724 }
3725 
3726 int os::win32::exit_process_or_thread(Ept what, int exit_code) {
3727   // Basic approach:
3728   //  - Each exiting thread registers its intent to exit and then does so.
3729   //  - A thread trying to terminate the process must wait for all
3730   //    threads currently exiting to complete their exit.
3731 
3732   if (os::win32::has_exit_bug()) {
3733     // The array holds handles of the threads that have started exiting by calling
3734     // _endthreadex().
3735     // Should be large enough to avoid blocking the exiting thread due to lack of
3736     // a free slot.
3737     static HANDLE handles[MAXIMUM_THREADS_TO_KEEP];
3738     static int handle_count = 0;
3739 
3740     static INIT_ONCE init_once_crit_sect = INIT_ONCE_STATIC_INIT;
3741     static CRITICAL_SECTION crit_sect;
3742     static volatile DWORD process_exiting = 0;
3743     int i, j;
3744     DWORD res;
3745     HANDLE hproc, hthr;
3746 
3747     // We only attempt to register threads until a process exiting
3748     // thread manages to set the process_exiting flag. Any threads
3749     // that come through here after the process_exiting flag is set
3750     // are unregistered and will be caught in the SuspendThread()
3751     // infinite loop below.
3752     bool registered = false;
3753 
3754     // The first thread that reached this point, initializes the critical section.
3755     if (!InitOnceExecuteOnce(&amp;init_once_crit_sect, init_crit_sect_call, &amp;crit_sect, NULL)) {
3756       warning(&quot;crit_sect initialization failed in %s: %d\n&quot;, __FILE__, __LINE__);
3757     } else if (Atomic::load_acquire(&amp;process_exiting) == 0) {
3758       if (what != EPT_THREAD) {
3759         // Atomically set process_exiting before the critical section
3760         // to increase the visibility between racing threads.
3761         Atomic::cmpxchg(&amp;process_exiting, (DWORD)0, GetCurrentThreadId());
3762       }
3763       EnterCriticalSection(&amp;crit_sect);
3764 
3765       if (what == EPT_THREAD &amp;&amp; Atomic::load_acquire(&amp;process_exiting) == 0) {
3766         // Remove from the array those handles of the threads that have completed exiting.
3767         for (i = 0, j = 0; i &lt; handle_count; ++i) {
3768           res = WaitForSingleObject(handles[i], 0 /* don&#39;t wait */);
3769           if (res == WAIT_TIMEOUT) {
3770             handles[j++] = handles[i];
3771           } else {
3772             if (res == WAIT_FAILED) {
3773               warning(&quot;WaitForSingleObject failed (%u) in %s: %d\n&quot;,
3774                       GetLastError(), __FILE__, __LINE__);
3775             }
3776             // Don&#39;t keep the handle, if we failed waiting for it.
3777             CloseHandle(handles[i]);
3778           }
3779         }
3780 
3781         // If there&#39;s no free slot in the array of the kept handles, we&#39;ll have to
3782         // wait until at least one thread completes exiting.
3783         if ((handle_count = j) == MAXIMUM_THREADS_TO_KEEP) {
3784           // Raise the priority of the oldest exiting thread to increase its chances
3785           // to complete sooner.
3786           SetThreadPriority(handles[0], THREAD_PRIORITY_ABOVE_NORMAL);
3787           res = WaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, handles, FALSE, EXIT_TIMEOUT);
3788           if (res &gt;= WAIT_OBJECT_0 &amp;&amp; res &lt; (WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS)) {
3789             i = (res - WAIT_OBJECT_0);
3790             handle_count = MAXIMUM_THREADS_TO_KEEP - 1;
3791             for (; i &lt; handle_count; ++i) {
3792               handles[i] = handles[i + 1];
3793             }
3794           } else {
3795             warning(&quot;WaitForMultipleObjects %s (%u) in %s: %d\n&quot;,
3796                     (res == WAIT_FAILED ? &quot;failed&quot; : &quot;timed out&quot;),
3797                     GetLastError(), __FILE__, __LINE__);
3798             // Don&#39;t keep handles, if we failed waiting for them.
3799             for (i = 0; i &lt; MAXIMUM_THREADS_TO_KEEP; ++i) {
3800               CloseHandle(handles[i]);
3801             }
3802             handle_count = 0;
3803           }
3804         }
3805 
3806         // Store a duplicate of the current thread handle in the array of handles.
3807         hproc = GetCurrentProcess();
3808         hthr = GetCurrentThread();
3809         if (!DuplicateHandle(hproc, hthr, hproc, &amp;handles[handle_count],
3810                              0, FALSE, DUPLICATE_SAME_ACCESS)) {
3811           warning(&quot;DuplicateHandle failed (%u) in %s: %d\n&quot;,
3812                   GetLastError(), __FILE__, __LINE__);
3813 
3814           // We can&#39;t register this thread (no more handles) so this thread
3815           // may be racing with a thread that is calling exit(). If the thread
3816           // that is calling exit() has managed to set the process_exiting
3817           // flag, then this thread will be caught in the SuspendThread()
3818           // infinite loop below which closes that race. A small timing
3819           // window remains before the process_exiting flag is set, but it
3820           // is only exposed when we are out of handles.
3821         } else {
3822           ++handle_count;
3823           registered = true;
3824 
3825           // The current exiting thread has stored its handle in the array, and now
3826           // should leave the critical section before calling _endthreadex().
3827         }
3828 
3829       } else if (what != EPT_THREAD &amp;&amp; handle_count &gt; 0) {
3830         jlong start_time, finish_time, timeout_left;
3831         // Before ending the process, make sure all the threads that had called
3832         // _endthreadex() completed.
3833 
3834         // Set the priority level of the current thread to the same value as
3835         // the priority level of exiting threads.
3836         // This is to ensure it will be given a fair chance to execute if
3837         // the timeout expires.
3838         hthr = GetCurrentThread();
3839         SetThreadPriority(hthr, THREAD_PRIORITY_ABOVE_NORMAL);
3840         start_time = os::javaTimeNanos();
3841         finish_time = start_time + ((jlong)EXIT_TIMEOUT * 1000000L);
3842         for (i = 0; ; ) {
3843           int portion_count = handle_count - i;
3844           if (portion_count &gt; MAXIMUM_WAIT_OBJECTS) {
3845             portion_count = MAXIMUM_WAIT_OBJECTS;
3846           }
3847           for (j = 0; j &lt; portion_count; ++j) {
3848             SetThreadPriority(handles[i + j], THREAD_PRIORITY_ABOVE_NORMAL);
3849           }
3850           timeout_left = (finish_time - start_time) / 1000000L;
3851           if (timeout_left &lt; 0) {
3852             timeout_left = 0;
3853           }
3854           res = WaitForMultipleObjects(portion_count, handles + i, TRUE, timeout_left);
3855           if (res == WAIT_FAILED || res == WAIT_TIMEOUT) {
3856             warning(&quot;WaitForMultipleObjects %s (%u) in %s: %d\n&quot;,
3857                     (res == WAIT_FAILED ? &quot;failed&quot; : &quot;timed out&quot;),
3858                     GetLastError(), __FILE__, __LINE__);
3859             // Reset portion_count so we close the remaining
3860             // handles due to this error.
3861             portion_count = handle_count - i;
3862           }
3863           for (j = 0; j &lt; portion_count; ++j) {
3864             CloseHandle(handles[i + j]);
3865           }
3866           if ((i += portion_count) &gt;= handle_count) {
3867             break;
3868           }
3869           start_time = os::javaTimeNanos();
3870         }
3871         handle_count = 0;
3872       }
3873 
3874       LeaveCriticalSection(&amp;crit_sect);
3875     }
3876 
3877     if (!registered &amp;&amp;
3878         Atomic::load_acquire(&amp;process_exiting) != 0 &amp;&amp;
3879         process_exiting != GetCurrentThreadId()) {
3880       // Some other thread is about to call exit(), so we don&#39;t let
3881       // the current unregistered thread proceed to exit() or _endthreadex()
3882       while (true) {
3883         SuspendThread(GetCurrentThread());
3884         // Avoid busy-wait loop, if SuspendThread() failed.
3885         Sleep(EXIT_TIMEOUT);
3886       }
3887     }
3888   }
3889 
3890   // We are here if either
3891   // - there&#39;s no &#39;race at exit&#39; bug on this OS release;
3892   // - initialization of the critical section failed (unlikely);
3893   // - the current thread has registered itself and left the critical section;
3894   // - the process-exiting thread has raised the flag and left the critical section.
3895   if (what == EPT_THREAD) {
3896     _endthreadex((unsigned)exit_code);
3897   } else if (what == EPT_PROCESS) {
3898     ::exit(exit_code);
3899   } else {
3900     _exit(exit_code);
3901   }
3902 
3903   // Should not reach here
3904   return exit_code;
3905 }
3906 
3907 #undef EXIT_TIMEOUT
3908 
3909 void os::win32::setmode_streams() {
3910   _setmode(_fileno(stdin), _O_BINARY);
3911   _setmode(_fileno(stdout), _O_BINARY);
3912   _setmode(_fileno(stderr), _O_BINARY);
3913 }
3914 
3915 void os::wait_for_keypress_at_exit(void) {
3916   if (PauseAtExit) {
3917     fprintf(stderr, &quot;Press any key to continue...\n&quot;);
3918     fgetc(stdin);
3919   }
3920 }
3921 
3922 
3923 bool os::message_box(const char* title, const char* message) {
3924   int result = MessageBox(NULL, message, title,
3925                           MB_YESNO | MB_ICONERROR | MB_SYSTEMMODAL | MB_DEFAULT_DESKTOP_ONLY);
3926   return result == IDYES;
3927 }
3928 
3929 #ifndef PRODUCT
3930 #ifndef _WIN64
3931 // Helpers to check whether NX protection is enabled
3932 int nx_exception_filter(_EXCEPTION_POINTERS *pex) {
3933   if (pex-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION &amp;&amp;
3934       pex-&gt;ExceptionRecord-&gt;NumberParameters &gt; 0 &amp;&amp;
3935       pex-&gt;ExceptionRecord-&gt;ExceptionInformation[0] ==
3936       EXCEPTION_INFO_EXEC_VIOLATION) {
3937     return EXCEPTION_EXECUTE_HANDLER;
3938   }
3939   return EXCEPTION_CONTINUE_SEARCH;
3940 }
3941 
3942 void nx_check_protection() {
3943   // If NX is enabled we&#39;ll get an exception calling into code on the stack
3944   char code[] = { (char)0xC3 }; // ret
3945   void *code_ptr = (void *)code;
3946   __try {
3947     __asm call code_ptr
3948   } __except(nx_exception_filter((_EXCEPTION_POINTERS*)_exception_info())) {
3949     tty-&gt;print_raw_cr(&quot;NX protection detected.&quot;);
3950   }
3951 }
3952 #endif // _WIN64
3953 #endif // PRODUCT
3954 
3955 // This is called _before_ the global arguments have been parsed
3956 void os::init(void) {
3957   _initial_pid = _getpid();
3958 
3959   init_random(1234567);
3960 
3961   win32::initialize_system_info();
3962   win32::setmode_streams();
3963   init_page_sizes((size_t) win32::vm_page_size());
3964 
3965   // This may be overridden later when argument processing is done.
3966   FLAG_SET_ERGO(UseLargePagesIndividualAllocation, false);
3967 
3968   // Initialize main_process and main_thread
3969   main_process = GetCurrentProcess();  // Remember main_process is a pseudo handle
3970   if (!DuplicateHandle(main_process, GetCurrentThread(), main_process,
3971                        &amp;main_thread, THREAD_ALL_ACCESS, false, 0)) {
3972     fatal(&quot;DuplicateHandle failed\n&quot;);
3973   }
3974   main_thread_id = (int) GetCurrentThreadId();
3975 
3976   // initialize fast thread access - only used for 32-bit
3977   win32::initialize_thread_ptr_offset();
3978 }
3979 
3980 // To install functions for atexit processing
3981 extern &quot;C&quot; {
3982   static void perfMemory_exit_helper() {
3983     perfMemory_exit();
3984   }
3985 }
3986 
3987 static jint initSock();
3988 
3989 // this is called _after_ the global arguments have been parsed
3990 jint os::init_2(void) {
3991 
3992   // This could be set any time but all platforms
3993   // have to set it the same so we have to mirror Solaris.
3994   DEBUG_ONLY(os::set_mutex_init_done();)
3995 
3996   // Setup Windows Exceptions
<a name="41" id="anc41"></a><span class="line-modified">3997 </span>
<span class="line-removed">3998 #if INCLUDE_AOT</span>
<span class="line-removed">3999   // If AOT is enabled we need to install a vectored exception handler</span>
<span class="line-removed">4000   // in order to forward implicit exceptions from code in AOT</span>
<span class="line-removed">4001   // generated DLLs.  This is necessary since these DLLs are not</span>
<span class="line-removed">4002   // registered for structured exceptions like codecache methods are.</span>
<span class="line-removed">4003   if (AOTLibrary != NULL &amp;&amp; (UseAOT || FLAG_IS_DEFAULT(UseAOT))) {</span>
<span class="line-removed">4004     topLevelVectoredExceptionHandler = AddVectoredExceptionHandler( 1, topLevelVectoredExceptionFilter);</span>
<span class="line-removed">4005   }</span>
<span class="line-removed">4006 #endif</span>
4007 
4008   // for debugging float code generation bugs
4009   if (ForceFloatExceptions) {
4010 #ifndef  _WIN64
4011     static long fp_control_word = 0;
4012     __asm { fstcw fp_control_word }
4013     // see Intel PPro Manual, Vol. 2, p 7-16
4014     const long precision = 0x20;
4015     const long underflow = 0x10;
4016     const long overflow  = 0x08;
4017     const long zero_div  = 0x04;
4018     const long denorm    = 0x02;
4019     const long invalid   = 0x01;
4020     fp_control_word |= invalid;
4021     __asm { fldcw fp_control_word }
4022 #endif
4023   }
4024 
4025   // If stack_commit_size is 0, windows will reserve the default size,
4026   // but only commit a small portion of it.
4027   size_t stack_commit_size = align_up(ThreadStackSize*K, os::vm_page_size());
4028   size_t default_reserve_size = os::win32::default_stack_size();
4029   size_t actual_reserve_size = stack_commit_size;
4030   if (stack_commit_size &lt; default_reserve_size) {
4031     // If stack_commit_size == 0, we want this too
4032     actual_reserve_size = default_reserve_size;
4033   }
4034 
4035   // Check minimum allowable stack size for thread creation and to initialize
4036   // the java system classes, including StackOverflowError - depends on page
4037   // size.  Add two 4K pages for compiler2 recursion in main thread.
4038   // Add in 4*BytesPerWord 4K pages to account for VM stack during
4039   // class initialization depending on 32 or 64 bit VM.
4040   size_t min_stack_allowed =
4041             (size_t)(JavaThread::stack_guard_zone_size() +
4042                      JavaThread::stack_shadow_zone_size() +
4043                      (4*BytesPerWord COMPILER2_PRESENT(+2)) * 4 * K);
4044 
4045   min_stack_allowed = align_up(min_stack_allowed, os::vm_page_size());
4046 
4047   if (actual_reserve_size &lt; min_stack_allowed) {
4048     tty-&gt;print_cr(&quot;\nThe Java thread stack size specified is too small. &quot;
4049                   &quot;Specify at least %dk&quot;,
4050                   min_stack_allowed / K);
4051     return JNI_ERR;
4052   }
4053 
4054   JavaThread::set_stack_size_at_create(stack_commit_size);
4055 
4056   // Calculate theoretical max. size of Threads to guard gainst artifical
4057   // out-of-memory situations, where all available address-space has been
4058   // reserved by thread stacks.
4059   assert(actual_reserve_size != 0, &quot;Must have a stack&quot;);
4060 
4061   // Calculate the thread limit when we should start doing Virtual Memory
4062   // banging. Currently when the threads will have used all but 200Mb of space.
4063   //
4064   // TODO: consider performing a similar calculation for commit size instead
4065   // as reserve size, since on a 64-bit platform we&#39;ll run into that more
4066   // often than running out of virtual memory space.  We can use the
4067   // lower value of the two calculations as the os_thread_limit.
4068   size_t max_address_space = ((size_t)1 &lt;&lt; (BitsPerWord - 1)) - (200 * K * K);
4069   win32::_os_thread_limit = (intx)(max_address_space / actual_reserve_size);
4070 
4071   // at exit methods are called in the reverse order of their registration.
4072   // there is no limit to the number of functions registered. atexit does
4073   // not set errno.
4074 
4075   if (PerfAllowAtExitRegistration) {
4076     // only register atexit functions if PerfAllowAtExitRegistration is set.
4077     // atexit functions can be delayed until process exit time, which
4078     // can be problematic for embedded VM situations. Embedded VMs should
4079     // call DestroyJavaVM() to assure that VM resources are released.
4080 
4081     // note: perfMemory_exit_helper atexit function may be removed in
4082     // the future if the appropriate cleanup code can be added to the
4083     // VM_Exit VMOperation&#39;s doit method.
4084     if (atexit(perfMemory_exit_helper) != 0) {
4085       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
4086     }
4087   }
4088 
4089 #ifndef _WIN64
4090   // Print something if NX is enabled (win32 on AMD64)
4091   NOT_PRODUCT(if (PrintMiscellaneous &amp;&amp; Verbose) nx_check_protection());
4092 #endif
4093 
4094   // initialize thread priority policy
4095   prio_init();
4096 
4097   if (UseNUMA &amp;&amp; !ForceNUMA) {
4098     UseNUMA = false; // We don&#39;t fully support this yet
4099   }
4100 
<a name="42" id="anc42"></a><span class="line-modified">4101   if (UseNUMAInterleaving) {</span>
4102     // first check whether this Windows OS supports VirtualAllocExNuma, if not ignore this flag
4103     bool success = numa_interleaving_init();
4104     if (!success) UseNUMAInterleaving = false;
4105   }
4106 
4107   if (initSock() != JNI_OK) {
4108     return JNI_ERR;
4109   }
4110 
4111   SymbolEngine::recalc_search_path();
4112 
4113   // Initialize data for jdk.internal.misc.Signal
4114   if (!ReduceSignalUsage) {
4115     jdk_misc_signal_init();
4116   }
4117 
4118   return JNI_OK;
4119 }
4120 
4121 // Mark the polling page as unreadable
4122 void os::make_polling_page_unreadable(void) {
4123   DWORD old_status;
4124   if (!VirtualProtect((char *)_polling_page, os::vm_page_size(),
4125                       PAGE_NOACCESS, &amp;old_status)) {
4126     fatal(&quot;Could not disable polling page&quot;);
4127   }
4128 }
4129 
4130 // Mark the polling page as readable
4131 void os::make_polling_page_readable(void) {
4132   DWORD old_status;
4133   if (!VirtualProtect((char *)_polling_page, os::vm_page_size(),
4134                       PAGE_READONLY, &amp;old_status)) {
4135     fatal(&quot;Could not enable polling page&quot;);
4136   }
4137 }
4138 
4139 // combine the high and low DWORD into a ULONGLONG
4140 static ULONGLONG make_double_word(DWORD high_word, DWORD low_word) {
4141   ULONGLONG value = high_word;
4142   value &lt;&lt;= sizeof(high_word) * 8;
4143   value |= low_word;
4144   return value;
4145 }
4146 
4147 // Transfers data from WIN32_FILE_ATTRIBUTE_DATA structure to struct stat
4148 static void file_attribute_data_to_stat(struct stat* sbuf, WIN32_FILE_ATTRIBUTE_DATA file_data) {
4149   ::memset((void*)sbuf, 0, sizeof(struct stat));
4150   sbuf-&gt;st_size = (_off_t)make_double_word(file_data.nFileSizeHigh, file_data.nFileSizeLow);
4151   sbuf-&gt;st_mtime = make_double_word(file_data.ftLastWriteTime.dwHighDateTime,
4152                                   file_data.ftLastWriteTime.dwLowDateTime);
4153   sbuf-&gt;st_ctime = make_double_word(file_data.ftCreationTime.dwHighDateTime,
4154                                   file_data.ftCreationTime.dwLowDateTime);
4155   sbuf-&gt;st_atime = make_double_word(file_data.ftLastAccessTime.dwHighDateTime,
4156                                   file_data.ftLastAccessTime.dwLowDateTime);
4157   if ((file_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
4158     sbuf-&gt;st_mode |= S_IFDIR;
4159   } else {
4160     sbuf-&gt;st_mode |= S_IFREG;
4161   }
4162 }
4163 
4164 // Returns the given path as an absolute wide path in unc format. The returned path is NULL
4165 // on error (with err being set accordingly) and should be freed via os::free() otherwise.
4166 // additional_space is the number of additionally allocated wchars after the terminating L&#39;\0&#39;.
4167 // This is based on pathToNTPath() in io_util_md.cpp, but omits the optimizations for
4168 // short paths.
4169 static wchar_t* wide_abs_unc_path(char const* path, errno_t &amp; err, int additional_space = 0) {
4170   if ((path == NULL) || (path[0] == &#39;\0&#39;)) {
4171     err = ENOENT;
4172     return NULL;
4173   }
4174 
4175   size_t path_len = strlen(path);
4176   // Need to allocate at least room for 3 characters, since os::native_path transforms C: to C:.
4177   char* buf = (char*) os::malloc(1 + MAX2((size_t) 3, path_len), mtInternal);
4178   wchar_t* result = NULL;
4179 
4180   if (buf == NULL) {
4181     err = ENOMEM;
4182   } else {
4183     memcpy(buf, path, path_len + 1);
4184     os::native_path(buf);
4185 
4186     wchar_t* prefix;
4187     int prefix_off = 0;
4188     bool is_abs = true;
4189     bool needs_fullpath = true;
4190 
4191     if (::isalpha(buf[0]) &amp;&amp; !::IsDBCSLeadByte(buf[0]) &amp;&amp; buf[1] == &#39;:&#39; &amp;&amp; buf[2] == &#39;\\&#39;) {
4192       prefix = L&quot;\\\\?\\&quot;;
4193     } else if (buf[0] == &#39;\\&#39; &amp;&amp; buf[1] == &#39;\\&#39;) {
4194       if (buf[2] == &#39;?&#39; &amp;&amp; buf[3] == &#39;\\&#39;) {
4195         prefix = L&quot;&quot;;
4196         needs_fullpath = false;
4197       } else {
4198         prefix = L&quot;\\\\?\\UNC&quot;;
4199         prefix_off = 1; // Overwrite the first char with the prefix, so \\share\path becomes \\?\UNC\share\path
4200       }
4201     } else {
4202       is_abs = false;
4203       prefix = L&quot;\\\\?\\&quot;;
4204     }
4205 
4206     size_t buf_len = strlen(buf);
4207     size_t prefix_len = wcslen(prefix);
4208     size_t full_path_size = is_abs ? 1 + buf_len : JVM_MAXPATHLEN;
4209     size_t result_size = prefix_len + full_path_size - prefix_off;
4210     result = (wchar_t*) os::malloc(sizeof(wchar_t) * (additional_space + result_size), mtInternal);
4211 
4212     if (result == NULL) {
4213       err = ENOMEM;
4214     } else {
4215       size_t converted_chars;
4216       wchar_t* path_start = result + prefix_len - prefix_off;
4217       err = ::mbstowcs_s(&amp;converted_chars, path_start, buf_len + 1, buf, buf_len);
4218 
4219       if ((err == ERROR_SUCCESS) &amp;&amp; needs_fullpath) {
4220         wchar_t* tmp = (wchar_t*) os::malloc(sizeof(wchar_t) * full_path_size, mtInternal);
4221 
4222         if (tmp == NULL) {
4223           err = ENOMEM;
4224         } else {
4225           if (!_wfullpath(tmp, path_start, full_path_size)) {
4226             err = ENOENT;
4227           } else {
4228             ::memcpy(path_start, tmp, (1 + wcslen(tmp)) * sizeof(wchar_t));
4229           }
4230 
4231           os::free(tmp);
4232         }
4233       }
4234 
4235       memcpy(result, prefix, sizeof(wchar_t) * prefix_len);
4236 
4237       // Remove trailing pathsep (not for \\?\&lt;DRIVE&gt;:\, since it would make it relative)
4238       size_t result_len = wcslen(result);
4239 
4240       if (result[result_len - 1] == L&#39;\\&#39;) {
4241         if (!(::iswalpha(result[4]) &amp;&amp; result[5] == L&#39;:&#39; &amp;&amp; result_len == 7)) {
4242           result[result_len - 1] = L&#39;\0&#39;;
4243         }
4244       }
4245     }
4246   }
4247 
4248   os::free(buf);
4249 
4250   if (err != ERROR_SUCCESS) {
4251     os::free(result);
4252     result = NULL;
4253   }
4254 
4255   return result;
4256 }
4257 
4258 int os::stat(const char *path, struct stat *sbuf) {
4259   errno_t err;
4260   wchar_t* wide_path = wide_abs_unc_path(path, err);
4261 
4262   if (wide_path == NULL) {
4263     errno = err;
4264     return -1;
4265   }
4266 
4267   WIN32_FILE_ATTRIBUTE_DATA file_data;;
4268   BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &amp;file_data);
4269   os::free(wide_path);
4270 
4271   if (!bret) {
4272     errno = ::GetLastError();
4273     return -1;
4274   }
4275 
4276   file_attribute_data_to_stat(sbuf, file_data);
4277   return 0;
4278 }
4279 
4280 static HANDLE create_read_only_file_handle(const char* file) {
4281   errno_t err;
4282   wchar_t* wide_path = wide_abs_unc_path(file, err);
4283 
4284   if (wide_path == NULL) {
4285     errno = err;
4286     return INVALID_HANDLE_VALUE;
4287   }
4288 
4289   HANDLE handle = ::CreateFileW(wide_path, 0, FILE_SHARE_READ,
4290                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
4291   os::free(wide_path);
4292 
4293   return handle;
4294 }
4295 
4296 bool os::same_files(const char* file1, const char* file2) {
4297 
4298   if (file1 == NULL &amp;&amp; file2 == NULL) {
4299     return true;
4300   }
4301 
4302   if (file1 == NULL || file2 == NULL) {
4303     return false;
4304   }
4305 
4306   if (strcmp(file1, file2) == 0) {
4307     return true;
4308   }
4309 
4310   HANDLE handle1 = create_read_only_file_handle(file1);
4311   HANDLE handle2 = create_read_only_file_handle(file2);
4312   bool result = false;
4313 
4314   // if we could open both paths...
4315   if (handle1 != INVALID_HANDLE_VALUE &amp;&amp; handle2 != INVALID_HANDLE_VALUE) {
4316     BY_HANDLE_FILE_INFORMATION fileInfo1;
4317     BY_HANDLE_FILE_INFORMATION fileInfo2;
4318     if (::GetFileInformationByHandle(handle1, &amp;fileInfo1) &amp;&amp;
4319       ::GetFileInformationByHandle(handle2, &amp;fileInfo2)) {
4320       // the paths are the same if they refer to the same file (fileindex) on the same volume (volume serial number)
4321       if (fileInfo1.dwVolumeSerialNumber == fileInfo2.dwVolumeSerialNumber &amp;&amp;
4322         fileInfo1.nFileIndexHigh == fileInfo2.nFileIndexHigh &amp;&amp;
4323         fileInfo1.nFileIndexLow == fileInfo2.nFileIndexLow) {
4324         result = true;
4325       }
4326     }
4327   }
4328 
4329   //free the handles
4330   if (handle1 != INVALID_HANDLE_VALUE) {
4331     ::CloseHandle(handle1);
4332   }
4333 
4334   if (handle2 != INVALID_HANDLE_VALUE) {
4335     ::CloseHandle(handle2);
4336   }
4337 
4338   return result;
4339 }
4340 
4341 #define FT2INT64(ft) \
4342   ((jlong)((jlong)(ft).dwHighDateTime &lt;&lt; 32 | (julong)(ft).dwLowDateTime))
4343 
4344 
4345 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
4346 // are used by JVM M&amp;M and JVMTI to get user+sys or user CPU time
4347 // of a thread.
4348 //
4349 // current_thread_cpu_time() and thread_cpu_time(Thread*) returns
4350 // the fast estimate available on the platform.
4351 
4352 // current_thread_cpu_time() is not optimized for Windows yet
4353 jlong os::current_thread_cpu_time() {
4354   // return user + sys since the cost is the same
4355   return os::thread_cpu_time(Thread::current(), true /* user+sys */);
4356 }
4357 
4358 jlong os::thread_cpu_time(Thread* thread) {
4359   // consistent with what current_thread_cpu_time() returns.
4360   return os::thread_cpu_time(thread, true /* user+sys */);
4361 }
4362 
4363 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
4364   return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
4365 }
4366 
4367 jlong os::thread_cpu_time(Thread* thread, bool user_sys_cpu_time) {
4368   // This code is copy from clasic VM -&gt; hpi::sysThreadCPUTime
4369   // If this function changes, os::is_thread_cpu_time_supported() should too
4370   FILETIME CreationTime;
4371   FILETIME ExitTime;
4372   FILETIME KernelTime;
4373   FILETIME UserTime;
4374 
4375   if (GetThreadTimes(thread-&gt;osthread()-&gt;thread_handle(), &amp;CreationTime,
4376                       &amp;ExitTime, &amp;KernelTime, &amp;UserTime) == 0) {
4377     return -1;
4378   } else if (user_sys_cpu_time) {
4379     return (FT2INT64(UserTime) + FT2INT64(KernelTime)) * 100;
4380   } else {
4381     return FT2INT64(UserTime) * 100;
4382   }
4383 }
4384 
4385 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4386   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4387   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4388   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4389   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4390 }
4391 
4392 void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4393   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4394   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4395   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4396   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4397 }
4398 
4399 bool os::is_thread_cpu_time_supported() {
4400   // see os::thread_cpu_time
4401   FILETIME CreationTime;
4402   FILETIME ExitTime;
4403   FILETIME KernelTime;
4404   FILETIME UserTime;
4405 
4406   if (GetThreadTimes(GetCurrentThread(), &amp;CreationTime, &amp;ExitTime,
4407                       &amp;KernelTime, &amp;UserTime) == 0) {
4408     return false;
4409   } else {
4410     return true;
4411   }
4412 }
4413 
4414 // Windows does&#39;t provide a loadavg primitive so this is stubbed out for now.
4415 // It does have primitives (PDH API) to get CPU usage and run queue length.
4416 // &quot;\\Processor(_Total)\\% Processor Time&quot;, &quot;\\System\\Processor Queue Length&quot;
4417 // If we wanted to implement loadavg on Windows, we have a few options:
4418 //
4419 // a) Query CPU usage and run queue length and &quot;fake&quot; an answer by
4420 //    returning the CPU usage if it&#39;s under 100%, and the run queue
4421 //    length otherwise.  It turns out that querying is pretty slow
4422 //    on Windows, on the order of 200 microseconds on a fast machine.
4423 //    Note that on the Windows the CPU usage value is the % usage
4424 //    since the last time the API was called (and the first call
4425 //    returns 100%), so we&#39;d have to deal with that as well.
4426 //
4427 // b) Sample the &quot;fake&quot; answer using a sampling thread and store
4428 //    the answer in a global variable.  The call to loadavg would
4429 //    just return the value of the global, avoiding the slow query.
4430 //
4431 // c) Sample a better answer using exponential decay to smooth the
4432 //    value.  This is basically the algorithm used by UNIX kernels.
4433 //
4434 // Note that sampling thread starvation could affect both (b) and (c).
4435 int os::loadavg(double loadavg[], int nelem) {
4436   return -1;
4437 }
4438 
4439 
4440 // DontYieldALot=false by default: dutifully perform all yields as requested by JVM_Yield()
4441 bool os::dont_yield() {
4442   return DontYieldALot;
4443 }
4444 
4445 int os::open(const char *path, int oflag, int mode) {
4446   errno_t err;
4447   wchar_t* wide_path = wide_abs_unc_path(path, err);
4448 
4449   if (wide_path == NULL) {
4450     errno = err;
4451     return -1;
4452   }
4453   int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);
4454   os::free(wide_path);
4455 
4456   if (fd == -1) {
4457     errno = ::GetLastError();
4458   }
4459 
4460   return fd;
4461 }
4462 
4463 FILE* os::open(int fd, const char* mode) {
4464   return ::_fdopen(fd, mode);
4465 }
4466 
4467 // Is a (classpath) directory empty?
4468 bool os::dir_is_empty(const char* path) {
4469   errno_t err;
4470   wchar_t* wide_path = wide_abs_unc_path(path, err, 2);
4471 
4472   if (wide_path == NULL) {
4473     errno = err;
4474     return false;
4475   }
4476 
4477   // Make sure we end with &quot;\\*&quot;
4478   if (wide_path[wcslen(wide_path) - 1] == L&#39;\\&#39;) {
4479     wcscat(wide_path, L&quot;*&quot;);
4480   } else {
4481     wcscat(wide_path, L&quot;\\*&quot;);
4482   }
4483 
4484   WIN32_FIND_DATAW fd;
4485   HANDLE f = ::FindFirstFileW(wide_path, &amp;fd);
4486   os::free(wide_path);
4487   bool is_empty = true;
4488 
4489   if (f != INVALID_HANDLE_VALUE) {
4490     while (is_empty &amp;&amp; ::FindNextFileW(f, &amp;fd)) {
4491       // An empty directory contains only the current directory file
4492       // and the previous directory file.
4493       if ((wcscmp(fd.cFileName, L&quot;.&quot;) != 0) &amp;&amp;
4494           (wcscmp(fd.cFileName, L&quot;..&quot;) != 0)) {
4495         is_empty = false;
4496       }
4497     }
4498     FindClose(f);
4499   } else {
4500     errno = ::GetLastError();
4501   }
4502 
4503   return is_empty;
4504 }
4505 
4506 // create binary file, rewriting existing file if required
4507 int os::create_binary_file(const char* path, bool rewrite_existing) {
4508   int oflags = _O_CREAT | _O_WRONLY | _O_BINARY;
4509   if (!rewrite_existing) {
4510     oflags |= _O_EXCL;
4511   }
4512   return ::open(path, oflags, _S_IREAD | _S_IWRITE);
4513 }
4514 
4515 // return current position of file pointer
4516 jlong os::current_file_offset(int fd) {
4517   return (jlong)::_lseeki64(fd, (__int64)0L, SEEK_CUR);
4518 }
4519 
4520 // move file pointer to the specified offset
4521 jlong os::seek_to_file_offset(int fd, jlong offset) {
4522   return (jlong)::_lseeki64(fd, (__int64)offset, SEEK_SET);
4523 }
4524 
4525 
4526 jlong os::lseek(int fd, jlong offset, int whence) {
4527   return (jlong) ::_lseeki64(fd, offset, whence);
4528 }
4529 
4530 ssize_t os::read_at(int fd, void *buf, unsigned int nBytes, jlong offset) {
4531   OVERLAPPED ov;
4532   DWORD nread;
4533   BOOL result;
4534 
4535   ZeroMemory(&amp;ov, sizeof(ov));
4536   ov.Offset = (DWORD)offset;
4537   ov.OffsetHigh = (DWORD)(offset &gt;&gt; 32);
4538 
4539   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4540 
4541   result = ReadFile(h, (LPVOID)buf, nBytes, &amp;nread, &amp;ov);
4542 
4543   return result ? nread : 0;
4544 }
4545 
4546 
4547 // This method is a slightly reworked copy of JDK&#39;s sysNativePath
4548 // from src/windows/hpi/src/path_md.c
4549 
4550 // Convert a pathname to native format.  On win32, this involves forcing all
4551 // separators to be &#39;\\&#39; rather than &#39;/&#39; (both are legal inputs, but Win95
4552 // sometimes rejects &#39;/&#39;) and removing redundant separators.  The input path is
4553 // assumed to have been converted into the character encoding used by the local
4554 // system.  Because this might be a double-byte encoding, care is taken to
4555 // treat double-byte lead characters correctly.
4556 //
4557 // This procedure modifies the given path in place, as the result is never
4558 // longer than the original.  There is no error return; this operation always
4559 // succeeds.
4560 char * os::native_path(char *path) {
4561   char *src = path, *dst = path, *end = path;
4562   char *colon = NULL;  // If a drive specifier is found, this will
4563                        // point to the colon following the drive letter
4564 
4565   // Assumption: &#39;/&#39;, &#39;\\&#39;, &#39;:&#39;, and drive letters are never lead bytes
4566   assert(((!::IsDBCSLeadByte(&#39;/&#39;)) &amp;&amp; (!::IsDBCSLeadByte(&#39;\\&#39;))
4567           &amp;&amp; (!::IsDBCSLeadByte(&#39;:&#39;))), &quot;Illegal lead byte&quot;);
4568 
4569   // Check for leading separators
4570 #define isfilesep(c) ((c) == &#39;/&#39; || (c) == &#39;\\&#39;)
4571   while (isfilesep(*src)) {
4572     src++;
4573   }
4574 
4575   if (::isalpha(*src) &amp;&amp; !::IsDBCSLeadByte(*src) &amp;&amp; src[1] == &#39;:&#39;) {
4576     // Remove leading separators if followed by drive specifier.  This
4577     // hack is necessary to support file URLs containing drive
4578     // specifiers (e.g., &quot;file://c:/path&quot;).  As a side effect,
4579     // &quot;/c:/path&quot; can be used as an alternative to &quot;c:/path&quot;.
4580     *dst++ = *src++;
4581     colon = dst;
4582     *dst++ = &#39;:&#39;;
4583     src++;
4584   } else {
4585     src = path;
4586     if (isfilesep(src[0]) &amp;&amp; isfilesep(src[1])) {
4587       // UNC pathname: Retain first separator; leave src pointed at
4588       // second separator so that further separators will be collapsed
4589       // into the second separator.  The result will be a pathname
4590       // beginning with &quot;\\\\&quot; followed (most likely) by a host name.
4591       src = dst = path + 1;
4592       path[0] = &#39;\\&#39;;     // Force first separator to &#39;\\&#39;
4593     }
4594   }
4595 
4596   end = dst;
4597 
4598   // Remove redundant separators from remainder of path, forcing all
4599   // separators to be &#39;\\&#39; rather than &#39;/&#39;. Also, single byte space
4600   // characters are removed from the end of the path because those
4601   // are not legal ending characters on this operating system.
4602   //
4603   while (*src != &#39;\0&#39;) {
4604     if (isfilesep(*src)) {
4605       *dst++ = &#39;\\&#39;; src++;
4606       while (isfilesep(*src)) src++;
4607       if (*src == &#39;\0&#39;) {
4608         // Check for trailing separator
4609         end = dst;
4610         if (colon == dst - 2) break;  // &quot;z:\\&quot;
4611         if (dst == path + 1) break;   // &quot;\\&quot;
4612         if (dst == path + 2 &amp;&amp; isfilesep(path[0])) {
4613           // &quot;\\\\&quot; is not collapsed to &quot;\\&quot; because &quot;\\\\&quot; marks the
4614           // beginning of a UNC pathname.  Even though it is not, by
4615           // itself, a valid UNC pathname, we leave it as is in order
4616           // to be consistent with the path canonicalizer as well
4617           // as the win32 APIs, which treat this case as an invalid
4618           // UNC pathname rather than as an alias for the root
4619           // directory of the current drive.
4620           break;
4621         }
4622         end = --dst;  // Path does not denote a root directory, so
4623                       // remove trailing separator
4624         break;
4625       }
4626       end = dst;
4627     } else {
4628       if (::IsDBCSLeadByte(*src)) {  // Copy a double-byte character
4629         *dst++ = *src++;
4630         if (*src) *dst++ = *src++;
4631         end = dst;
4632       } else {  // Copy a single-byte character
4633         char c = *src++;
4634         *dst++ = c;
4635         // Space is not a legal ending character
4636         if (c != &#39; &#39;) end = dst;
4637       }
4638     }
4639   }
4640 
4641   *end = &#39;\0&#39;;
4642 
4643   // For &quot;z:&quot;, add &quot;.&quot; to work around a bug in the C runtime library
4644   if (colon == dst - 1) {
4645     path[2] = &#39;.&#39;;
4646     path[3] = &#39;\0&#39;;
4647   }
4648 
4649   return path;
4650 }
4651 
4652 // This code is a copy of JDK&#39;s sysSetLength
4653 // from src/windows/hpi/src/sys_api_md.c
4654 
4655 int os::ftruncate(int fd, jlong length) {
4656   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4657   long high = (long)(length &gt;&gt; 32);
4658   DWORD ret;
4659 
4660   if (h == (HANDLE)(-1)) {
4661     return -1;
4662   }
4663 
4664   ret = ::SetFilePointer(h, (long)(length), &amp;high, FILE_BEGIN);
4665   if ((ret == 0xFFFFFFFF) &amp;&amp; (::GetLastError() != NO_ERROR)) {
4666     return -1;
4667   }
4668 
4669   if (::SetEndOfFile(h) == FALSE) {
4670     return -1;
4671   }
4672 
4673   return 0;
4674 }
4675 
4676 int os::get_fileno(FILE* fp) {
4677   return _fileno(fp);
4678 }
4679 
4680 // This code is a copy of JDK&#39;s sysSync
4681 // from src/windows/hpi/src/sys_api_md.c
4682 // except for the legacy workaround for a bug in Win 98
4683 
4684 int os::fsync(int fd) {
4685   HANDLE handle = (HANDLE)::_get_osfhandle(fd);
4686 
4687   if ((!::FlushFileBuffers(handle)) &amp;&amp;
4688       (GetLastError() != ERROR_ACCESS_DENIED)) {
4689     // from winerror.h
4690     return -1;
4691   }
4692   return 0;
4693 }
4694 
4695 static int nonSeekAvailable(int, long *);
4696 static int stdinAvailable(int, long *);
4697 
4698 // This code is a copy of JDK&#39;s sysAvailable
4699 // from src/windows/hpi/src/sys_api_md.c
4700 
4701 int os::available(int fd, jlong *bytes) {
4702   jlong cur, end;
4703   struct _stati64 stbuf64;
4704 
4705   if (::_fstati64(fd, &amp;stbuf64) &gt;= 0) {
4706     int mode = stbuf64.st_mode;
4707     if (S_ISCHR(mode) || S_ISFIFO(mode)) {
4708       int ret;
4709       long lpbytes;
4710       if (fd == 0) {
4711         ret = stdinAvailable(fd, &amp;lpbytes);
4712       } else {
4713         ret = nonSeekAvailable(fd, &amp;lpbytes);
4714       }
4715       (*bytes) = (jlong)(lpbytes);
4716       return ret;
4717     }
4718     if ((cur = ::_lseeki64(fd, 0L, SEEK_CUR)) == -1) {
4719       return FALSE;
4720     } else if ((end = ::_lseeki64(fd, 0L, SEEK_END)) == -1) {
4721       return FALSE;
4722     } else if (::_lseeki64(fd, cur, SEEK_SET) == -1) {
4723       return FALSE;
4724     }
4725     *bytes = end - cur;
4726     return TRUE;
4727   } else {
4728     return FALSE;
4729   }
4730 }
4731 
4732 void os::flockfile(FILE* fp) {
4733   _lock_file(fp);
4734 }
4735 
4736 void os::funlockfile(FILE* fp) {
4737   _unlock_file(fp);
4738 }
4739 
4740 // This code is a copy of JDK&#39;s nonSeekAvailable
4741 // from src/windows/hpi/src/sys_api_md.c
4742 
4743 static int nonSeekAvailable(int fd, long *pbytes) {
4744   // This is used for available on non-seekable devices
4745   // (like both named and anonymous pipes, such as pipes
4746   //  connected to an exec&#39;d process).
4747   // Standard Input is a special case.
4748   HANDLE han;
4749 
4750   if ((han = (HANDLE) ::_get_osfhandle(fd)) == (HANDLE)(-1)) {
4751     return FALSE;
4752   }
4753 
4754   if (! ::PeekNamedPipe(han, NULL, 0, NULL, (LPDWORD)pbytes, NULL)) {
4755     // PeekNamedPipe fails when at EOF.  In that case we
4756     // simply make *pbytes = 0 which is consistent with the
4757     // behavior we get on Solaris when an fd is at EOF.
4758     // The only alternative is to raise an Exception,
4759     // which isn&#39;t really warranted.
4760     //
4761     if (::GetLastError() != ERROR_BROKEN_PIPE) {
4762       return FALSE;
4763     }
4764     *pbytes = 0;
4765   }
4766   return TRUE;
4767 }
4768 
4769 #define MAX_INPUT_EVENTS 2000
4770 
4771 // This code is a copy of JDK&#39;s stdinAvailable
4772 // from src/windows/hpi/src/sys_api_md.c
4773 
4774 static int stdinAvailable(int fd, long *pbytes) {
4775   HANDLE han;
4776   DWORD numEventsRead = 0;  // Number of events read from buffer
4777   DWORD numEvents = 0;      // Number of events in buffer
4778   DWORD i = 0;              // Loop index
4779   DWORD curLength = 0;      // Position marker
4780   DWORD actualLength = 0;   // Number of bytes readable
4781   BOOL error = FALSE;       // Error holder
4782   INPUT_RECORD *lpBuffer;   // Pointer to records of input events
4783 
4784   if ((han = ::GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
4785     return FALSE;
4786   }
4787 
4788   // Construct an array of input records in the console buffer
4789   error = ::GetNumberOfConsoleInputEvents(han, &amp;numEvents);
4790   if (error == 0) {
4791     return nonSeekAvailable(fd, pbytes);
4792   }
4793 
4794   // lpBuffer must fit into 64K or else PeekConsoleInput fails
4795   if (numEvents &gt; MAX_INPUT_EVENTS) {
4796     numEvents = MAX_INPUT_EVENTS;
4797   }
4798 
4799   lpBuffer = (INPUT_RECORD *)os::malloc(numEvents * sizeof(INPUT_RECORD), mtInternal);
4800   if (lpBuffer == NULL) {
4801     return FALSE;
4802   }
4803 
4804   error = ::PeekConsoleInput(han, lpBuffer, numEvents, &amp;numEventsRead);
4805   if (error == 0) {
4806     os::free(lpBuffer);
4807     return FALSE;
4808   }
4809 
4810   // Examine input records for the number of bytes available
4811   for (i=0; i&lt;numEvents; i++) {
4812     if (lpBuffer[i].EventType == KEY_EVENT) {
4813 
4814       KEY_EVENT_RECORD *keyRecord = (KEY_EVENT_RECORD *)
4815                                       &amp;(lpBuffer[i].Event);
4816       if (keyRecord-&gt;bKeyDown == TRUE) {
4817         CHAR *keyPressed = (CHAR *) &amp;(keyRecord-&gt;uChar);
4818         curLength++;
4819         if (*keyPressed == &#39;\r&#39;) {
4820           actualLength = curLength;
4821         }
4822       }
4823     }
4824   }
4825 
4826   if (lpBuffer != NULL) {
4827     os::free(lpBuffer);
4828   }
4829 
4830   *pbytes = (long) actualLength;
4831   return TRUE;
4832 }
4833 
4834 // Map a block of memory.
4835 char* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,
4836                         char *addr, size_t bytes, bool read_only,
4837                         bool allow_exec) {
4838   HANDLE hFile;
4839   char* base;
4840 
4841   hFile = CreateFile(file_name, GENERIC_READ, FILE_SHARE_READ, NULL,
4842                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
4843   if (hFile == NULL) {
4844     log_info(os)(&quot;CreateFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4845     return NULL;
4846   }
4847 
4848   if (allow_exec) {
4849     // CreateFileMapping/MapViewOfFileEx can&#39;t map executable memory
4850     // unless it comes from a PE image (which the shared archive is not.)
4851     // Even VirtualProtect refuses to give execute access to mapped memory
4852     // that was not previously executable.
4853     //
4854     // Instead, stick the executable region in anonymous memory.  Yuck.
4855     // Penalty is that ~4 pages will not be shareable - in the future
4856     // we might consider DLLizing the shared archive with a proper PE
4857     // header so that mapping executable + sharing is possible.
4858 
4859     base = (char*) VirtualAlloc(addr, bytes, MEM_COMMIT | MEM_RESERVE,
4860                                 PAGE_READWRITE);
4861     if (base == NULL) {
4862       log_info(os)(&quot;VirtualAlloc() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4863       CloseHandle(hFile);
4864       return NULL;
4865     }
4866 
4867     // Record virtual memory allocation
4868     MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);
4869 
4870     DWORD bytes_read;
4871     OVERLAPPED overlapped;
4872     overlapped.Offset = (DWORD)file_offset;
4873     overlapped.OffsetHigh = 0;
4874     overlapped.hEvent = NULL;
4875     // ReadFile guarantees that if the return value is true, the requested
4876     // number of bytes were read before returning.
4877     bool res = ReadFile(hFile, base, (DWORD)bytes, &amp;bytes_read, &amp;overlapped) != 0;
4878     if (!res) {
4879       log_info(os)(&quot;ReadFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4880       release_memory(base, bytes);
4881       CloseHandle(hFile);
4882       return NULL;
4883     }
4884   } else {
4885     HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,
4886                                     NULL /* file_name */);
4887     if (hMap == NULL) {
4888       log_info(os)(&quot;CreateFileMapping() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4889       CloseHandle(hFile);
4890       return NULL;
4891     }
4892 
4893     DWORD access = read_only ? FILE_MAP_READ : FILE_MAP_COPY;
4894     base = (char*)MapViewOfFileEx(hMap, access, 0, (DWORD)file_offset,
4895                                   (DWORD)bytes, addr);
4896     if (base == NULL) {
4897       log_info(os)(&quot;MapViewOfFileEx() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4898       CloseHandle(hMap);
4899       CloseHandle(hFile);
4900       return NULL;
4901     }
4902 
4903     if (CloseHandle(hMap) == 0) {
4904       log_info(os)(&quot;CloseHandle(hMap) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4905       CloseHandle(hFile);
4906       return base;
4907     }
4908   }
4909 
4910   if (allow_exec) {
4911     DWORD old_protect;
4912     DWORD exec_access = read_only ? PAGE_EXECUTE_READ : PAGE_EXECUTE_READWRITE;
4913     bool res = VirtualProtect(base, bytes, exec_access, &amp;old_protect) != 0;
4914 
4915     if (!res) {
4916       log_info(os)(&quot;VirtualProtect() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4917       // Don&#39;t consider this a hard error, on IA32 even if the
4918       // VirtualProtect fails, we should still be able to execute
4919       CloseHandle(hFile);
4920       return base;
4921     }
4922   }
4923 
4924   if (CloseHandle(hFile) == 0) {
4925     log_info(os)(&quot;CloseHandle(hFile) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4926     return base;
4927   }
4928 
4929   return base;
4930 }
4931 
4932 
4933 // Remap a block of memory.
4934 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
4935                           char *addr, size_t bytes, bool read_only,
4936                           bool allow_exec) {
4937   // This OS does not allow existing memory maps to be remapped so we
4938   // would have to unmap the memory before we remap it.
4939 
4940   // Because there is a small window between unmapping memory and mapping
4941   // it in again with different protections, CDS archives are mapped RW
4942   // on windows, so this function isn&#39;t called.
4943   ShouldNotReachHere();
4944   return NULL;
4945 }
4946 
4947 
4948 // Unmap a block of memory.
4949 // Returns true=success, otherwise false.
4950 
4951 bool os::pd_unmap_memory(char* addr, size_t bytes) {
4952   MEMORY_BASIC_INFORMATION mem_info;
4953   if (VirtualQuery(addr, &amp;mem_info, sizeof(mem_info)) == 0) {
4954     log_info(os)(&quot;VirtualQuery() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4955     return false;
4956   }
4957 
4958   // Executable memory was not mapped using CreateFileMapping/MapViewOfFileEx.
4959   // Instead, executable region was allocated using VirtualAlloc(). See
4960   // pd_map_memory() above.
4961   //
4962   // The following flags should match the &#39;exec_access&#39; flages used for
4963   // VirtualProtect() in pd_map_memory().
4964   if (mem_info.Protect == PAGE_EXECUTE_READ ||
4965       mem_info.Protect == PAGE_EXECUTE_READWRITE) {
4966     return pd_release_memory(addr, bytes);
4967   }
4968 
4969   BOOL result = UnmapViewOfFile(addr);
4970   if (result == 0) {
4971     log_info(os)(&quot;UnmapViewOfFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4972     return false;
4973   }
4974   return true;
4975 }
4976 
4977 void os::pause() {
4978   char filename[MAX_PATH];
4979   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
4980     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);
4981   } else {
4982     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
4983   }
4984 
4985   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4986   if (fd != -1) {
4987     struct stat buf;
4988     ::close(fd);
4989     while (::stat(filename, &amp;buf) == 0) {
4990       Sleep(100);
4991     }
4992   } else {
4993     jio_fprintf(stderr,
4994                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
4995   }
4996 }
4997 
4998 Thread* os::ThreadCrashProtection::_protected_thread = NULL;
4999 os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;
5000 volatile intptr_t os::ThreadCrashProtection::_crash_mux = 0;
5001 
5002 os::ThreadCrashProtection::ThreadCrashProtection() {
5003 }
5004 
5005 // See the caveats for this class in os_windows.hpp
5006 // Protects the callback call so that raised OS EXCEPTIONS causes a jump back
5007 // into this method and returns false. If no OS EXCEPTION was raised, returns
5008 // true.
5009 // The callback is supposed to provide the method that should be protected.
5010 //
5011 bool os::ThreadCrashProtection::call(os::CrashProtectionCallback&amp; cb) {
5012 
5013   Thread::muxAcquire(&amp;_crash_mux, &quot;CrashProtection&quot;);
5014 
5015   _protected_thread = Thread::current_or_null();
5016   assert(_protected_thread != NULL, &quot;Cannot crash protect a NULL thread&quot;);
5017 
5018   bool success = true;
5019   __try {
5020     _crash_protection = this;
5021     cb.call();
5022   } __except(EXCEPTION_EXECUTE_HANDLER) {
5023     // only for protection, nothing to do
5024     success = false;
5025   }
5026   _crash_protection = NULL;
5027   _protected_thread = NULL;
5028   Thread::muxRelease(&amp;_crash_mux);
5029   return success;
5030 }
5031 
5032 
5033 class HighResolutionInterval : public CHeapObj&lt;mtThread&gt; {
5034   // The default timer resolution seems to be 10 milliseconds.
5035   // (Where is this written down?)
5036   // If someone wants to sleep for only a fraction of the default,
5037   // then we set the timer resolution down to 1 millisecond for
5038   // the duration of their interval.
5039   // We carefully set the resolution back, since otherwise we
5040   // seem to incur an overhead (3%?) that we don&#39;t need.
5041   // CONSIDER: if ms is small, say 3, then we should run with a high resolution time.
5042   // Buf if ms is large, say 500, or 503, we should avoid the call to timeBeginPeriod().
5043   // Alternatively, we could compute the relative error (503/500 = .6%) and only use
5044   // timeBeginPeriod() if the relative error exceeded some threshold.
5045   // timeBeginPeriod() has been linked to problems with clock drift on win32 systems and
5046   // to decreased efficiency related to increased timer &quot;tick&quot; rates.  We want to minimize
5047   // (a) calls to timeBeginPeriod() and timeEndPeriod() and (b) time spent with high
5048   // resolution timers running.
5049  private:
5050   jlong resolution;
5051  public:
5052   HighResolutionInterval(jlong ms) {
5053     resolution = ms % 10L;
5054     if (resolution != 0) {
5055       MMRESULT result = timeBeginPeriod(1L);
5056     }
5057   }
5058   ~HighResolutionInterval() {
5059     if (resolution != 0) {
5060       MMRESULT result = timeEndPeriod(1L);
5061     }
5062     resolution = 0L;
5063   }
5064 };
5065 
5066 // An Event wraps a win32 &quot;CreateEvent&quot; kernel handle.
5067 //
5068 // We have a number of choices regarding &quot;CreateEvent&quot; win32 handle leakage:
5069 //
5070 // 1:  When a thread dies return the Event to the EventFreeList, clear the ParkHandle
5071 //     field, and call CloseHandle() on the win32 event handle.  Unpark() would
5072 //     need to be modified to tolerate finding a NULL (invalid) win32 event handle.
5073 //     In addition, an unpark() operation might fetch the handle field, but the
5074 //     event could recycle between the fetch and the SetEvent() operation.
5075 //     SetEvent() would either fail because the handle was invalid, or inadvertently work,
5076 //     as the win32 handle value had been recycled.  In an ideal world calling SetEvent()
5077 //     on an stale but recycled handle would be harmless, but in practice this might
5078 //     confuse other non-Sun code, so it&#39;s not a viable approach.
5079 //
5080 // 2:  Once a win32 event handle is associated with an Event, it remains associated
5081 //     with the Event.  The event handle is never closed.  This could be construed
5082 //     as handle leakage, but only up to the maximum # of threads that have been extant
5083 //     at any one time.  This shouldn&#39;t be an issue, as windows platforms typically
5084 //     permit a process to have hundreds of thousands of open handles.
5085 //
5086 // 3:  Same as (1), but periodically, at stop-the-world time, rundown the EventFreeList
5087 //     and release unused handles.
5088 //
5089 // 4:  Add a CRITICAL_SECTION to the Event to protect LD+SetEvent from LD;ST(null);CloseHandle.
5090 //     It&#39;s not clear, however, that we wouldn&#39;t be trading one type of leak for another.
5091 //
5092 // 5.  Use an RCU-like mechanism (Read-Copy Update).
5093 //     Or perhaps something similar to Maged Michael&#39;s &quot;Hazard pointers&quot;.
5094 //
5095 // We use (2).
5096 //
5097 // TODO-FIXME:
5098 // 1.  Reconcile Doug&#39;s JSR166 j.u.c park-unpark with the objectmonitor implementation.
5099 // 2.  Consider wrapping the WaitForSingleObject(Ex) calls in SEH try/finally blocks
5100 //     to recover from (or at least detect) the dreaded Windows 841176 bug.
5101 // 3.  Collapse the JSR166 parker event, and the objectmonitor ParkEvent
5102 //     into a single win32 CreateEvent() handle.
5103 //
5104 // Assumption:
5105 //    Only one parker can exist on an event, which is why we allocate
5106 //    them per-thread. Multiple unparkers can coexist.
5107 //
5108 // _Event transitions in park()
5109 //   -1 =&gt; -1 : illegal
5110 //    1 =&gt;  0 : pass - return immediately
5111 //    0 =&gt; -1 : block; then set _Event to 0 before returning
5112 //
5113 // _Event transitions in unpark()
5114 //    0 =&gt; 1 : just return
5115 //    1 =&gt; 1 : just return
5116 //   -1 =&gt; either 0 or 1; must signal target thread
5117 //         That is, we can safely transition _Event from -1 to either
5118 //         0 or 1.
5119 //
5120 // _Event serves as a restricted-range semaphore.
5121 //   -1 : thread is blocked, i.e. there is a waiter
5122 //    0 : neutral: thread is running or ready,
5123 //        could have been signaled after a wait started
5124 //    1 : signaled - thread is running or ready
5125 //
5126 // Another possible encoding of _Event would be with
5127 // explicit &quot;PARKED&quot; == 01b and &quot;SIGNALED&quot; == 10b bits.
5128 //
5129 
5130 int os::PlatformEvent::park(jlong Millis) {
5131   // Transitions for _Event:
5132   //   -1 =&gt; -1 : illegal
5133   //    1 =&gt;  0 : pass - return immediately
5134   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5135 
5136   guarantee(_ParkHandle != NULL , &quot;Invariant&quot;);
5137   guarantee(Millis &gt; 0          , &quot;Invariant&quot;);
5138 
5139   // CONSIDER: defer assigning a CreateEvent() handle to the Event until
5140   // the initial park() operation.
5141   // Consider: use atomic decrement instead of CAS-loop
5142 
5143   int v;
5144   for (;;) {
5145     v = _Event;
5146     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;
5147   }
5148   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5149   if (v != 0) return OS_OK;
5150 
5151   // Do this the hard way by blocking ...
5152   // TODO: consider a brief spin here, gated on the success of recent
5153   // spin attempts by this thread.
5154   //
5155   // We decompose long timeouts into series of shorter timed waits.
5156   // Evidently large timo values passed in WaitForSingleObject() are problematic on some
5157   // versions of Windows.  See EventWait() for details.  This may be superstition.  Or not.
5158   // We trust the WAIT_TIMEOUT indication and don&#39;t track the elapsed wait time
5159   // with os::javaTimeNanos().  Furthermore, we assume that spurious returns from
5160   // ::WaitForSingleObject() caused by latent ::setEvent() operations will tend
5161   // to happen early in the wait interval.  Specifically, after a spurious wakeup (rv ==
5162   // WAIT_OBJECT_0 but _Event is still &lt; 0) we don&#39;t bother to recompute Millis to compensate
5163   // for the already waited time.  This policy does not admit any new outcomes.
5164   // In the future, however, we might want to track the accumulated wait time and
5165   // adjust Millis accordingly if we encounter a spurious wakeup.
5166 
5167   const int MAXTIMEOUT = 0x10000000;
5168   DWORD rv = WAIT_TIMEOUT;
5169   while (_Event &lt; 0 &amp;&amp; Millis &gt; 0) {
5170     DWORD prd = Millis;     // set prd = MAX (Millis, MAXTIMEOUT)
5171     if (Millis &gt; MAXTIMEOUT) {
5172       prd = MAXTIMEOUT;
5173     }
5174     HighResolutionInterval *phri = NULL;
5175     if (!ForceTimeHighResolution) {
5176       phri = new HighResolutionInterval(prd);
5177     }
5178     rv = ::WaitForSingleObject(_ParkHandle, prd);
5179     assert(rv == WAIT_OBJECT_0 || rv == WAIT_TIMEOUT, &quot;WaitForSingleObject failed&quot;);
5180     if (rv == WAIT_TIMEOUT) {
5181       Millis -= prd;
5182     }
5183     delete phri; // if it is NULL, harmless
5184   }
5185   v = _Event;
5186   _Event = 0;
5187   // see comment at end of os::PlatformEvent::park() below:
5188   OrderAccess::fence();
5189   // If we encounter a nearly simultanous timeout expiry and unpark()
5190   // we return OS_OK indicating we awoke via unpark().
5191   // Implementor&#39;s license -- returning OS_TIMEOUT would be equally valid, however.
5192   return (v &gt;= 0) ? OS_OK : OS_TIMEOUT;
5193 }
5194 
5195 void os::PlatformEvent::park() {
5196   // Transitions for _Event:
5197   //   -1 =&gt; -1 : illegal
5198   //    1 =&gt;  0 : pass - return immediately
5199   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5200 
5201   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5202   // Invariant: Only the thread associated with the Event/PlatformEvent
5203   // may call park().
5204   // Consider: use atomic decrement instead of CAS-loop
5205   int v;
5206   for (;;) {
5207     v = _Event;
5208     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;
5209   }
5210   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5211   if (v != 0) return;
5212 
5213   // Do this the hard way by blocking ...
5214   // TODO: consider a brief spin here, gated on the success of recent
5215   // spin attempts by this thread.
5216   while (_Event &lt; 0) {
5217     DWORD rv = ::WaitForSingleObject(_ParkHandle, INFINITE);
5218     assert(rv == WAIT_OBJECT_0, &quot;WaitForSingleObject failed&quot;);
5219   }
5220 
5221   // Usually we&#39;ll find _Event == 0 at this point, but as
5222   // an optional optimization we clear it, just in case can
5223   // multiple unpark() operations drove _Event up to 1.
5224   _Event = 0;
5225   OrderAccess::fence();
5226   guarantee(_Event &gt;= 0, &quot;invariant&quot;);
5227 }
5228 
5229 void os::PlatformEvent::unpark() {
5230   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5231 
5232   // Transitions for _Event:
5233   //    0 =&gt; 1 : just return
5234   //    1 =&gt; 1 : just return
5235   //   -1 =&gt; either 0 or 1; must signal target thread
5236   //         That is, we can safely transition _Event from -1 to either
5237   //         0 or 1.
5238   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
5239   //
5240   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
5241   // that it will take two back-to-back park() calls for the owning
5242   // thread to block. This has the benefit of forcing a spurious return
5243   // from the first park() call after an unpark() call which will help
5244   // shake out uses of park() and unpark() without condition variables.
5245 
5246   if (Atomic::xchg(&amp;_Event, 1) &gt;= 0) return;
5247 
5248   ::SetEvent(_ParkHandle);
5249 }
5250 
5251 
5252 // JSR166
5253 // -------------------------------------------------------
5254 
5255 // The Windows implementation of Park is very straightforward: Basic
5256 // operations on Win32 Events turn out to have the right semantics to
5257 // use them directly. We opportunistically resuse the event inherited
5258 // from Monitor.
5259 
5260 void Parker::park(bool isAbsolute, jlong time) {
5261   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5262   // First, demultiplex/decode time arguments
5263   if (time &lt; 0) { // don&#39;t wait
5264     return;
5265   } else if (time == 0 &amp;&amp; !isAbsolute) {
5266     time = INFINITE;
5267   } else if (isAbsolute) {
5268     time -= os::javaTimeMillis(); // convert to relative time
5269     if (time &lt;= 0) {  // already elapsed
5270       return;
5271     }
5272   } else { // relative
5273     time /= 1000000;  // Must coarsen from nanos to millis
5274     if (time == 0) {  // Wait for the minimal time unit if zero
5275       time = 1;
5276     }
5277   }
5278 
5279   JavaThread* thread = JavaThread::current();
5280 
5281   // Don&#39;t wait if interrupted or already triggered
5282   if (thread-&gt;is_interrupted(false) ||
5283       WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {
5284     ResetEvent(_ParkEvent);
5285     return;
5286   } else {
5287     ThreadBlockInVM tbivm(thread);
5288     OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
5289     thread-&gt;set_suspend_equivalent();
5290 
5291     WaitForSingleObject(_ParkEvent, time);
5292     ResetEvent(_ParkEvent);
5293 
5294     // If externally suspended while waiting, re-suspend
5295     if (thread-&gt;handle_special_suspend_equivalent_condition()) {
5296       thread-&gt;java_suspend_self();
5297     }
5298   }
5299 }
5300 
5301 void Parker::unpark() {
5302   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5303   SetEvent(_ParkEvent);
5304 }
5305 
5306 // Platform Monitor implementation
5307 
5308 // Must already be locked
5309 int os::PlatformMonitor::wait(jlong millis) {
5310   assert(millis &gt;= 0, &quot;negative timeout&quot;);
5311   int ret = OS_TIMEOUT;
5312   int status = SleepConditionVariableCS(&amp;_cond, &amp;_mutex,
5313                                         millis == 0 ? INFINITE : millis);
5314   if (status != 0) {
5315     ret = OS_OK;
5316   }
5317   #ifndef PRODUCT
5318   else {
5319     DWORD err = GetLastError();
5320     assert(err == ERROR_TIMEOUT, &quot;SleepConditionVariableCS: %ld:&quot;, err);
5321   }
5322   #endif
5323   return ret;
5324 }
5325 
5326 // Run the specified command in a separate process. Return its exit value,
5327 // or -1 on failure (e.g. can&#39;t create a new process).
5328 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
5329   STARTUPINFO si;
5330   PROCESS_INFORMATION pi;
5331   DWORD exit_code;
5332 
5333   char * cmd_string;
5334   const char * cmd_prefix = &quot;cmd /C &quot;;
5335   size_t len = strlen(cmd) + strlen(cmd_prefix) + 1;
5336   cmd_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtInternal);
5337   if (cmd_string == NULL) {
5338     return -1;
5339   }
5340   cmd_string[0] = &#39;\0&#39;;
5341   strcat(cmd_string, cmd_prefix);
5342   strcat(cmd_string, cmd);
5343 
5344   // now replace all &#39;\n&#39; with &#39;&amp;&#39;
5345   char * substring = cmd_string;
5346   while ((substring = strchr(substring, &#39;\n&#39;)) != NULL) {
5347     substring[0] = &#39;&amp;&#39;;
5348     substring++;
5349   }
5350   memset(&amp;si, 0, sizeof(si));
5351   si.cb = sizeof(si);
5352   memset(&amp;pi, 0, sizeof(pi));
5353   BOOL rslt = CreateProcess(NULL,   // executable name - use command line
5354                             cmd_string,    // command line
5355                             NULL,   // process security attribute
5356                             NULL,   // thread security attribute
5357                             TRUE,   // inherits system handles
5358                             0,      // no creation flags
5359                             NULL,   // use parent&#39;s environment block
5360                             NULL,   // use parent&#39;s starting directory
5361                             &amp;si,    // (in) startup information
5362                             &amp;pi);   // (out) process information
5363 
5364   if (rslt) {
5365     // Wait until child process exits.
5366     WaitForSingleObject(pi.hProcess, INFINITE);
5367 
5368     GetExitCodeProcess(pi.hProcess, &amp;exit_code);
5369 
5370     // Close process and thread handles.
5371     CloseHandle(pi.hProcess);
5372     CloseHandle(pi.hThread);
5373   } else {
5374     exit_code = -1;
5375   }
5376 
5377   FREE_C_HEAP_ARRAY(char, cmd_string);
5378   return (int)exit_code;
5379 }
5380 
5381 bool os::find(address addr, outputStream* st) {
5382   int offset = -1;
5383   bool result = false;
5384   char buf[256];
5385   if (os::dll_address_to_library_name(addr, buf, sizeof(buf), &amp;offset)) {
5386     st-&gt;print(PTR_FORMAT &quot; &quot;, addr);
5387     if (strlen(buf) &lt; sizeof(buf) - 1) {
5388       char* p = strrchr(buf, &#39;\\&#39;);
5389       if (p) {
5390         st-&gt;print(&quot;%s&quot;, p + 1);
5391       } else {
5392         st-&gt;print(&quot;%s&quot;, buf);
5393       }
5394     } else {
5395         // The library name is probably truncated. Let&#39;s omit the library name.
5396         // See also JDK-8147512.
5397     }
5398     if (os::dll_address_to_function_name(addr, buf, sizeof(buf), &amp;offset)) {
5399       st-&gt;print(&quot;::%s + 0x%x&quot;, buf, offset);
5400     }
5401     st-&gt;cr();
5402     result = true;
5403   }
5404   return result;
5405 }
5406 
5407 static jint initSock() {
5408   WSADATA wsadata;
5409 
5410   if (WSAStartup(MAKEWORD(2,2), &amp;wsadata) != 0) {
5411     jio_fprintf(stderr, &quot;Could not initialize Winsock (error: %d)\n&quot;,
5412                 ::GetLastError());
5413     return JNI_ERR;
5414   }
5415   return JNI_OK;
5416 }
5417 
5418 struct hostent* os::get_host_by_name(char* name) {
5419   return (struct hostent*)gethostbyname(name);
5420 }
5421 
5422 int os::socket_close(int fd) {
5423   return ::closesocket(fd);
5424 }
5425 
5426 int os::socket(int domain, int type, int protocol) {
5427   return ::socket(domain, type, protocol);
5428 }
5429 
5430 int os::connect(int fd, struct sockaddr* him, socklen_t len) {
5431   return ::connect(fd, him, len);
5432 }
5433 
5434 int os::recv(int fd, char* buf, size_t nBytes, uint flags) {
5435   return ::recv(fd, buf, (int)nBytes, flags);
5436 }
5437 
5438 int os::send(int fd, char* buf, size_t nBytes, uint flags) {
5439   return ::send(fd, buf, (int)nBytes, flags);
5440 }
5441 
5442 int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {
5443   return ::send(fd, buf, (int)nBytes, flags);
5444 }
5445 
5446 // WINDOWS CONTEXT Flags for THREAD_SAMPLING
5447 #if defined(IA32)
5448   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS)
<a name="43" id="anc43"></a><span class="line-modified">5449 #elif defined (AMD64)</span>
5450   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
5451 #endif
5452 
5453 // returns true if thread could be suspended,
5454 // false otherwise
5455 static bool do_suspend(HANDLE* h) {
5456   if (h != NULL) {
5457     if (SuspendThread(*h) != ~0) {
5458       return true;
5459     }
5460   }
5461   return false;
5462 }
5463 
5464 // resume the thread
5465 // calling resume on an active thread is a no-op
5466 static void do_resume(HANDLE* h) {
5467   if (h != NULL) {
5468     ResumeThread(*h);
5469   }
5470 }
5471 
5472 // retrieve a suspend/resume context capable handle
5473 // from the tid. Caller validates handle return value.
5474 void get_thread_handle_for_extended_context(HANDLE* h,
5475                                             OSThread::thread_id_t tid) {
5476   if (h != NULL) {
5477     *h = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);
5478   }
5479 }
5480 
5481 // Thread sampling implementation
5482 //
5483 void os::SuspendedThreadTask::internal_do_task() {
5484   CONTEXT    ctxt;
5485   HANDLE     h = NULL;
5486 
5487   // get context capable handle for thread
5488   get_thread_handle_for_extended_context(&amp;h, _thread-&gt;osthread()-&gt;thread_id());
5489 
5490   // sanity
5491   if (h == NULL || h == INVALID_HANDLE_VALUE) {
5492     return;
5493   }
5494 
5495   // suspend the thread
5496   if (do_suspend(&amp;h)) {
5497     ctxt.ContextFlags = sampling_context_flags;
5498     // get thread context
5499     GetThreadContext(h, &amp;ctxt);
5500     SuspendedThreadTaskContext context(_thread, &amp;ctxt);
5501     // pass context to Thread Sampling impl
5502     do_task(context);
5503     // resume thread
5504     do_resume(&amp;h);
5505   }
5506 
5507   // close handle
5508   CloseHandle(h);
5509 }
5510 
5511 bool os::start_debugging(char *buf, int buflen) {
5512   int len = (int)strlen(buf);
5513   char *p = &amp;buf[len];
5514 
5515   jio_snprintf(p, buflen-len,
5516              &quot;\n\n&quot;
5517              &quot;Do you want to debug the problem?\n\n&quot;
5518              &quot;To debug, attach Visual Studio to process %d; then switch to thread 0x%x\n&quot;
5519              &quot;Select &#39;Yes&#39; to launch Visual Studio automatically (PATH must include msdev)\n&quot;
5520              &quot;Otherwise, select &#39;No&#39; to abort...&quot;,
5521              os::current_process_id(), os::current_thread_id());
5522 
5523   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
5524 
5525   if (yes) {
5526     // os::breakpoint() calls DebugBreak(), which causes a breakpoint
5527     // exception. If VM is running inside a debugger, the debugger will
5528     // catch the exception. Otherwise, the breakpoint exception will reach
5529     // the default windows exception handler, which can spawn a debugger and
5530     // automatically attach to the dying VM.
5531     os::breakpoint();
5532     yes = false;
5533   }
5534   return yes;
5535 }
5536 
5537 void* os::get_default_process_handle() {
5538   return (void*)GetModuleHandle(NULL);
5539 }
5540 
5541 // Builds a platform dependent Agent_OnLoad_&lt;lib_name&gt; function name
5542 // which is used to find statically linked in agents.
5543 // Additionally for windows, takes into account __stdcall names.
5544 // Parameters:
5545 //            sym_name: Symbol in library we are looking for
5546 //            lib_name: Name of library to look in, NULL for shared libs.
5547 //            is_absolute_path == true if lib_name is absolute path to agent
5548 //                                     such as &quot;C:/a/b/L.dll&quot;
5549 //            == false if only the base name of the library is passed in
5550 //               such as &quot;L&quot;
5551 char* os::build_agent_function_name(const char *sym_name, const char *lib_name,
5552                                     bool is_absolute_path) {
5553   char *agent_entry_name;
5554   size_t len;
5555   size_t name_len;
5556   size_t prefix_len = strlen(JNI_LIB_PREFIX);
5557   size_t suffix_len = strlen(JNI_LIB_SUFFIX);
5558   const char *start;
5559 
5560   if (lib_name != NULL) {
5561     len = name_len = strlen(lib_name);
5562     if (is_absolute_path) {
5563       // Need to strip path, prefix and suffix
5564       if ((start = strrchr(lib_name, *os::file_separator())) != NULL) {
5565         lib_name = ++start;
5566       } else {
5567         // Need to check for drive prefix
5568         if ((start = strchr(lib_name, &#39;:&#39;)) != NULL) {
5569           lib_name = ++start;
5570         }
5571       }
5572       if (len &lt;= (prefix_len + suffix_len)) {
5573         return NULL;
5574       }
5575       lib_name += prefix_len;
5576       name_len = strlen(lib_name) - suffix_len;
5577     }
5578   }
5579   len = (lib_name != NULL ? name_len : 0) + strlen(sym_name) + 2;
5580   agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);
5581   if (agent_entry_name == NULL) {
5582     return NULL;
5583   }
5584   if (lib_name != NULL) {
5585     const char *p = strrchr(sym_name, &#39;@&#39;);
5586     if (p != NULL &amp;&amp; p != sym_name) {
5587       // sym_name == _Agent_OnLoad@XX
5588       strncpy(agent_entry_name, sym_name, (p - sym_name));
5589       agent_entry_name[(p-sym_name)] = &#39;\0&#39;;
5590       // agent_entry_name == _Agent_OnLoad
5591       strcat(agent_entry_name, &quot;_&quot;);
5592       strncat(agent_entry_name, lib_name, name_len);
5593       strcat(agent_entry_name, p);
5594       // agent_entry_name == _Agent_OnLoad_lib_name@XX
5595     } else {
5596       strcpy(agent_entry_name, sym_name);
5597       strcat(agent_entry_name, &quot;_&quot;);
5598       strncat(agent_entry_name, lib_name, name_len);
5599     }
5600   } else {
5601     strcpy(agent_entry_name, sym_name);
5602   }
5603   return agent_entry_name;
5604 }
5605 
5606 #ifndef PRODUCT
5607 
5608 // test the code path in reserve_memory_special() that tries to allocate memory in a single
5609 // contiguous memory block at a particular address.
5610 // The test first tries to find a good approximate address to allocate at by using the same
5611 // method to allocate some memory at any address. The test then tries to allocate memory in
5612 // the vicinity (not directly after it to avoid possible by-chance use of that location)
5613 // This is of course only some dodgy assumption, there is no guarantee that the vicinity of
5614 // the previously allocated memory is available for allocation. The only actual failure
5615 // that is reported is when the test tries to allocate at a particular location but gets a
5616 // different valid one. A NULL return value at this point is not considered an error but may
5617 // be legitimate.
5618 void TestReserveMemorySpecial_test() {
5619   if (!UseLargePages) {
5620     return;
5621   }
5622   // save current value of globals
5623   bool old_use_large_pages_individual_allocation = UseLargePagesIndividualAllocation;
5624   bool old_use_numa_interleaving = UseNUMAInterleaving;
5625 
5626   // set globals to make sure we hit the correct code path
5627   UseLargePagesIndividualAllocation = UseNUMAInterleaving = false;
5628 
5629   // do an allocation at an address selected by the OS to get a good one.
5630   const size_t large_allocation_size = os::large_page_size() * 4;
5631   char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), NULL, false);
5632   if (result == NULL) {
5633   } else {
5634     os::release_memory_special(result, large_allocation_size);
5635 
5636     // allocate another page within the recently allocated memory area which seems to be a good location. At least
5637     // we managed to get it once.
5638     const size_t expected_allocation_size = os::large_page_size();
5639     char* expected_location = result + os::large_page_size();
5640     char* actual_location = os::reserve_memory_special(expected_allocation_size, os::large_page_size(), expected_location, false);
5641     if (actual_location == NULL) {
5642     } else {
5643       // release memory
5644       os::release_memory_special(actual_location, expected_allocation_size);
5645       // only now check, after releasing any memory to avoid any leaks.
5646       assert(actual_location == expected_location,
5647              &quot;Failed to allocate memory at requested location &quot; PTR_FORMAT &quot; of size &quot; SIZE_FORMAT &quot;, is &quot; PTR_FORMAT &quot; instead&quot;,
5648              expected_location, expected_allocation_size, actual_location);
5649     }
5650   }
5651 
5652   // restore globals
5653   UseLargePagesIndividualAllocation = old_use_large_pages_individual_allocation;
5654   UseNUMAInterleaving = old_use_numa_interleaving;
5655 }
5656 #endif // PRODUCT
5657 
5658 /*
5659   All the defined signal names for Windows.
5660 
5661   NOTE that not all of these names are accepted by FindSignal!
5662 
5663   For various reasons some of these may be rejected at runtime.
5664 
5665   Here are the names currently accepted by a user of sun.misc.Signal with
5666   1.4.1 (ignoring potential interaction with use of chaining, etc):
5667 
5668      (LIST TBD)
5669 
5670 */
5671 int os::get_signal_number(const char* name) {
5672   static const struct {
5673     const char* name;
5674     int         number;
5675   } siglabels [] =
5676     // derived from version 6.0 VC98/include/signal.h
5677   {&quot;ABRT&quot;,      SIGABRT,        // abnormal termination triggered by abort cl
5678   &quot;FPE&quot;,        SIGFPE,         // floating point exception
5679   &quot;SEGV&quot;,       SIGSEGV,        // segment violation
5680   &quot;INT&quot;,        SIGINT,         // interrupt
5681   &quot;TERM&quot;,       SIGTERM,        // software term signal from kill
5682   &quot;BREAK&quot;,      SIGBREAK,       // Ctrl-Break sequence
5683   &quot;ILL&quot;,        SIGILL};        // illegal instruction
5684   for (unsigned i = 0; i &lt; ARRAY_SIZE(siglabels); ++i) {
5685     if (strcmp(name, siglabels[i].name) == 0) {
5686       return siglabels[i].number;
5687     }
5688   }
5689   return -1;
5690 }
5691 
5692 // Fast current thread access
5693 
5694 int os::win32::_thread_ptr_offset = 0;
5695 
5696 static void call_wrapper_dummy() {}
5697 
5698 // We need to call the os_exception_wrapper once so that it sets
5699 // up the offset from FS of the thread pointer.
5700 void os::win32::initialize_thread_ptr_offset() {
5701   os::os_exception_wrapper((java_call_t)call_wrapper_dummy,
5702                            NULL, methodHandle(), NULL, NULL);
5703 }
5704 
5705 bool os::supports_map_sync() {
5706   return false;
5707 }
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>