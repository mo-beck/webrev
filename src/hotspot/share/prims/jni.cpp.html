<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src\hotspot\share\prims\jni.cpp</title>
    <link rel="stylesheet" href="..\..\..\..\style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/modules.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  40 #include &quot;interpreter/linkResolver.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/arrayOop.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceOop.hpp&quot;
  53 #include &quot;oops/markWord.hpp&quot;
  54 #include &quot;oops/method.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/symbol.hpp&quot;
  59 #include &quot;oops/typeArrayKlass.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  61 #include &quot;prims/jniCheck.hpp&quot;
  62 #include &quot;prims/jniExport.hpp&quot;
  63 #include &quot;prims/jniFastGetField.hpp&quot;
  64 #include &quot;prims/jvm_misc.hpp&quot;
  65 #include &quot;prims/jvmtiExport.hpp&quot;
  66 #include &quot;prims/jvmtiThreadState.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  69 #include &quot;runtime/handles.inline.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/reflection.hpp&quot;
  76 #include &quot;runtime/safepointVerifiers.hpp&quot;
  77 #include &quot;runtime/sharedRuntime.hpp&quot;
  78 #include &quot;runtime/signature.hpp&quot;
  79 #include &quot;runtime/thread.inline.hpp&quot;
  80 #include &quot;runtime/vmOperations.hpp&quot;
  81 #include &quot;services/memTracker.hpp&quot;
  82 #include &quot;services/runtimeService.hpp&quot;
  83 #include &quot;utilities/defaultStream.hpp&quot;
  84 #include &quot;utilities/dtrace.hpp&quot;
  85 #include &quot;utilities/events.hpp&quot;
  86 #include &quot;utilities/histogram.hpp&quot;
  87 #include &quot;utilities/macros.hpp&quot;
  88 #include &quot;utilities/vmError.hpp&quot;
  89 #if INCLUDE_JVMCI
  90 #include &quot;jvmci/jvmciCompiler.hpp&quot;
  91 #endif
  92 
  93 static jint CurrentVersion = JNI_VERSION_10;
  94 
  95 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
  96 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
  97 // Methods that have multiple return paths use this to avoid having to
  98 // instrument each return path.  Methods that use CHECK or THROW must use this
  99 // since those macros can cause an immedate uninstrumented return.
 100 //
 101 // In order to get the return value, a reference to the variable containing
 102 // the return value must be passed to the contructor of the object, and
 103 // the return value must be set before return (since the mark object has
 104 // a reference to it).
 105 //
 106 // Example:
 107 // DT_RETURN_MARK_DECL(SomeFunc, int);
 108 // JNI_ENTRY(int, SomeFunc, ...)
 109 //   int return_value = 0;
 110 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 111 //   foo(CHECK_0)
 112 //   return_value = 5;
 113 //   return return_value;
 114 // JNI_END
 115 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 116   DTRACE_ONLY(                                                             \
 117     class DTraceReturnProbeMark_##name {                                   \
 118      public:                                                               \
 119       const type&amp; _ret_ref;                                                \
 120       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 121       ~DTraceReturnProbeMark_##name() {                                    \
 122         probe;                                                             \
 123       }                                                                    \
 124     }                                                                      \
 125   )
 126 // Void functions are simpler since there&#39;s no return value
 127 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 128   DTRACE_ONLY(                                                             \
 129     class DTraceReturnProbeMark_##name {                                   \
 130      public:                                                               \
 131       ~DTraceReturnProbeMark_##name() {                                    \
 132         probe;                                                             \
 133       }                                                                    \
 134     }                                                                      \
 135   )
 136 
 137 // Place these macros in the function to mark the return.  Non-void
 138 // functions need the type and address of the return value.
 139 #define DT_RETURN_MARK(name, type, ref) \
 140   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 141 #define DT_VOID_RETURN_MARK(name) \
 142   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 143 
 144 
 145 // Use these to select distinct code for floating-point vs. non-floating point
 146 // situations.  Used from within common macros where we need slightly
 147 // different behavior for Float/Double
 148 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 149 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 150 #define FP_SELECT_Char(intcode, fpcode)    intcode
 151 #define FP_SELECT_Short(intcode, fpcode)   intcode
 152 #define FP_SELECT_Object(intcode, fpcode)  intcode
 153 #define FP_SELECT_Int(intcode, fpcode)     intcode
 154 #define FP_SELECT_Long(intcode, fpcode)    intcode
 155 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 156 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 157 #define FP_SELECT(TypeName, intcode, fpcode) \
 158   FP_SELECT_##TypeName(intcode, fpcode)
 159 
 160 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 161 // (dtrace doesn&#39;t do FP yet)
 162 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 163   FP_SELECT(TypeName, \
 164     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 165 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 166   FP_SELECT(TypeName, \
 167     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 168 
 169 
 170 // out-of-line helpers for class jfieldIDWorkaround:
 171 
 172 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 173   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 174     uintptr_t as_uint = (uintptr_t) id;
 175     intptr_t offset = raw_instance_offset(id);
 176     if (is_checked_jfieldID(id)) {
 177       if (!klass_hash_ok(k, id)) {
 178         return false;
 179       }
 180     }
 181     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 182   } else {
 183     JNIid* result = (JNIid*) id;
 184 #ifdef ASSERT
 185     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 186 #else
 187     return result != NULL;
 188 #endif
 189   }
 190 }
 191 
 192 
 193 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 194   if (offset &lt;= small_offset_mask) {
 195     Klass* field_klass = k;
 196     Klass* super_klass = field_klass-&gt;super();
 197     // With compressed oops the most super class with nonstatic fields would
 198     // be the owner of fields embedded in the header.
 199     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 200            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 201       field_klass = super_klass;   // super contains the field also
 202       super_klass = field_klass-&gt;super();
 203     }
 204     debug_only(NoSafepointVerifier nosafepoint;)
 205     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 206     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 207   } else {
 208 #if 0
 209     #ifndef PRODUCT
 210     {
 211       ResourceMark rm;
 212       warning(&quot;VerifyJNIFields: long offset %d in %s&quot;, offset, k-&gt;external_name());
 213     }
 214     #endif
 215 #endif
 216     return 0;
 217   }
 218 }
 219 
 220 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 221   uintptr_t as_uint = (uintptr_t) id;
 222   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 223   do {
 224     debug_only(NoSafepointVerifier nosafepoint;)
 225     // Could use a non-blocking query for identity_hash here...
 226     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 227       return true;
 228     k = k-&gt;super();
 229   } while (k != NULL);
 230   return false;
 231 }
 232 
 233 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 234   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), &quot;must be an instance field&quot; );
 235   uintptr_t as_uint = (uintptr_t) id;
 236   intptr_t offset = raw_instance_offset(id);
 237   if (VerifyJNIFields) {
 238     if (is_checked_jfieldID(id)) {
 239       guarantee(klass_hash_ok(k, id),
 240     &quot;Bug in native code: jfieldID class must match object&quot;);
 241     } else {
 242 #if 0
 243       #ifndef PRODUCT
 244       if (Verbose) {
 245   ResourceMark rm;
 246   warning(&quot;VerifyJNIFields: unverified offset %d for %s&quot;, offset, k-&gt;external_name());
 247       }
 248       #endif
 249 #endif
 250     }
 251   }
 252   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 253       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 254 }
 255 
 256 // Wrapper to trace JNI functions
 257 
 258 #ifdef ASSERT
 259   Histogram* JNIHistogram;
 260   static volatile int JNIHistogram_lock = 0;
 261 
 262   class JNIHistogramElement : public HistogramElement {
 263     public:
 264      JNIHistogramElement(const char* name);
 265   };
 266 
 267   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 268     _name = elementName;
 269     uintx count = 0;
 270 
 271     while (Atomic::cmpxchg(&amp;JNIHistogram_lock, 0, 1) != 0) {
 272       while (Atomic::load_acquire(&amp;JNIHistogram_lock) != 0) {
 273         count +=1;
 274         if ( (WarnOnStalledSpinLock &gt; 0)
 275           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 276           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 277         }
 278       }
 279      }
 280 
 281 
 282     if(JNIHistogram == NULL)
 283       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 284 
 285     JNIHistogram-&gt;add_element(this);
 286     Atomic::dec(&amp;JNIHistogram_lock);
 287   }
 288 
 289   #define JNICountWrapper(arg)                                     \
 290      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 291       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 292      if (e != NULL) e-&gt;increment_count()
 293   #define JNIWrapper(arg) JNICountWrapper(arg);
 294 #else
 295   #define JNIWrapper(arg)
 296 #endif
 297 
 298 
 299 // Implementation of JNI entries
 300 
 301 DT_RETURN_MARK_DECL(DefineClass, jclass
 302                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 303 
 304 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 305                                   const jbyte *buf, jsize bufLen))
 306   JNIWrapper(&quot;DefineClass&quot;);
 307 
 308   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 309     env, (char*) name, loaderRef, (char*) buf, bufLen);
 310 
 311   jclass cls = NULL;
 312   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 313 
 314   TempNewSymbol class_name = NULL;
 315   // Since exceptions can be thrown, class initialization can take place
 316   // if name is NULL no check for class name in .class stream has to be made.
 317   if (name != NULL) {
 318     const int str_len = (int)strlen(name);
 319     if (str_len &gt; Symbol::max_length()) {
 320       // It&#39;s impossible to create this class;  the name cannot fit
 321       // into the constant pool.
 322       Exceptions::fthrow(THREAD_AND_LOCATION,
 323                          vmSymbols::java_lang_NoClassDefFoundError(),
 324                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 325                          Symbol::max_length(),
 326                          name);
 327       return 0;
 328     }
 329     class_name = SymbolTable::new_symbol(name);
 330   }
 331   ResourceMark rm(THREAD);
 332   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 333   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 334 
 335   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 336     // check whether the current caller thread holds the lock or not.
 337     // If not, increment the corresponding counter
 338     if (ObjectSynchronizer::
 339         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 340         ObjectSynchronizer::owner_self) {
 341       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 342     }
 343   }
 344   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 345                                                    class_loader,
 346                                                    Handle(),
 347                                                    &amp;st,
 348                                                    CHECK_NULL);
 349 
 350   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 351     trace_class_resolution(k);
 352   }
 353 
 354   cls = (jclass)JNIHandles::make_local(
 355     env, k-&gt;java_mirror());
 356   return cls;
 357 JNI_END
 358 
 359 
 360 
 361 DT_RETURN_MARK_DECL(FindClass, jclass
 362                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 363 
 364 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 365   JNIWrapper(&quot;FindClass&quot;);
 366 
 367   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 368 
 369   jclass result = NULL;
 370   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 371 
 372   // Sanity check the name:  it cannot be null or larger than the maximum size
 373   // name we can fit in the constant pool.
 374   if (name == NULL) {
 375     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 376   }
 377   if ((int)strlen(name) &gt; Symbol::max_length()) {
 378     Exceptions::fthrow(THREAD_AND_LOCATION,
 379                        vmSymbols::java_lang_NoClassDefFoundError(),
 380                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 381                        Symbol::max_length(),
 382                        name);
 383     return 0;
 384   }
 385 
 386   //%note jni_3
 387   Handle protection_domain;
 388   // Find calling class
 389   Klass* k = thread-&gt;security_get_caller_class(0);
 390   // default to the system loader when no context
 391   Handle loader(THREAD, SystemDictionary::java_system_loader());
 392   if (k != NULL) {
 393     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 394     // in the correct class context.
 395     if (k-&gt;class_loader() == NULL &amp;&amp;
 396         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {
 397       JavaValue result(T_OBJECT);
 398       JavaCalls::call_static(&amp;result, k,
 399                              vmSymbols::getFromClass_name(),
 400                              vmSymbols::void_class_signature(),
 401                              CHECK_NULL);
 402       // When invoked from JNI_OnLoad, NativeLibrary::getFromClass returns
 403       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 404       // it will return NULL to indicate no context.
 405       oop mirror = (oop) result.get_jobject();
 406       if (mirror != NULL) {
 407         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 408         loader = Handle(THREAD, fromClass-&gt;class_loader());
 409         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 410       }
 411     } else {
 412       loader = Handle(THREAD, k-&gt;class_loader());
 413     }
 414   }
 415 
 416   TempNewSymbol sym = SymbolTable::new_symbol(name);
 417   result = find_class_from_class_loader(env, sym, true, loader,
 418                                         protection_domain, true, thread);
 419 
 420   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 421     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 422   }
 423 
 424   return result;
 425 JNI_END
 426 
 427 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 428                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 429 
 430 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 431   JNIWrapper(&quot;FromReflectedMethod&quot;);
 432 
 433   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 434 
 435   jmethodID ret = NULL;
 436   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 437 
 438   // method is a handle to a java.lang.reflect.Method object
 439   oop reflected  = JNIHandles::resolve_non_null(method);
 440   oop mirror     = NULL;
 441   int slot       = 0;
 442 
 443   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 444     mirror = java_lang_reflect_Constructor::clazz(reflected);
 445     slot   = java_lang_reflect_Constructor::slot(reflected);
 446   } else {
 447     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 448     mirror = java_lang_reflect_Method::clazz(reflected);
 449     slot   = java_lang_reflect_Method::slot(reflected);
 450   }
 451   Klass* k1 = java_lang_Class::as_Klass(mirror);
 452 
 453   // Make sure class is initialized before handing id&#39;s out to methods
 454   k1-&gt;initialize(CHECK_NULL);
 455   Method* m = InstanceKlass::cast(k1)-&gt;method_with_idnum(slot);
 456   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 457   return ret;
 458 JNI_END
 459 
 460 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 461                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 462 
 463 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 464   JNIWrapper(&quot;FromReflectedField&quot;);
 465 
 466   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 467 
 468   jfieldID ret = NULL;
 469   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 470 
 471   // field is a handle to a java.lang.reflect.Field object
 472   oop reflected   = JNIHandles::resolve_non_null(field);
 473   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 474   Klass* k1       = java_lang_Class::as_Klass(mirror);
 475   int slot        = java_lang_reflect_Field::slot(reflected);
 476   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 477 
 478   // Make sure class is initialized before handing id&#39;s out to fields
 479   k1-&gt;initialize(CHECK_NULL);
 480 
 481   // First check if this is a static field
 482   if (modifiers &amp; JVM_ACC_STATIC) {
 483     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 484     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 485     assert(id != NULL, &quot;corrupt Field object&quot;);
 486     debug_only(id-&gt;set_is_static_field_id();)
 487     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 488     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 489     return ret;
 490   }
 491 
 492   // The slot is the index of the field description in the field-array
 493   // The jfieldID is the offset of the field within the object
 494   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 495   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 496   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
 497   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);
 498   return ret;
 499 JNI_END
 500 
 501 
 502 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 503                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 504 
 505 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 506   JNIWrapper(&quot;ToReflectedMethod&quot;);
 507 
 508   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 509 
 510   jobject ret = NULL;
 511   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 512 
 513   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 514   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 515   oop reflection_method;
 516   if (m-&gt;is_initializer()) {
 517     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 518   } else {
 519     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 520   }
 521   ret = JNIHandles::make_local(env, reflection_method);
 522   return ret;
 523 JNI_END
 524 
 525 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 526                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 527 
 528 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 529   JNIWrapper(&quot;GetSuperclass&quot;);
 530 
 531   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 532 
 533   jclass obj = NULL;
 534   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 535 
 536   oop mirror = JNIHandles::resolve_non_null(sub);
 537   // primitive classes return NULL
 538   if (java_lang_Class::is_primitive(mirror)) return NULL;
 539 
 540   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 541   // arrays return Object
 542   // interfaces return NULL
 543   // proper classes return Klass::super()
 544   Klass* k = java_lang_Class::as_Klass(mirror);
 545   if (k-&gt;is_interface()) return NULL;
 546 
 547   // return mirror for superclass
 548   Klass* super = k-&gt;java_super();
 549   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 550   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 551                                  ? SystemDictionary::Object_klass()
 552                                  : k-&gt;super() ) );
 553   assert(super == super2,
 554          &quot;java_super computation depends on interface, array, other super&quot;);
 555   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 556   return obj;
 557 JNI_END
 558 
 559 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 560   JNIWrapper(&quot;IsSubclassOf&quot;);
 561 
 562   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 563 
 564   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 565   oop super_mirror = JNIHandles::resolve_non_null(super);
 566   if (java_lang_Class::is_primitive(sub_mirror) ||
 567       java_lang_Class::is_primitive(super_mirror)) {
 568     jboolean ret = (sub_mirror == super_mirror);
 569 
 570     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 571     return ret;
 572   }
 573   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 574   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 575   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 576   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 577                    JNI_TRUE : JNI_FALSE;
 578 
 579   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 580   return ret;
 581 JNI_END
 582 
 583 
 584 DT_RETURN_MARK_DECL(Throw, jint
 585                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 586 
 587 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 588   JNIWrapper(&quot;Throw&quot;);
 589 
 590   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 591 
 592   jint ret = JNI_OK;
 593   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 594 
 595   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 596   ShouldNotReachHere();
 597   return 0;  // Mute compiler.
 598 JNI_END
 599 
 600 
 601 DT_RETURN_MARK_DECL(ThrowNew, jint
 602                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 603 
 604 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 605   JNIWrapper(&quot;ThrowNew&quot;);
 606 
 607   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 608 
 609   jint ret = JNI_OK;
 610   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 611 
 612   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 613   Symbol*  name = k-&gt;name();
 614   Handle class_loader (THREAD,  k-&gt;class_loader());
 615   Handle protection_domain (THREAD, k-&gt;protection_domain());
 616   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 617   ShouldNotReachHere();
 618   return 0;  // Mute compiler.
 619 JNI_END
 620 
 621 
 622 // JNI functions only transform a pending async exception to a synchronous
 623 // exception in ExceptionOccurred and ExceptionCheck calls, since
 624 // delivering an async exception in other places won&#39;t change the native
 625 // code&#39;s control flow and would be harmful when native code further calls
 626 // JNI functions with a pending exception. Async exception is also checked
 627 // during the call, so ExceptionOccurred/ExceptionCheck won&#39;t return
 628 // false but deliver the async exception at the very end during
 629 // state transition.
 630 
 631 static void jni_check_async_exceptions(JavaThread *thread) {
 632   assert(thread == Thread::current(), &quot;must be itself&quot;);
 633   thread-&gt;check_and_handle_async_exceptions();
 634 }
 635 
 636 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 637   JNIWrapper(&quot;ExceptionOccurred&quot;);
 638 
 639   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 640 
 641   jni_check_async_exceptions(thread);
 642   oop exception = thread-&gt;pending_exception();
 643   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 644 
 645   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 646   return ret;
 647 JNI_END
 648 
 649 
 650 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 651   JNIWrapper(&quot;ExceptionDescribe&quot;);
 652 
 653   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 654 
 655   if (thread-&gt;has_pending_exception()) {
 656     Handle ex(thread, thread-&gt;pending_exception());
 657     thread-&gt;clear_pending_exception();
 658     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 659       // Don&#39;t print anything if we are being killed.
 660     } else {
 661       jio_fprintf(defaultStream::error_stream(), &quot;Exception &quot;);
 662       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 663         ResourceMark rm(THREAD);
 664         jio_fprintf(defaultStream::error_stream(),
 665         &quot;in thread \&quot;%s\&quot; &quot;, thread-&gt;get_thread_name());
 666       }
 667       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 668         JavaValue result(T_VOID);
 669         JavaCalls::call_virtual(&amp;result,
 670                                 ex,
 671                                 SystemDictionary::Throwable_klass(),
 672                                 vmSymbols::printStackTrace_name(),
 673                                 vmSymbols::void_method_signature(),
 674                                 THREAD);
 675         // If an exception is thrown in the call it gets thrown away. Not much
 676         // we can do with it. The native code that calls this, does not check
 677         // for the exception - hence, it might still be in the thread when DestroyVM gets
 678         // called, potentially causing a few asserts to trigger - since no pending exception
 679         // is expected.
 680         CLEAR_PENDING_EXCEPTION;
 681       } else {
 682         ResourceMark rm(THREAD);
 683         jio_fprintf(defaultStream::error_stream(),
 684         &quot;. Uncaught exception of type %s.&quot;,
 685         ex-&gt;klass()-&gt;external_name());
 686       }
 687     }
 688   }
 689 
 690   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 691 JNI_END
 692 
 693 
 694 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))
 695   JNIWrapper(&quot;ExceptionClear&quot;);
 696 
 697   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 698 
 699   // The jni code might be using this API to clear java thrown exception.
 700   // So just mark jvmti thread exception state as exception caught.
 701   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 702   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 703     state-&gt;set_exception_caught();
 704   }
 705   thread-&gt;clear_pending_exception();
 706 
 707   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 708 JNI_END
 709 
 710 
 711 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 712   JNIWrapper(&quot;FatalError&quot;);
 713 
 714   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 715 
 716   tty-&gt;print_cr(&quot;FATAL ERROR in native method: %s&quot;, msg);
 717   thread-&gt;print_stack();
 718   os::abort(); // Dump core and abort
 719 JNI_END
 720 
 721 
 722 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 723   JNIWrapper(&quot;PushLocalFrame&quot;);
 724 
 725   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 726 
 727   //%note jni_11
 728   if (capacity &lt; 0 ||
 729       ((MaxJNILocalCapacity &gt; 0) &amp;&amp; (capacity &gt; MaxJNILocalCapacity))) {
 730     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 731     return JNI_ERR;
 732   }
 733   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 734   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 735   assert(new_handles != NULL, &quot;should not be NULL&quot;);
 736   new_handles-&gt;set_pop_frame_link(old_handles);
 737   thread-&gt;set_active_handles(new_handles);
 738   jint ret = JNI_OK;
 739   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 740   return ret;
 741 JNI_END
 742 
 743 
 744 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 745   JNIWrapper(&quot;PopLocalFrame&quot;);
 746 
 747   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 748 
 749   //%note jni_11
 750   Handle result_handle(thread, JNIHandles::resolve(result));
 751   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 752   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 753   if (new_handles != NULL) {
 754     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 755     // This way code will still work if PopLocalFrame is called without a corresponding
 756     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 757     // the release_block call will release the blocks.
 758     thread-&gt;set_active_handles(new_handles);
 759     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won&#39;t release new_handles below
 760     JNIHandleBlock::release_block(old_handles, thread); // may block
 761     result = JNIHandles::make_local(thread, result_handle());
 762   }
 763   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 764   return result;
 765 JNI_END
 766 
 767 
 768 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 769   JNIWrapper(&quot;NewGlobalRef&quot;);
 770 
 771   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 772 
 773   Handle ref_handle(thread, JNIHandles::resolve(ref));
 774   jobject ret = JNIHandles::make_global(ref_handle);
 775 
 776   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 777   return ret;
 778 JNI_END
 779 
 780 // Must be JNI_ENTRY (with HandleMark)
 781 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 782   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 783 
 784   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 785 
 786   JNIHandles::destroy_global(ref);
 787 
 788   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 789 JNI_END
 790 
 791 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 792   JNIWrapper(&quot;DeleteLocalRef&quot;);
 793 
 794   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 795 
 796   JNIHandles::destroy_local(obj);
 797 
 798   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 799 JNI_END
 800 
 801 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 802   JNIWrapper(&quot;IsSameObject&quot;);
 803 
 804   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 805 
 806   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 807 
 808   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 809   return ret;
 810 JNI_END
 811 
 812 
 813 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 814   JNIWrapper(&quot;NewLocalRef&quot;);
 815 
 816   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 817 
 818   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 819 
 820   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 821   return ret;
 822 JNI_END
 823 
 824 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 825   JNIWrapper(&quot;EnsureLocalCapacity&quot;);
 826 
 827   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 828 
 829   jint ret;
 830   if (capacity &gt;= 0 &amp;&amp;
 831       ((MaxJNILocalCapacity &lt;= 0) || (capacity &lt;= MaxJNILocalCapacity))) {
 832     ret = JNI_OK;
 833   } else {
 834     ret = JNI_ERR;
 835   }
 836 
 837   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 838   return ret;
 839 JNI_END
 840 
 841 // Return the Handle Type
 842 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 843   JNIWrapper(&quot;GetObjectRefType&quot;);
 844 
 845   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 846 
 847   jobjectRefType ret = JNIInvalidRefType;
 848   if (obj != NULL) {
 849     ret = JNIHandles::handle_type(thread, obj);
 850   }
 851 
 852   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 853   return ret;
 854 JNI_END
 855 
 856 
 857 class JNI_ArgumentPusher : public SignatureIterator {
 858  protected:
 859   JavaCallArguments*  _arguments;
 860 
 861   virtual void get_bool   () = 0;
 862   virtual void get_char   () = 0;
 863   virtual void get_short  () = 0;
 864   virtual void get_byte   () = 0;
 865   virtual void get_int    () = 0;
 866   virtual void get_long   () = 0;
 867   virtual void get_float  () = 0;
 868   virtual void get_double () = 0;
 869   virtual void get_object () = 0;
 870 
 871   JNI_ArgumentPusher(Symbol* signature) : SignatureIterator(signature) {
 872     this-&gt;_return_type = T_ILLEGAL;
 873     _arguments = NULL;
 874   }
 875 
 876  public:
 877   virtual void iterate( uint64_t fingerprint ) = 0;
 878 
 879   void set_java_argument_object(JavaCallArguments *arguments) { _arguments = arguments; }
 880 
 881   inline void do_bool()                     { if (!is_return_type()) get_bool();   }
 882   inline void do_char()                     { if (!is_return_type()) get_char();   }
 883   inline void do_short()                    { if (!is_return_type()) get_short();  }
 884   inline void do_byte()                     { if (!is_return_type()) get_byte();   }
 885   inline void do_int()                      { if (!is_return_type()) get_int();    }
 886   inline void do_long()                     { if (!is_return_type()) get_long();   }
 887   inline void do_float()                    { if (!is_return_type()) get_float();  }
 888   inline void do_double()                   { if (!is_return_type()) get_double(); }
 889   inline void do_object(int begin, int end) { if (!is_return_type()) get_object(); }
 890   inline void do_array(int begin, int end)  { if (!is_return_type()) get_object(); } // do_array uses get_object -- there is no get_array
 891   inline void do_void()                     { }
 892 
 893   JavaCallArguments* arguments()     { return _arguments; }
 894   void push_receiver(Handle h)       { _arguments-&gt;push_oop(h); }
 895 };
 896 
 897 
 898 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 899  protected:
 900   va_list _ap;
 901 
 902   inline void get_bool()   {
 903     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
 904     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
 905     // TemplateInterpreterGenerator::generate_result_handler_for and
 906     // SharedRuntime::generate_native_wrapper.
 907     jboolean b = va_arg(_ap, jint);
 908     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));
 909   }
 910   inline void get_char()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // char is coerced to int when using va_arg
 911   inline void get_short()  { _arguments-&gt;push_int(va_arg(_ap, jint)); } // short is coerced to int when using va_arg
 912   inline void get_byte()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // byte is coerced to int when using va_arg
 913   inline void get_int()    { _arguments-&gt;push_int(va_arg(_ap, jint)); }
 914 
 915   // each of these paths is exercized by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 916 
 917   inline void get_long()   { _arguments-&gt;push_long(va_arg(_ap, jlong)); }
 918   inline void get_float()  { _arguments-&gt;push_float((jfloat)va_arg(_ap, jdouble)); } // float is coerced to double w/ va_arg
 919   inline void get_double() { _arguments-&gt;push_double(va_arg(_ap, jdouble)); }
 920   inline void get_object() { _arguments-&gt;push_jobject(va_arg(_ap, jobject)); }
 921 
 922   inline void set_ap(va_list rap) {
 923     va_copy(_ap, rap);
 924   }
 925 
 926  public:
 927   JNI_ArgumentPusherVaArg(Symbol* signature, va_list rap)
 928        : JNI_ArgumentPusher(signature) {
 929     set_ap(rap);
 930   }
 931   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 932       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {
 933     set_ap(rap);
 934   }
 935 
 936   // Optimized path if we have the bitvector form of signature
 937   void iterate( uint64_t fingerprint ) {
 938     if (fingerprint == (uint64_t)CONST64(-1)) {
 939       SignatureIterator::iterate(); // Must be too many arguments
 940     } else {
 941       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;
 942                                   result_feature_mask);
 943 
 944       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);
 945       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);
 946       while ( 1 ) {
 947         switch ( fingerprint &amp; parameter_feature_mask ) {
 948           case bool_parm:
 949             get_bool();
 950             break;
 951           case char_parm:
 952             get_char();
 953             break;
 954           case short_parm:
 955             get_short();
 956             break;
 957           case byte_parm:
 958             get_byte();
 959             break;
 960           case int_parm:
 961             get_int();
 962             break;
 963           case obj_parm:
 964             get_object();
 965             break;
 966           case long_parm:
 967             get_long();
 968             break;
 969           case float_parm:
 970             get_float();
 971             break;
 972           case double_parm:
 973             get_double();
 974             break;
 975           case done_parm:
 976             return;
 977             break;
 978           default:
 979             ShouldNotReachHere();
 980             break;
 981         }
 982         fingerprint &gt;&gt;= parameter_feature_size;
 983       }
 984     }
 985   }
 986 };
 987 
 988 
 989 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 990  protected:
 991   const jvalue *_ap;
 992 
 993   inline void get_bool()   {
 994     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
 995     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
 996     // TemplateInterpreterGenerator::generate_result_handler_for and
 997     // SharedRuntime::generate_native_wrapper.
 998     jboolean b = (_ap++)-&gt;z;
 999     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));
1000   }
1001   inline void get_char()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;c); }
1002   inline void get_short()  { _arguments-&gt;push_int((jint)(_ap++)-&gt;s); }
1003   inline void get_byte()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;b); }
1004   inline void get_int()    { _arguments-&gt;push_int((jint)(_ap++)-&gt;i); }
1005 
1006   inline void get_long()   { _arguments-&gt;push_long((_ap++)-&gt;j);  }
1007   inline void get_float()  { _arguments-&gt;push_float((_ap++)-&gt;f); }
1008   inline void get_double() { _arguments-&gt;push_double((_ap++)-&gt;d);}
1009   inline void get_object() { _arguments-&gt;push_jobject((_ap++)-&gt;l); }
1010 
1011   inline void set_ap(const jvalue *rap) { _ap = rap; }
1012 
1013  public:
1014   JNI_ArgumentPusherArray(Symbol* signature, const jvalue *rap)
1015        : JNI_ArgumentPusher(signature) {
1016     set_ap(rap);
1017   }
1018   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
1019       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {
1020     set_ap(rap);
1021   }
1022 
1023   // Optimized path if we have the bitvector form of signature
1024   void iterate( uint64_t fingerprint ) {
1025     if (fingerprint == (uint64_t)CONST64(-1)) {
1026       SignatureIterator::iterate(); // Must be too many arguments
1027     } else {
1028       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;
1029                                   result_feature_mask);
1030       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);
1031       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);
1032       while ( 1 ) {
1033         switch ( fingerprint &amp; parameter_feature_mask ) {
1034           case bool_parm:
1035             get_bool();
1036             break;
1037           case char_parm:
1038             get_char();
1039             break;
1040           case short_parm:
1041             get_short();
1042             break;
1043           case byte_parm:
1044             get_byte();
1045             break;
1046           case int_parm:
1047             get_int();
1048             break;
1049           case obj_parm:
1050             get_object();
1051             break;
1052           case long_parm:
1053             get_long();
1054             break;
1055           case float_parm:
1056             get_float();
1057             break;
1058           case double_parm:
1059             get_double();
1060             break;
1061           case done_parm:
1062             return;
1063             break;
1064           default:
1065             ShouldNotReachHere();
1066             break;
1067         }
1068         fingerprint &gt;&gt;= parameter_feature_size;
1069       }
1070     }
1071   }
1072 };
1073 
1074 
1075 enum JNICallType {
1076   JNI_STATIC,
1077   JNI_VIRTUAL,
1078   JNI_NONVIRTUAL
1079 };
1080 
1081 
1082 
1083 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1084   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
1085 
1086   // Create object to hold arguments for the JavaCall, and associate it with
1087   // the jni parser
1088   ResourceMark rm(THREAD);
1089   int number_of_parameters = method-&gt;size_of_parameters();
1090   JavaCallArguments java_args(number_of_parameters);
1091   args-&gt;set_java_argument_object(&amp;java_args);
1092 
1093   assert(method-&gt;is_static(), &quot;method should be static&quot;);
1094 
1095   // Fill out JavaCallArguments object
1096   args-&gt;iterate( Fingerprinter(method).fingerprint() );
1097   // Initialize result type
1098   result-&gt;set_type(args-&gt;get_ret_type());
1099 
1100   // Invoke the method. Result is returned as oop.
1101   JavaCalls::call(result, method, &amp;java_args, CHECK);
1102 
1103   // Convert result
1104   if (is_reference_type(result-&gt;get_type())) {
1105     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1106   }
1107 }
1108 
1109 
1110 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1111   oop recv = JNIHandles::resolve(receiver);
1112   if (recv == NULL) {
1113     THROW(vmSymbols::java_lang_NullPointerException());
1114   }
1115   Handle h_recv(THREAD, recv);
1116 
1117   int number_of_parameters;
1118   Method* selected_method;
1119   {
1120     Method* m = Method::resolve_jmethod_id(method_id);
1121     number_of_parameters = m-&gt;size_of_parameters();
1122     Klass* holder = m-&gt;method_holder();
1123     if (call_type != JNI_VIRTUAL) {
1124         selected_method = m;
1125     } else if (!m-&gt;has_itable_index()) {
1126       // non-interface call -- for that little speed boost, don&#39;t handlize
1127       debug_only(NoSafepointVerifier nosafepoint;)
1128       // jni_GetMethodID makes sure class is linked and initialized
1129       // so m should have a valid vtable index.
1130       assert(m-&gt;valid_vtable_index(), &quot;no valid vtable index&quot;);
1131       int vtbl_index = m-&gt;vtable_index();
1132       if (vtbl_index != Method::nonvirtual_vtable_index) {
1133         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1134       } else {
1135         // final method
1136         selected_method = m;
1137       }
1138     } else {
1139       // interface call
1140       int itbl_index = m-&gt;itable_index();
1141       Klass* k = h_recv-&gt;klass();
1142       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1143     }
1144   }
1145 
1146   methodHandle method(THREAD, selected_method);
1147 
1148   // Create object to hold arguments for the JavaCall, and associate it with
1149   // the jni parser
1150   ResourceMark rm(THREAD);
1151   JavaCallArguments java_args(number_of_parameters);
1152   args-&gt;set_java_argument_object(&amp;java_args);
1153 
1154   // handle arguments
1155   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
1156   args-&gt;push_receiver(h_recv); // Push jobject handle
1157 
1158   // Fill out JavaCallArguments object
1159   args-&gt;iterate( Fingerprinter(method).fingerprint() );
1160   // Initialize result type
1161   result-&gt;set_type(args-&gt;get_ret_type());
1162 
1163   // Invoke the method. Result is returned as oop.
1164   JavaCalls::call(result, method, &amp;java_args, CHECK);
1165 
1166   // Convert result
1167   if (is_reference_type(result-&gt;get_type())) {
1168     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1169   }
1170 }
1171 
1172 
1173 static instanceOop alloc_object(jclass clazz, TRAPS) {
1174   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1175   if (k == NULL) {
1176     ResourceMark rm(THREAD);
1177     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1178   }
1179   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1180   k-&gt;initialize(CHECK_NULL);
1181   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
1182   return ih;
1183 }
1184 
1185 DT_RETURN_MARK_DECL(AllocObject, jobject
1186                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1187 
1188 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1189   JNIWrapper(&quot;AllocObject&quot;);
1190 
1191   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1192 
1193   jobject ret = NULL;
1194   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1195 
1196   instanceOop i = alloc_object(clazz, CHECK_NULL);
1197   ret = JNIHandles::make_local(env, i);
1198   return ret;
1199 JNI_END
1200 
1201 DT_RETURN_MARK_DECL(NewObjectA, jobject
1202                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1203 
1204 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1205   JNIWrapper(&quot;NewObjectA&quot;);
1206 
1207   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1208 
1209   jobject obj = NULL;
1210   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1211 
1212   instanceOop i = alloc_object(clazz, CHECK_NULL);
1213   obj = JNIHandles::make_local(env, i);
1214   JavaValue jvalue(T_VOID);
1215   JNI_ArgumentPusherArray ap(methodID, args);
1216   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1217   return obj;
1218 JNI_END
1219 
1220 
1221 DT_RETURN_MARK_DECL(NewObjectV, jobject
1222                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1223 
1224 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1225   JNIWrapper(&quot;NewObjectV&quot;);
1226 
1227   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1228 
1229   jobject obj = NULL;
1230   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1231 
1232   instanceOop i = alloc_object(clazz, CHECK_NULL);
1233   obj = JNIHandles::make_local(env, i);
1234   JavaValue jvalue(T_VOID);
1235   JNI_ArgumentPusherVaArg ap(methodID, args);
1236   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1237   return obj;
1238 JNI_END
1239 
1240 
1241 DT_RETURN_MARK_DECL(NewObject, jobject
1242                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1243 
1244 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1245   JNIWrapper(&quot;NewObject&quot;);
1246 
1247   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1248 
1249   jobject obj = NULL;
1250   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1251 
1252   instanceOop i = alloc_object(clazz, CHECK_NULL);
1253   obj = JNIHandles::make_local(env, i);
1254   va_list args;
1255   va_start(args, methodID);
1256   JavaValue jvalue(T_VOID);
1257   JNI_ArgumentPusherVaArg ap(methodID, args);
1258   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1259   va_end(args);
1260   return obj;
1261 JNI_END
1262 
1263 
1264 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1265   JNIWrapper(&quot;GetObjectClass&quot;);
1266 
1267   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1268 
1269   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1270   jclass ret =
1271     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1272 
1273   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1274   return ret;
1275 JNI_END
1276 
1277 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1278   JNIWrapper(&quot;IsInstanceOf&quot;);
1279 
1280   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1281 
1282   jboolean ret = JNI_TRUE;
1283   if (obj != NULL) {
1284     ret = JNI_FALSE;
1285     Klass* k = java_lang_Class::as_Klass(
1286       JNIHandles::resolve_non_null(clazz));
1287     if (k != NULL) {
1288       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1289     }
1290   }
1291 
1292   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1293   return ret;
1294 JNI_END
1295 
1296 
1297 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1298                                const char *sig, bool is_static, TRAPS) {
1299   // %%%% This code should probably just call into a method in the LinkResolver
1300   //
1301   // The class should have been loaded (we have an instance of the class
1302   // passed in) so the method and signature should already be in the symbol
1303   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1304   const char *name_to_probe = (name_str == NULL)
1305                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1306                         : name_str;
1307   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1308   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1309 
1310   if (name == NULL || signature == NULL) {
1311     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1312   }
1313 
1314   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1315 
1316   // Throw a NoSuchMethodError exception if we have an instance of a
1317   // primitive java.lang.Class
1318   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1319     ResourceMark rm;
1320     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1321   }
1322 
1323   // Make sure class is linked and initialized before handing id&#39;s out to
1324   // Method*s.
1325   klass-&gt;initialize(CHECK_NULL);
1326 
1327   Method* m;
1328   if (name == vmSymbols::object_initializer_name() ||
1329       name == vmSymbols::class_initializer_name()) {
1330     // Never search superclasses for constructors
1331     if (klass-&gt;is_instance_klass()) {
1332       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1333     } else {
1334       m = NULL;
1335     }
1336   } else {
1337     m = klass-&gt;lookup_method(name, signature);
1338     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1339       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1340     }
1341   }
1342   if (m == NULL || (m-&gt;is_static() != is_static)) {
1343     ResourceMark rm;
1344     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1345   }
1346   return m-&gt;jmethod_id();
1347 }
1348 
1349 
1350 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1351           const char *name, const char *sig))
1352   JNIWrapper(&quot;GetMethodID&quot;);
1353   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1354   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1355   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1356   return ret;
1357 JNI_END
1358 
1359 
1360 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1361           const char *name, const char *sig))
1362   JNIWrapper(&quot;GetStaticMethodID&quot;);
1363   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1364   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1365   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1366   return ret;
1367 JNI_END
1368 
1369 
1370 
1371 //
1372 // Calling Methods
1373 //
1374 
1375 
1376 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1377                           , EntryProbe, ReturnProbe)    \
1378 \
1379   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1380                           , ReturnProbe);                          \
1381 \
1382 JNI_ENTRY(ResultType, \
1383           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1384   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;Method&quot;); \
1385 \
1386   EntryProbe; \
1387   ResultType ret = 0;\
1388   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1389                      (const ResultType&amp;)ret);\
1390 \
1391   va_list args; \
1392   va_start(args, methodID); \
1393   JavaValue jvalue(Tag); \
1394   JNI_ArgumentPusherVaArg ap(methodID, args); \
1395   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1396   va_end(args); \
1397   ret = jvalue.get_##ResultType(); \
1398   return ret;\
1399 JNI_END
1400 
1401 // the runtime type of subword integral basic types is integer
1402 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1403                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1404                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1405 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1406                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1407                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1408 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1409                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1410                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1411 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1412                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1413                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1414 
1415 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1416                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1417                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1418 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1419                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1420                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1421 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1422                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1423                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1424 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1425 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1426                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1427                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1428 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1429                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1430                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1431 
1432 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1433                           , EntryProbe, ReturnProbe)    \
1434 \
1435   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1436                           , ReturnProbe);                          \
1437 \
1438 JNI_ENTRY(ResultType, \
1439           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1440   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodV&quot;); \
1441 \
1442   EntryProbe;\
1443   ResultType ret = 0;\
1444   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1445                      (const ResultType&amp;)ret);\
1446 \
1447   JavaValue jvalue(Tag); \
1448   JNI_ArgumentPusherVaArg ap(methodID, args); \
1449   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1450   ret = jvalue.get_##ResultType(); \
1451   return ret;\
1452 JNI_END
1453 
1454 // the runtime type of subword integral basic types is integer
1455 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1456                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1457                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1458 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1459                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1460                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1461 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1462                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1463                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1464 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1465                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1466                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1467 
1468 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1469                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1470                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1471 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1472                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1473                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1474 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1475                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1476                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1477 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1478 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1479                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1480                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1481 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1482                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1483                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1484 
1485 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1486                           , EntryProbe, ReturnProbe)    \
1487 \
1488   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1489                           , ReturnProbe);                          \
1490 \
1491 JNI_ENTRY(ResultType, \
1492           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1493   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodA&quot;); \
1494   EntryProbe; \
1495   ResultType ret = 0;\
1496   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1497                      (const ResultType&amp;)ret);\
1498 \
1499   JavaValue jvalue(Tag); \
1500   JNI_ArgumentPusherArray ap(methodID, args); \
1501   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1502   ret = jvalue.get_##ResultType(); \
1503   return ret;\
1504 JNI_END
1505 
1506 // the runtime type of subword integral basic types is integer
1507 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1508                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1509                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1510 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1511                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1512                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1513 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1514                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1515                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1516 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1517                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1518                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1519 
1520 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1521                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1522                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1523 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1524                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1525                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1526 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1527                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1528                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1529 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1530 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1531                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1532                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1533 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1534                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1535                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1536 
1537 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1538 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1539 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1540 
1541 
1542 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1543   JNIWrapper(&quot;CallVoidMethod&quot;);
1544   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1545   DT_VOID_RETURN_MARK(CallVoidMethod);
1546 
1547   va_list args;
1548   va_start(args, methodID);
1549   JavaValue jvalue(T_VOID);
1550   JNI_ArgumentPusherVaArg ap(methodID, args);
1551   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1552   va_end(args);
1553 JNI_END
1554 
1555 
1556 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1557   JNIWrapper(&quot;CallVoidMethodV&quot;);
1558   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1559   DT_VOID_RETURN_MARK(CallVoidMethodV);
1560 
1561   JavaValue jvalue(T_VOID);
1562   JNI_ArgumentPusherVaArg ap(methodID, args);
1563   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1564 JNI_END
1565 
1566 
1567 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1568   JNIWrapper(&quot;CallVoidMethodA&quot;);
1569   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1570   DT_VOID_RETURN_MARK(CallVoidMethodA);
1571 
1572   JavaValue jvalue(T_VOID);
1573   JNI_ArgumentPusherArray ap(methodID, args);
1574   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1575 JNI_END
1576 
1577 
1578 
1579 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1580                                     , EntryProbe, ReturnProbe)      \
1581 \
1582   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1583                           , ReturnProbe);\
1584 \
1585 JNI_ENTRY(ResultType, \
1586           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1587   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;Method&quot;); \
1588 \
1589   EntryProbe;\
1590   ResultType ret;\
1591   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1592                      (const ResultType&amp;)ret);\
1593 \
1594   va_list args; \
1595   va_start(args, methodID); \
1596   JavaValue jvalue(Tag); \
1597   JNI_ArgumentPusherVaArg ap(methodID, args); \
1598   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1599   va_end(args); \
1600   ret = jvalue.get_##ResultType(); \
1601   return ret;\
1602 JNI_END
1603 
1604 // the runtime type of subword integral basic types is integer
1605 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1606                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1607                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1608 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1609                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1610                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1611 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1612                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1613                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1614 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1615                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1616                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1617 
1618 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1619                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1620                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1621 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1622                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1623                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1624 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1625                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1626 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1627                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1628 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1629                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1630                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1631 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1632                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1633                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1634 
1635 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1636                                     , EntryProbe, ReturnProbe)      \
1637 \
1638   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1639                           , ReturnProbe);\
1640 \
1641 JNI_ENTRY(ResultType, \
1642           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1643   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodV&quot;); \
1644 \
1645   EntryProbe;\
1646   ResultType ret;\
1647   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1648                      (const ResultType&amp;)ret);\
1649 \
1650   JavaValue jvalue(Tag); \
1651   JNI_ArgumentPusherVaArg ap(methodID, args); \
1652   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1653   ret = jvalue.get_##ResultType(); \
1654   return ret;\
1655 JNI_END
1656 
1657 // the runtime type of subword integral basic types is integer
1658 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1659                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1660                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1661 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1662                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1663                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1664 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1665                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1666                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1667 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1668                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1669                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1670 
1671 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1672                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1673                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1674 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1675                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1676                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1677 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1678                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1679 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1680                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1681 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1682                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1683                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1684 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1685                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1686                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1687 
1688 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1689                                     , EntryProbe, ReturnProbe)      \
1690 \
1691   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1692                           , ReturnProbe);\
1693 \
1694 JNI_ENTRY(ResultType, \
1695           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1696   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodA&quot;); \
1697 \
1698   EntryProbe;\
1699   ResultType ret;\
1700   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1701                      (const ResultType&amp;)ret);\
1702 \
1703   JavaValue jvalue(Tag); \
1704   JNI_ArgumentPusherArray ap(methodID, args); \
1705   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1706   ret = jvalue.get_##ResultType(); \
1707   return ret;\
1708 JNI_END
1709 
1710 // the runtime type of subword integral basic types is integer
1711 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1712                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1713                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1714 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1715                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1716                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1717 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1718                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1719                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1720 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1721                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1722                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1723 
1724 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1725                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1726                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1727 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1728                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1729                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1730 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1731                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1732 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1733                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1734 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1735                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1736                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1737 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1738                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1739                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1740 
1741 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1742                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1743 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1744                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1745 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1746                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1747 
1748 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1749   JNIWrapper(&quot;CallNonvirtualVoidMethod&quot;);
1750 
1751   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1752   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1753 
1754   va_list args;
1755   va_start(args, methodID);
1756   JavaValue jvalue(T_VOID);
1757   JNI_ArgumentPusherVaArg ap(methodID, args);
1758   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1759   va_end(args);
1760 JNI_END
1761 
1762 
1763 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1764   JNIWrapper(&quot;CallNonvirtualVoidMethodV&quot;);
1765 
1766   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1767                env, obj, cls, (uintptr_t) methodID);
1768   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1769 
1770   JavaValue jvalue(T_VOID);
1771   JNI_ArgumentPusherVaArg ap(methodID, args);
1772   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1773 JNI_END
1774 
1775 
1776 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1777   JNIWrapper(&quot;CallNonvirtualVoidMethodA&quot;);
1778   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1779                 env, obj, cls, (uintptr_t) methodID);
1780   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1781   JavaValue jvalue(T_VOID);
1782   JNI_ArgumentPusherArray ap(methodID, args);
1783   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1784 JNI_END
1785 
1786 
1787 
1788 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1789                                 , EntryProbe, ResultProbe) \
1790 \
1791   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1792                           , ResultProbe);                               \
1793 \
1794 JNI_ENTRY(ResultType, \
1795           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1796   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;Method&quot;); \
1797 \
1798   EntryProbe; \
1799   ResultType ret = 0;\
1800   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1801                      (const ResultType&amp;)ret);\
1802 \
1803   va_list args; \
1804   va_start(args, methodID); \
1805   JavaValue jvalue(Tag); \
1806   JNI_ArgumentPusherVaArg ap(methodID, args); \
1807   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1808   va_end(args); \
1809   ret = jvalue.get_##ResultType(); \
1810   return ret;\
1811 JNI_END
1812 
1813 // the runtime type of subword integral basic types is integer
1814 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1815                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1816                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1817 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1818                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1819                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1820 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1821                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1822                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1823 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1824                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1825                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1826 
1827 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1828                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1829                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1830 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1831                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1832                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1833 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1834                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1835                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1836 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1837 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1838                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1839                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1840 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1841                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1842                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1843 
1844 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1845                                 , EntryProbe, ResultProbe) \
1846 \
1847   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1848                           , ResultProbe);                               \
1849 \
1850 JNI_ENTRY(ResultType, \
1851           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1852   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodV&quot;); \
1853 \
1854   EntryProbe; \
1855   ResultType ret = 0;\
1856   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1857                      (const ResultType&amp;)ret);\
1858 \
1859   JavaValue jvalue(Tag); \
1860   JNI_ArgumentPusherVaArg ap(methodID, args); \
1861   /* Make sure class is initialized before trying to invoke its method */ \
1862   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
1863   k-&gt;initialize(CHECK_0); \
1864   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1865   va_end(args); \
1866   ret = jvalue.get_##ResultType(); \
1867   return ret;\
1868 JNI_END
1869 
1870 // the runtime type of subword integral basic types is integer
1871 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1872                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1873                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1874 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1875                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1876                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1877 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1878                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1879                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1880 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1881                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1882                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1883 
1884 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1885                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1886                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1887 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1888                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1889                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1890 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1891                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1892                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1893 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1894 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1895                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1896                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1897 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1898                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1899                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1900 
1901 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1902                                 , EntryProbe, ResultProbe) \
1903 \
1904   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1905                           , ResultProbe);                               \
1906 \
1907 JNI_ENTRY(ResultType, \
1908           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1909   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodA&quot;); \
1910 \
1911   EntryProbe; \
1912   ResultType ret = 0;\
1913   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1914                      (const ResultType&amp;)ret);\
1915 \
1916   JavaValue jvalue(Tag); \
1917   JNI_ArgumentPusherArray ap(methodID, args); \
1918   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1919   ret = jvalue.get_##ResultType(); \
1920   return ret;\
1921 JNI_END
1922 
1923 // the runtime type of subword integral basic types is integer
1924 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1925                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1926                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1927 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1928                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1929                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1930 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1931                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1932                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1933 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1934                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1935                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1936 
1937 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1938                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1939                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1940 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1941                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1942                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1943 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1944                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1945                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1946 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1947 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1948                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1949                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1950 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1951                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1952                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1953 
1954 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1955                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1956 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1957                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1958 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1959                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1960 
1961 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1962   JNIWrapper(&quot;CallStaticVoidMethod&quot;);
1963   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1964   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1965 
1966   va_list args;
1967   va_start(args, methodID);
1968   JavaValue jvalue(T_VOID);
1969   JNI_ArgumentPusherVaArg ap(methodID, args);
1970   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1971   va_end(args);
1972 JNI_END
1973 
1974 
1975 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
1976   JNIWrapper(&quot;CallStaticVoidMethodV&quot;);
1977   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
1978   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
1979 
1980   JavaValue jvalue(T_VOID);
1981   JNI_ArgumentPusherVaArg ap(methodID, args);
1982   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1983 JNI_END
1984 
1985 
1986 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
1987   JNIWrapper(&quot;CallStaticVoidMethodA&quot;);
1988   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
1989   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
1990 
1991   JavaValue jvalue(T_VOID);
1992   JNI_ArgumentPusherArray ap(methodID, args);
1993   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1994 JNI_END
1995 
1996 
1997 //
1998 // Accessing Fields
1999 //
2000 
2001 
2002 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
2003                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
2004 
2005 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
2006           const char *name, const char *sig))
2007   JNIWrapper(&quot;GetFieldID&quot;);
2008   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2009   jfieldID ret = 0;
2010   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
2011 
2012   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2013 
2014   // The class should have been loaded (we have an instance of the class
2015   // passed in) so the field and signature should already be in the symbol
2016   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2017   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2018   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2019   if (fieldname == NULL || signame == NULL) {
2020     ResourceMark rm;
2021     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
2022   }
2023 
2024   // Make sure class is initialized before handing id&#39;s out to fields
2025   k-&gt;initialize(CHECK_NULL);
2026 
2027   fieldDescriptor fd;
2028   if (!k-&gt;is_instance_klass() ||
2029       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
2030     ResourceMark rm;
2031     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
2032   }
2033 
2034   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
2035   // It may also have hash bits for k, if VerifyJNIFields is turned on.
2036   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
2037   return ret;
2038 JNI_END
2039 
2040 
2041 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
2042   JNIWrapper(&quot;GetObjectField&quot;);
2043   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
2044   oop o = JNIHandles::resolve_non_null(obj);
2045   Klass* k = o-&gt;klass();
2046   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2047   // Keep JVMTI addition small and only check enabled flag here.
2048   // jni_GetField_probe() assumes that is okay to create handles.
2049   if (JvmtiExport::should_post_field_access()) {
2050     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
2051   }
2052   oop loaded_obj = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
2053   jobject ret = JNIHandles::make_local(env, loaded_obj);
2054   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
2055   return ret;
2056 JNI_END
2057 
2058 
2059 
2060 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2061   , EntryProbe, ReturnProbe) \
2062 \
2063   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2064   , ReturnProbe); \
2065 \
2066 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
2067   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
2068 \
2069   EntryProbe; \
2070   Return ret = 0;\
2071   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2072 \
2073   oop o = JNIHandles::resolve_non_null(obj); \
2074   Klass* k = o-&gt;klass(); \
2075   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2076   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2077   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
2078   /* and creates a ResetNoHandleMark.                                   */ \
2079   if (JvmtiExport::should_post_field_access()) { \
2080     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2081   } \
2082   ret = o-&gt;Fieldname##_field(offset); \
2083   return ret; \
2084 JNI_END
2085 
2086 DEFINE_GETFIELD(jboolean, bool,   Boolean
2087                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2088                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
2089 DEFINE_GETFIELD(jbyte,    byte,   Byte
2090                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2091                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
2092 DEFINE_GETFIELD(jchar,    char,   Char
2093                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2094                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
2095 DEFINE_GETFIELD(jshort,   short,  Short
2096                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2097                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
2098 DEFINE_GETFIELD(jint,     int,    Int
2099                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2100                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
2101 DEFINE_GETFIELD(jlong,    long,   Long
2102                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2103                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
2104 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2105 DEFINE_GETFIELD(jfloat,   float,  Float
2106                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2107                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2108 DEFINE_GETFIELD(jdouble,  double, Double
2109                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2110                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2111 
2112 address jni_GetBooleanField_addr() {
2113   return (address)jni_GetBooleanField;
2114 }
2115 address jni_GetByteField_addr() {
2116   return (address)jni_GetByteField;
2117 }
2118 address jni_GetCharField_addr() {
2119   return (address)jni_GetCharField;
2120 }
2121 address jni_GetShortField_addr() {
2122   return (address)jni_GetShortField;
2123 }
2124 address jni_GetIntField_addr() {
2125   return (address)jni_GetIntField;
2126 }
2127 address jni_GetLongField_addr() {
2128   return (address)jni_GetLongField;
2129 }
2130 address jni_GetFloatField_addr() {
2131   return (address)jni_GetFloatField;
2132 }
2133 address jni_GetDoubleField_addr() {
2134   return (address)jni_GetDoubleField;
2135 }
2136 
2137 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2138   JNIWrapper(&quot;SetObjectField&quot;);
2139   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2140   oop o = JNIHandles::resolve_non_null(obj);
2141   Klass* k = o-&gt;klass();
2142   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2143   // Keep JVMTI addition small and only check enabled flag here.
2144   // jni_SetField_probe_nh() assumes that is not okay to create handles
2145   // and creates a ResetNoHandleMark.
2146   if (JvmtiExport::should_post_field_modification()) {
2147     jvalue field_value;
2148     field_value.l = value;
2149     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2150   }
2151   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2152   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2153 JNI_END
2154 
2155 
2156 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2157                         , EntryProbe, ReturnProbe) \
2158 \
2159 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2160   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2161 \
2162   EntryProbe; \
2163 \
2164   oop o = JNIHandles::resolve_non_null(obj); \
2165   Klass* k = o-&gt;klass(); \
2166   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2167   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2168   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2169   /* and creates a ResetNoHandleMark.                                   */ \
2170   if (JvmtiExport::should_post_field_modification()) { \
2171     jvalue field_value; \
2172     field_value.unionType = value; \
2173     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2174   } \
2175   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2176   o-&gt;Fieldname##_field_put(offset, value); \
2177   ReturnProbe; \
2178 JNI_END
2179 
2180 DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2181                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2182                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2183 DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2184                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2185                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2186 DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2187                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2188                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2189 DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2190                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2191                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2192 DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2193                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2194                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2195 DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2196                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2197                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2198 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2199 DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2200                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2201                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2202 DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2203                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2204                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2205 
2206 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2207                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2208 
2209 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2210   JNIWrapper(&quot;ToReflectedField&quot;);
2211   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2212   jobject ret = NULL;
2213   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2214 
2215   fieldDescriptor fd;
2216   bool found = false;
2217   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2218 
2219   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2220 
2221   if (isStatic) {
2222     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2223     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2224     assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2225     found = id-&gt;find_local_field(&amp;fd);
2226   } else {
2227     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2228     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2229     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2230   }
2231   assert(found, &quot;bad fieldID passed into jni_ToReflectedField&quot;);
2232   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2233   ret = JNIHandles::make_local(env, reflected);
2234   return ret;
2235 JNI_END
2236 
2237 
2238 //
2239 // Accessing Static Fields
2240 //
2241 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2242                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2243 
2244 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2245           const char *name, const char *sig))
2246   JNIWrapper(&quot;GetStaticFieldID&quot;);
2247   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2248   jfieldID ret = NULL;
2249   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2250 
2251   // The class should have been loaded (we have an instance of the class
2252   // passed in) so the field and signature should already be in the symbol
2253   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2254   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2255   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2256   if (fieldname == NULL || signame == NULL) {
2257     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2258   }
2259   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2260   // Make sure class is initialized before handing id&#39;s out to static fields
2261   k-&gt;initialize(CHECK_NULL);
2262 
2263   fieldDescriptor fd;
2264   if (!k-&gt;is_instance_klass() ||
2265       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2266     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2267   }
2268 
2269   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2270   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2271   debug_only(id-&gt;set_is_static_field_id();)
2272 
2273   debug_only(id-&gt;verify(fd.field_holder()));
2274 
2275   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2276   return ret;
2277 JNI_END
2278 
2279 
2280 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2281   JNIWrapper(&quot;GetStaticObjectField&quot;);
2282   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2283 #if INCLUDE_JNI_CHECK
2284   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2285 #endif // INCLUDE_JNI_CHECK
2286   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2287   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2288   // Keep JVMTI addition small and only check enabled flag here.
2289   // jni_GetField_probe() assumes that is okay to create handles.
2290   if (JvmtiExport::should_post_field_access()) {
2291     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2292   }
2293   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2294   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2295   return ret;
2296 JNI_END
2297 
2298 
2299 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2300                               , EntryProbe, ReturnProbe) \
2301 \
2302   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2303                           , ReturnProbe);                                          \
2304 \
2305 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2306   JNIWrapper(&quot;GetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2307   EntryProbe; \
2308   Return ret = 0;\
2309   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2310                      (const Return&amp;)ret);\
2311   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2312   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2313   /* Keep JVMTI addition small and only check enabled flag here. */ \
2314   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2315   if (JvmtiExport::should_post_field_access()) { \
2316     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2317   } \
2318   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2319   return ret;\
2320 JNI_END
2321 
2322 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2323                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2324 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2325                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2326 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2327                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2328 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2329                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2330 DEFINE_GETSTATICFIELD(jint,     int,    Int
2331                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2332 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2333                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2334 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2335 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2336                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2337 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2338                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2339 
2340 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2341   JNIWrapper(&quot;SetStaticObjectField&quot;);
2342  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2343   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2344   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2345   // Keep JVMTI addition small and only check enabled flag here.
2346   // jni_SetField_probe() assumes that is okay to create handles.
2347   if (JvmtiExport::should_post_field_modification()) {
2348     jvalue field_value;
2349     field_value.l = value;
2350     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2351   }
2352   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2353   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2354 JNI_END
2355 
2356 
2357 
2358 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2359                               , EntryProbe, ReturnProbe) \
2360 \
2361 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2362   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2363   EntryProbe; \
2364 \
2365   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2366   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2367   /* Keep JVMTI addition small and only check enabled flag here. */ \
2368   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2369   if (JvmtiExport::should_post_field_modification()) { \
2370     jvalue field_value; \
2371     field_value.unionType = value; \
2372     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2373   } \
2374   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2375   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2376   ReturnProbe;\
2377 JNI_END
2378 
2379 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2380                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2381                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2382 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2383                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2384                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2385 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2386                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2387                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2388 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2389                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2390                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2391 DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2392                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2393                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2394 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2395                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2396                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2397 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2398 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2399                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2400                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2401 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2402                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2403                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2404 
2405 //
2406 // String Operations
2407 //
2408 
2409 // Unicode Interface
2410 
2411 DT_RETURN_MARK_DECL(NewString, jstring
2412                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2413 
2414 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2415   JNIWrapper(&quot;NewString&quot;);
2416  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2417   jstring ret = NULL;
2418   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2419   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2420   ret = (jstring) JNIHandles::make_local(env, string);
2421   return ret;
2422 JNI_END
2423 
2424 
2425 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2426   JNIWrapper(&quot;GetStringLength&quot;);
2427   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2428   jsize ret = 0;
2429   oop s = JNIHandles::resolve_non_null(string);
2430   ret = java_lang_String::length(s);
2431  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2432   return ret;
2433 JNI_END
2434 
2435 
2436 JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(
2437   JNIEnv *env, jstring string, jboolean *isCopy))
2438   JNIWrapper(&quot;GetStringChars&quot;);
2439  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2440   jchar* buf = NULL;
2441   oop s = JNIHandles::resolve_non_null(string);
2442   typeArrayOop s_value = java_lang_String::value(s);
2443   if (s_value != NULL) {
2444     int s_len = java_lang_String::length(s, s_value);
2445     bool is_latin1 = java_lang_String::is_latin1(s);
2446     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2447     /* JNI Specification states return NULL on OOM */
2448     if (buf != NULL) {
2449       if (s_len &gt; 0) {
2450         if (!is_latin1) {
2451           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2452                                              buf, s_len);
2453         } else {
2454           for (int i = 0; i &lt; s_len; i++) {
2455             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2456           }
2457         }
2458       }
2459       buf[s_len] = 0;
2460       //%note jni_5
2461       if (isCopy != NULL) {
2462         *isCopy = JNI_TRUE;
2463       }
2464     }
2465   }
2466   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2467   return buf;
2468 JNI_END
2469 
2470 
2471 JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2472   JNIWrapper(&quot;ReleaseStringChars&quot;);
2473   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2474   //%note jni_6
2475   if (chars != NULL) {
2476     // Since String objects are supposed to be immutable, don&#39;t copy any
2477     // new data back.  A bad user will have to go after the char array.
2478     FreeHeap((void*) chars);
2479   }
2480   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2481 JNI_END
2482 
2483 
2484 // UTF Interface
2485 
2486 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2487                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2488 
2489 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2490   JNIWrapper(&quot;NewStringUTF&quot;);
2491   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2492   jstring ret;
2493   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2494 
2495   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2496   ret = (jstring) JNIHandles::make_local(env, result);
2497   return ret;
2498 JNI_END
2499 
2500 
2501 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2502   JNIWrapper(&quot;GetStringUTFLength&quot;);
2503  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2504   oop java_string = JNIHandles::resolve_non_null(string);
2505   jsize ret = java_lang_String::utf8_length(java_string);
2506   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2507   return ret;
2508 JNI_END
2509 
2510 
2511 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2512   JNIWrapper(&quot;GetStringUTFChars&quot;);
2513  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2514   char* result = NULL;
2515   oop java_string = JNIHandles::resolve_non_null(string);
2516   typeArrayOop s_value = java_lang_String::value(java_string);
2517   if (s_value != NULL) {
2518     size_t length = java_lang_String::utf8_length(java_string, s_value);
2519     /* JNI Specification states return NULL on OOM */
2520     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2521     if (result != NULL) {
2522       java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);
2523       if (isCopy != NULL) {
2524         *isCopy = JNI_TRUE;
2525       }
2526     }
2527   }
2528  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2529   return result;
2530 JNI_END
2531 
2532 
2533 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2534   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2535  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2536   if (chars != NULL) {
2537     FreeHeap((char*) chars);
2538   }
2539 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2540 JNI_END
2541 
2542 
2543 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2544   JNIWrapper(&quot;GetArrayLength&quot;);
2545  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2546   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2547   assert(a-&gt;is_array(), &quot;must be array&quot;);
2548   jsize ret = a-&gt;length();
2549  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2550   return ret;
2551 JNI_END
2552 
2553 
2554 //
2555 // Object Array Operations
2556 //
2557 
2558 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2559                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2560 
2561 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2562   JNIWrapper(&quot;NewObjectArray&quot;);
2563  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2564   jobjectArray ret = NULL;
2565   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2566   Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
2567   Klass* ak = ek-&gt;array_klass(CHECK_NULL);
2568   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2569   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2570   oop initial_value = JNIHandles::resolve(initialElement);
2571   if (initial_value != NULL) {  // array already initialized with NULL
2572     for (int index = 0; index &lt; length; index++) {
2573       result-&gt;obj_at_put(index, initial_value);
2574     }
2575   }
2576   ret = (jobjectArray) JNIHandles::make_local(env, result);
2577   return ret;
2578 JNI_END
2579 
2580 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2581                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2582 
2583 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2584   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2585  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2586   jobject ret = NULL;
2587   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2588   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2589   if (a-&gt;is_within_bounds(index)) {
2590     ret = JNIHandles::make_local(env, a-&gt;obj_at(index));
2591     return ret;
2592   } else {
2593     ResourceMark rm(THREAD);
2594     stringStream ss;
2595     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2596     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2597   }
2598 JNI_END
2599 
2600 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2601                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2602 
2603 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2604   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2605  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2606   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2607 
2608   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2609   oop v = JNIHandles::resolve(value);
2610   if (a-&gt;is_within_bounds(index)) {
2611     if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2612       a-&gt;obj_at_put(index, v);
2613     } else {
2614       ResourceMark rm(THREAD);
2615       stringStream ss;
2616       Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2617       ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2618                v-&gt;klass()-&gt;external_name(),
2619                bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),
2620                index);
2621       for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2622         ss.print(&quot;[]&quot;);
2623       }
2624       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2625     }
2626   } else {
2627     ResourceMark rm(THREAD);
2628     stringStream ss;
2629     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2630     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2631   }
2632 JNI_END
2633 
2634 
2635 
2636 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2637                               ,EntryProbe,ReturnProbe)  \
2638 \
2639   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2640                       , ReturnProbe); \
2641 \
2642 JNI_ENTRY(Return, \
2643           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2644   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2645   EntryProbe; \
2646   Return ret = NULL;\
2647   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2648 \
2649   oop obj= oopFactory::Allocator(len, CHECK_0); \
2650   ret = (Return) JNIHandles::make_local(env, obj); \
2651   return ret;\
2652 JNI_END
2653 
2654 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2655                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2656                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2657 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2658                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2659                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2660 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2661                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2662                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2663 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2664                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2665                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2666 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2667                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2668                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2669 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2670                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2671                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2672 DEFINE_NEWSCALARARRAY(jfloatArray,   new_floatArray,  Float,
2673                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2674                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2675 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2676                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2677                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2678 
2679 // Return an address which will fault if the caller writes to it.
2680 
2681 static char* get_bad_address() {
2682   static char* bad_address = NULL;
2683   if (bad_address == NULL) {
2684     size_t size = os::vm_allocation_granularity();
2685     bad_address = os::reserve_memory(size);
2686     if (bad_address != NULL) {
2687       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2688                          /*is_committed*/false);
2689       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2690     }
2691   }
2692   return bad_address;
2693 }
2694 
2695 
2696 
2697 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2698                                       , EntryProbe, ReturnProbe) \
2699 \
2700 JNI_ENTRY_NO_PRESERVE(ElementType*, \
2701           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2702   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2703   EntryProbe; \
2704   /* allocate an chunk of memory in c land */ \
2705   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2706   ElementType* result; \
2707   int len = a-&gt;length(); \
2708   if (len == 0) { \
2709     if (isCopy != NULL) { \
2710       *isCopy = JNI_FALSE; \
2711     } \
2712     /* Empty array: legal but useless, can&#39;t return NULL. \
2713      * Return a pointer to something useless. \
2714      * Avoid asserts in typeArrayOop. */ \
2715     result = (ElementType*)get_bad_address(); \
2716   } else { \
2717     /* JNI Specification states return NULL on OOM */                    \
2718     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2719     if (result != NULL) {                                                \
2720       /* copy the array to the c chunk */                                \
2721       ArrayAccess&lt;&gt;::arraycopy_to_native(a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), \
2722                                          result, len);                   \
2723       if (isCopy) {                                                      \
2724         *isCopy = JNI_TRUE;                                              \
2725       }                                                                  \
2726     }                                                                    \
2727   } \
2728   ReturnProbe; \
2729   return result; \
2730 JNI_END
2731 
2732 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2733                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2734                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2735 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2736                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2737                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2738 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2739                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2740                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2741 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2742                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2743                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2744 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2745                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2746                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2747 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2748                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2749                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2750 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2751 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2752                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2753                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2754 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2755                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2756                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2757 
2758 
2759 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2760                                           , EntryProbe, ReturnProbe);\
2761 \
2762 JNI_ENTRY_NO_PRESERVE(void, \
2763           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2764                                              ElementType *buf, jint mode)) \
2765   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2766   EntryProbe; \
2767   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2768   int len = a-&gt;length(); \
2769   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2770     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2771       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2772     } \
2773     if ((mode == 0) || (mode == JNI_ABORT)) { \
2774       FreeHeap(buf); \
2775     } \
2776   } \
2777   ReturnProbe; \
2778 JNI_END
2779 
2780 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2781                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2782                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2783 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2784                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2785                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2786 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2787                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2788                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2789 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2790                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2791                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2792 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2793                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2794                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2795 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2796                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2797                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2798 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2799                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2800                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2801 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2802                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2803                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2804 
2805 static void check_bounds(jsize start, jsize copy_len, jsize array_len, TRAPS) {
2806   ResourceMark rm(THREAD);
2807   if (copy_len &lt; 0) {
2808     stringStream ss;
2809     ss.print(&quot;Length %d is negative&quot;, copy_len);
2810     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2811   } else if (start &lt; 0 || (start &gt; array_len - copy_len)) {
2812     stringStream ss;
2813     ss.print(&quot;Array region %d..&quot; INT64_FORMAT &quot; out of bounds for length %d&quot;,
2814              start, (int64_t)start+(int64_t)copy_len, array_len);
2815     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2816   }
2817 }
2818 
2819 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2820                                     , EntryProbe, ReturnProbe); \
2821   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2822                            , ReturnProbe); \
2823 \
2824 JNI_ENTRY(void, \
2825 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2826              jsize len, ElementType *buf)) \
2827   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2828   EntryProbe; \
2829   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2830   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2831   check_bounds(start, len, src-&gt;length(), CHECK); \
2832   if (len &gt; 0) {    \
2833     ArrayAccess&lt;&gt;::arraycopy_to_native(src, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), buf, len); \
2834   } \
2835 JNI_END
2836 
2837 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2838                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2839                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2840 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2841                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2842                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2843 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2844                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2845                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2846 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2847                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2848                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2849 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2850                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2851                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2852 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2853                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2854                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2855 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2856                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2857                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2858 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2859                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2860                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2861 
2862 
2863 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2864                                     , EntryProbe, ReturnProbe); \
2865   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2866                            ,ReturnProbe);           \
2867 \
2868 JNI_ENTRY(void, \
2869 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2870              jsize len, const ElementType *buf)) \
2871   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2872   EntryProbe; \
2873   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2874   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2875   check_bounds(start, len, dst-&gt;length(), CHECK); \
2876   if (len &gt; 0) { \
2877     ArrayAccess&lt;&gt;::arraycopy_from_native(buf, dst, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), len); \
2878   } \
2879 JNI_END
2880 
2881 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2882                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2883                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2884 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2885                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2886                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2887 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2888                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2889                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2890 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2891                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2892                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2893 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2894                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2895                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2896 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2897                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2898                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2899 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2900                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2901                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2902 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2903                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2904                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2905 
2906 
2907 DT_RETURN_MARK_DECL(RegisterNatives, jint
2908                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2909 
2910 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2911                                     const JNINativeMethod *methods,
2912                                     jint nMethods))
2913   JNIWrapper(&quot;RegisterNatives&quot;);
2914   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2915   jint ret = 0;
2916   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2917 
2918   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2919 
2920   for (int index = 0; index &lt; nMethods; index++) {
2921     const char* meth_name = methods[index].name;
2922     const char* meth_sig = methods[index].signature;
2923     int meth_name_len = (int)strlen(meth_name);
2924 
2925     // The class should have been loaded (we have an instance of the class
2926     // passed in) so the method and signature should already be in the symbol
2927     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2928     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2929     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2930 
2931     if (name == NULL || signature == NULL) {
2932       ResourceMark rm;
2933       stringStream st;
2934       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2935       // Must return negative value on failure
2936       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2937     }
2938 
2939     bool res = Method::register_native(k, name, signature,
2940                                        (address) methods[index].fnPtr, THREAD);
2941     if (!res) {
2942       ret = -1;
2943       break;
2944     }
2945   }
2946   return ret;
2947 JNI_END
2948 
2949 
2950 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2951   JNIWrapper(&quot;UnregisterNatives&quot;);
2952  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2953   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2954   //%note jni_2
2955   if (k-&gt;is_instance_klass()) {
2956     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2957       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2958       if (m-&gt;is_native()) {
2959         m-&gt;clear_native_function();
2960         m-&gt;set_signature_handler(NULL);
2961       }
2962     }
2963   }
2964  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
2965   return 0;
2966 JNI_END
2967 
2968 //
2969 // Monitor functions
2970 //
2971 
2972 DT_RETURN_MARK_DECL(MonitorEnter, jint
2973                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
2974 
2975 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
2976  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
2977   jint ret = JNI_ERR;
2978   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
2979 
2980   // If the object is null, we can&#39;t do anything with it
2981   if (jobj == NULL) {
2982     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
2983   }
2984 
2985   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
2986   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
2987   ret = JNI_OK;
2988   return ret;
2989 JNI_END
2990 
2991 DT_RETURN_MARK_DECL(MonitorExit, jint
2992                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
2993 
2994 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
2995  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
2996   jint ret = JNI_ERR;
2997   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
2998 
2999   // Don&#39;t do anything with a null object
3000   if (jobj == NULL) {
3001     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3002   }
3003 
3004   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
3005   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
3006 
3007   ret = JNI_OK;
3008   return ret;
3009 JNI_END
3010 
3011 //
3012 // Extensions
3013 //
3014 
3015 DT_VOID_RETURN_MARK_DECL(GetStringRegion
3016                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
3017 
3018 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
3019   JNIWrapper(&quot;GetStringRegion&quot;);
3020  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
3021   DT_VOID_RETURN_MARK(GetStringRegion);
3022   oop s = JNIHandles::resolve_non_null(string);
3023   typeArrayOop s_value = java_lang_String::value(s);
3024   int s_len = java_lang_String::length(s, s_value);
3025   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3026     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3027   } else {
3028     if (len &gt; 0) {
3029       bool is_latin1 = java_lang_String::is_latin1(s);
3030       if (!is_latin1) {
3031         ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, typeArrayOopDesc::element_offset&lt;jchar&gt;(start),
3032                                            buf, len);
3033       } else {
3034         for (int i = 0; i &lt; len; i++) {
3035           buf[i] = ((jchar) s_value-&gt;byte_at(i + start)) &amp; 0xff;
3036         }
3037       }
3038     }
3039   }
3040 JNI_END
3041 
3042 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
3043                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
3044 
3045 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
3046   JNIWrapper(&quot;GetStringUTFRegion&quot;);
3047  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
3048   DT_VOID_RETURN_MARK(GetStringUTFRegion);
3049   oop s = JNIHandles::resolve_non_null(string);
3050   typeArrayOop s_value = java_lang_String::value(s);
3051   int s_len = java_lang_String::length(s, s_value);
3052   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3053     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3054   } else {
3055     //%note jni_7
3056     if (len &gt; 0) {
3057       // Assume the buffer is large enough as the JNI spec. does not require user error checking
3058       java_lang_String::as_utf8_string(s, s_value, start, len, buf, INT_MAX);
3059       // as_utf8_string null-terminates the result string
3060     } else {
3061       // JDK null-terminates the buffer even in len is zero
3062       if (buf != NULL) {
3063         buf[0] = 0;
3064       }
3065     }
3066   }
3067 JNI_END
3068 
3069 static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {
3070   if (Universe::heap()-&gt;supports_object_pinning()) {
3071     const oop o = JNIHandles::resolve_non_null(obj);
3072     return Universe::heap()-&gt;pin_object(thread, o);
3073   } else {
3074     GCLocker::lock_critical(thread);
3075     return JNIHandles::resolve_non_null(obj);
3076   }
3077 }
3078 
3079 static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {
3080   if (Universe::heap()-&gt;supports_object_pinning()) {
3081     const oop o = JNIHandles::resolve_non_null(obj);
3082     return Universe::heap()-&gt;unpin_object(thread, o);
3083   } else {
3084     GCLocker::unlock_critical(thread);
3085   }
3086 }
3087 
3088 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3089   JNIWrapper(&quot;GetPrimitiveArrayCritical&quot;);
3090  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3091   if (isCopy != NULL) {
3092     *isCopy = JNI_FALSE;
3093   }
3094   oop a = lock_gc_or_pin_object(thread, array);
3095   assert(a-&gt;is_array(), &quot;just checking&quot;);
3096   BasicType type;
3097   if (a-&gt;is_objArray()) {
3098     type = T_OBJECT;
3099   } else {
3100     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3101   }
3102   void* ret = arrayOop(a)-&gt;base(type);
3103  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3104   return ret;
3105 JNI_END
3106 
3107 
3108 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3109   JNIWrapper(&quot;ReleasePrimitiveArrayCritical&quot;);
3110   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3111   unlock_gc_or_unpin_object(thread, array);
3112 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3113 JNI_END
3114 
3115 
3116 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3117   JNIWrapper(&quot;GetStringCritical&quot;);
3118   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3119   oop s = lock_gc_or_pin_object(thread, string);
3120   typeArrayOop s_value = java_lang_String::value(s);
3121   bool is_latin1 = java_lang_String::is_latin1(s);
3122   if (isCopy != NULL) {
3123     *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;
3124   }
3125   jchar* ret;
3126   if (!is_latin1) {
3127     ret = (jchar*) s_value-&gt;base(T_CHAR);
3128   } else {
3129     // Inflate latin1 encoded string to UTF16
3130     int s_len = java_lang_String::length(s, s_value);
3131     ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
3132     /* JNI Specification states return NULL on OOM */
3133     if (ret != NULL) {
3134       for (int i = 0; i &lt; s_len; i++) {
3135         ret[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
3136       }
3137       ret[s_len] = 0;
3138     }
3139   }
3140  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3141   return ret;
3142 JNI_END
3143 
3144 
3145 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3146   JNIWrapper(&quot;ReleaseStringCritical&quot;);
3147   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3148   // The str and chars arguments are ignored for UTF16 strings
3149   oop s = JNIHandles::resolve_non_null(str);
3150   bool is_latin1 = java_lang_String::is_latin1(s);
3151   if (is_latin1) {
3152     // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
3153     // This assumes that ReleaseStringCritical bookends GetStringCritical.
3154     FREE_C_HEAP_ARRAY(jchar, chars);
3155   }
3156   unlock_gc_or_unpin_object(thread, str);
3157 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3158 JNI_END
3159 
3160 
3161 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3162   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3163  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3164   Handle ref_handle(thread, JNIHandles::resolve(ref));
3165   jweak ret = JNIHandles::make_weak_global(ref_handle);
3166  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3167   return ret;
3168 JNI_END
3169 
3170 // Must be JNI_ENTRY (with HandleMark)
3171 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3172   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3173   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3174   JNIHandles::destroy_weak_global(ref);
3175   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3176 JNI_END
3177 
3178 
3179 JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv *env))
3180   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3181  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3182   jni_check_async_exceptions(thread);
3183   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3184  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3185   return ret;
3186 JNI_END
3187 
3188 
3189 // Initialization state for three routines below relating to
3190 // java.nio.DirectBuffers
3191 static          int directBufferSupportInitializeStarted = 0;
3192 static volatile int directBufferSupportInitializeEnded   = 0;
3193 static volatile int directBufferSupportInitializeFailed  = 0;
3194 static jclass    bufferClass                 = NULL;
3195 static jclass    directBufferClass           = NULL;
3196 static jclass    directByteBufferClass       = NULL;
3197 static jmethodID directByteBufferConstructor = NULL;
3198 static jfieldID  directBufferAddressField    = NULL;
3199 static jfieldID  bufferCapacityField         = NULL;
3200 
3201 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3202   Handle loader;            // null (bootstrap) loader
3203   Handle protection_domain; // null protection domain
3204 
3205   TempNewSymbol sym = SymbolTable::new_symbol(name);
3206   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3207 
3208   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3209     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3210   }
3211   return result;
3212 }
3213 
3214 // These lookups are done with the NULL (bootstrap) ClassLoader to
3215 // circumvent any security checks that would be done by jni_FindClass.
3216 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3217 {
3218   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3219   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3220   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3221   return true;
3222 }
3223 JNI_END
3224 
3225 
3226 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3227   if (directBufferSupportInitializeFailed) {
3228     return false;
3229   }
3230 
3231   if (Atomic::cmpxchg(&amp;directBufferSupportInitializeStarted, 0, 1) == 0) {
3232     if (!lookupDirectBufferClasses(env)) {
3233       directBufferSupportInitializeFailed = 1;
3234       return false;
3235     }
3236 
3237     // Make global references for these
3238     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3239     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3240     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3241 
3242     // Get needed field and method IDs
3243     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3244     if (env-&gt;ExceptionCheck()) {
3245       env-&gt;ExceptionClear();
3246       directBufferSupportInitializeFailed = 1;
3247       return false;
3248     }
3249     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3250     if (env-&gt;ExceptionCheck()) {
3251       env-&gt;ExceptionClear();
3252       directBufferSupportInitializeFailed = 1;
3253       return false;
3254     }
3255     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, &quot;capacity&quot;, &quot;I&quot;);
3256     if (env-&gt;ExceptionCheck()) {
3257       env-&gt;ExceptionClear();
3258       directBufferSupportInitializeFailed = 1;
3259       return false;
3260     }
3261 
3262     if ((directByteBufferConstructor == NULL) ||
3263         (directBufferAddressField    == NULL) ||
3264         (bufferCapacityField         == NULL)) {
3265       directBufferSupportInitializeFailed = 1;
3266       return false;
3267     }
3268 
3269     directBufferSupportInitializeEnded = 1;
3270   } else {
3271     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3272       os::naked_yield();
3273     }
3274   }
3275 
3276   return !directBufferSupportInitializeFailed;
3277 }
3278 
3279 extern &quot;C&quot; jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3280 {
3281   // thread_from_jni_environment() will block if VM is gone.
3282   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3283 
3284   JNIWrapper(&quot;jni_NewDirectByteBuffer&quot;);
3285  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3286 
3287   if (!directBufferSupportInitializeEnded) {
3288     if (!initializeDirectBufferSupport(env, thread)) {
3289       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3290       return NULL;
3291     }
3292   }
3293 
3294   // Being paranoid about accidental sign extension on address
3295   jlong addr = (jlong) ((uintptr_t) address);
3296   // NOTE that package-private DirectByteBuffer constructor currently
3297   // takes int capacity
3298   jint  cap  = (jint)  capacity;
3299   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3300   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3301   return ret;
3302 }
3303 
3304 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3305                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3306 
3307 extern &quot;C&quot; void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3308 {
3309   // thread_from_jni_environment() will block if VM is gone.
3310   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3311 
3312   JNIWrapper(&quot;jni_GetDirectBufferAddress&quot;);
3313   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3314   void* ret = NULL;
3315   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3316 
3317   if (!directBufferSupportInitializeEnded) {
3318     if (!initializeDirectBufferSupport(env, thread)) {
3319       return 0;
3320     }
3321   }
3322 
3323   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3324     return 0;
3325   }
3326 
3327   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3328   return ret;
3329 }
3330 
3331 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3332                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3333 
3334 extern &quot;C&quot; jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3335 {
3336   // thread_from_jni_environment() will block if VM is gone.
3337   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3338 
3339   JNIWrapper(&quot;jni_GetDirectBufferCapacity&quot;);
3340   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3341   jlong ret = -1;
3342   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3343 
3344   if (!directBufferSupportInitializeEnded) {
3345     if (!initializeDirectBufferSupport(env, thread)) {
3346       ret = 0;
3347       return ret;
3348     }
3349   }
3350 
3351   if (buf == NULL) {
3352     return -1;
3353   }
3354 
3355   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3356     return -1;
3357   }
3358 
3359   // NOTE that capacity is currently an int in the implementation
3360   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3361   return ret;
3362 }
3363 
3364 
3365 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3366   JNIWrapper(&quot;GetVersion&quot;);
3367   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3368   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3369   return CurrentVersion;
3370 JNI_END
3371 
3372 extern struct JavaVM_ main_vm;
3373 
3374 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3375   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3376   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3377   *vm  = (JavaVM *)(&amp;main_vm);
3378   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3379   return JNI_OK;
3380 JNI_END
3381 
3382 
3383 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3384   JNIWrapper(&quot;GetModule&quot;);
3385   return Modules::get_module(clazz, THREAD);
3386 JNI_END
3387 
3388 
3389 // Structure containing all jni functions
3390 struct JNINativeInterface_ jni_NativeInterface = {
3391     NULL,
3392     NULL,
3393     NULL,
3394 
3395     NULL,
3396 
3397     jni_GetVersion,
3398 
3399     jni_DefineClass,
3400     jni_FindClass,
3401 
3402     jni_FromReflectedMethod,
3403     jni_FromReflectedField,
3404 
3405     jni_ToReflectedMethod,
3406 
3407     jni_GetSuperclass,
3408     jni_IsAssignableFrom,
3409 
3410     jni_ToReflectedField,
3411 
3412     jni_Throw,
3413     jni_ThrowNew,
3414     jni_ExceptionOccurred,
3415     jni_ExceptionDescribe,
3416     jni_ExceptionClear,
3417     jni_FatalError,
3418 
3419     jni_PushLocalFrame,
3420     jni_PopLocalFrame,
3421 
3422     jni_NewGlobalRef,
3423     jni_DeleteGlobalRef,
3424     jni_DeleteLocalRef,
3425     jni_IsSameObject,
3426 
3427     jni_NewLocalRef,
3428     jni_EnsureLocalCapacity,
3429 
3430     jni_AllocObject,
3431     jni_NewObject,
3432     jni_NewObjectV,
3433     jni_NewObjectA,
3434 
3435     jni_GetObjectClass,
3436     jni_IsInstanceOf,
3437 
3438     jni_GetMethodID,
3439 
3440     jni_CallObjectMethod,
3441     jni_CallObjectMethodV,
3442     jni_CallObjectMethodA,
3443     jni_CallBooleanMethod,
3444     jni_CallBooleanMethodV,
3445     jni_CallBooleanMethodA,
3446     jni_CallByteMethod,
3447     jni_CallByteMethodV,
3448     jni_CallByteMethodA,
3449     jni_CallCharMethod,
3450     jni_CallCharMethodV,
3451     jni_CallCharMethodA,
3452     jni_CallShortMethod,
3453     jni_CallShortMethodV,
3454     jni_CallShortMethodA,
3455     jni_CallIntMethod,
3456     jni_CallIntMethodV,
3457     jni_CallIntMethodA,
3458     jni_CallLongMethod,
3459     jni_CallLongMethodV,
3460     jni_CallLongMethodA,
3461     jni_CallFloatMethod,
3462     jni_CallFloatMethodV,
3463     jni_CallFloatMethodA,
3464     jni_CallDoubleMethod,
3465     jni_CallDoubleMethodV,
3466     jni_CallDoubleMethodA,
3467     jni_CallVoidMethod,
3468     jni_CallVoidMethodV,
3469     jni_CallVoidMethodA,
3470 
3471     jni_CallNonvirtualObjectMethod,
3472     jni_CallNonvirtualObjectMethodV,
3473     jni_CallNonvirtualObjectMethodA,
3474     jni_CallNonvirtualBooleanMethod,
3475     jni_CallNonvirtualBooleanMethodV,
3476     jni_CallNonvirtualBooleanMethodA,
3477     jni_CallNonvirtualByteMethod,
3478     jni_CallNonvirtualByteMethodV,
3479     jni_CallNonvirtualByteMethodA,
3480     jni_CallNonvirtualCharMethod,
3481     jni_CallNonvirtualCharMethodV,
3482     jni_CallNonvirtualCharMethodA,
3483     jni_CallNonvirtualShortMethod,
3484     jni_CallNonvirtualShortMethodV,
3485     jni_CallNonvirtualShortMethodA,
3486     jni_CallNonvirtualIntMethod,
3487     jni_CallNonvirtualIntMethodV,
3488     jni_CallNonvirtualIntMethodA,
3489     jni_CallNonvirtualLongMethod,
3490     jni_CallNonvirtualLongMethodV,
3491     jni_CallNonvirtualLongMethodA,
3492     jni_CallNonvirtualFloatMethod,
3493     jni_CallNonvirtualFloatMethodV,
3494     jni_CallNonvirtualFloatMethodA,
3495     jni_CallNonvirtualDoubleMethod,
3496     jni_CallNonvirtualDoubleMethodV,
3497     jni_CallNonvirtualDoubleMethodA,
3498     jni_CallNonvirtualVoidMethod,
3499     jni_CallNonvirtualVoidMethodV,
3500     jni_CallNonvirtualVoidMethodA,
3501 
3502     jni_GetFieldID,
3503 
3504     jni_GetObjectField,
3505     jni_GetBooleanField,
3506     jni_GetByteField,
3507     jni_GetCharField,
3508     jni_GetShortField,
3509     jni_GetIntField,
3510     jni_GetLongField,
3511     jni_GetFloatField,
3512     jni_GetDoubleField,
3513 
3514     jni_SetObjectField,
3515     jni_SetBooleanField,
3516     jni_SetByteField,
3517     jni_SetCharField,
3518     jni_SetShortField,
3519     jni_SetIntField,
3520     jni_SetLongField,
3521     jni_SetFloatField,
3522     jni_SetDoubleField,
3523 
3524     jni_GetStaticMethodID,
3525 
3526     jni_CallStaticObjectMethod,
3527     jni_CallStaticObjectMethodV,
3528     jni_CallStaticObjectMethodA,
3529     jni_CallStaticBooleanMethod,
3530     jni_CallStaticBooleanMethodV,
3531     jni_CallStaticBooleanMethodA,
3532     jni_CallStaticByteMethod,
3533     jni_CallStaticByteMethodV,
3534     jni_CallStaticByteMethodA,
3535     jni_CallStaticCharMethod,
3536     jni_CallStaticCharMethodV,
3537     jni_CallStaticCharMethodA,
3538     jni_CallStaticShortMethod,
3539     jni_CallStaticShortMethodV,
3540     jni_CallStaticShortMethodA,
3541     jni_CallStaticIntMethod,
3542     jni_CallStaticIntMethodV,
3543     jni_CallStaticIntMethodA,
3544     jni_CallStaticLongMethod,
3545     jni_CallStaticLongMethodV,
3546     jni_CallStaticLongMethodA,
3547     jni_CallStaticFloatMethod,
3548     jni_CallStaticFloatMethodV,
3549     jni_CallStaticFloatMethodA,
3550     jni_CallStaticDoubleMethod,
3551     jni_CallStaticDoubleMethodV,
3552     jni_CallStaticDoubleMethodA,
3553     jni_CallStaticVoidMethod,
3554     jni_CallStaticVoidMethodV,
3555     jni_CallStaticVoidMethodA,
3556 
3557     jni_GetStaticFieldID,
3558 
3559     jni_GetStaticObjectField,
3560     jni_GetStaticBooleanField,
3561     jni_GetStaticByteField,
3562     jni_GetStaticCharField,
3563     jni_GetStaticShortField,
3564     jni_GetStaticIntField,
3565     jni_GetStaticLongField,
3566     jni_GetStaticFloatField,
3567     jni_GetStaticDoubleField,
3568 
3569     jni_SetStaticObjectField,
3570     jni_SetStaticBooleanField,
3571     jni_SetStaticByteField,
3572     jni_SetStaticCharField,
3573     jni_SetStaticShortField,
3574     jni_SetStaticIntField,
3575     jni_SetStaticLongField,
3576     jni_SetStaticFloatField,
3577     jni_SetStaticDoubleField,
3578 
3579     jni_NewString,
3580     jni_GetStringLength,
3581     jni_GetStringChars,
3582     jni_ReleaseStringChars,
3583 
3584     jni_NewStringUTF,
3585     jni_GetStringUTFLength,
3586     jni_GetStringUTFChars,
3587     jni_ReleaseStringUTFChars,
3588 
3589     jni_GetArrayLength,
3590 
3591     jni_NewObjectArray,
3592     jni_GetObjectArrayElement,
3593     jni_SetObjectArrayElement,
3594 
3595     jni_NewBooleanArray,
3596     jni_NewByteArray,
3597     jni_NewCharArray,
3598     jni_NewShortArray,
3599     jni_NewIntArray,
3600     jni_NewLongArray,
3601     jni_NewFloatArray,
3602     jni_NewDoubleArray,
3603 
3604     jni_GetBooleanArrayElements,
3605     jni_GetByteArrayElements,
3606     jni_GetCharArrayElements,
3607     jni_GetShortArrayElements,
3608     jni_GetIntArrayElements,
3609     jni_GetLongArrayElements,
3610     jni_GetFloatArrayElements,
3611     jni_GetDoubleArrayElements,
3612 
3613     jni_ReleaseBooleanArrayElements,
3614     jni_ReleaseByteArrayElements,
3615     jni_ReleaseCharArrayElements,
3616     jni_ReleaseShortArrayElements,
3617     jni_ReleaseIntArrayElements,
3618     jni_ReleaseLongArrayElements,
3619     jni_ReleaseFloatArrayElements,
3620     jni_ReleaseDoubleArrayElements,
3621 
3622     jni_GetBooleanArrayRegion,
3623     jni_GetByteArrayRegion,
3624     jni_GetCharArrayRegion,
3625     jni_GetShortArrayRegion,
3626     jni_GetIntArrayRegion,
3627     jni_GetLongArrayRegion,
3628     jni_GetFloatArrayRegion,
3629     jni_GetDoubleArrayRegion,
3630 
3631     jni_SetBooleanArrayRegion,
3632     jni_SetByteArrayRegion,
3633     jni_SetCharArrayRegion,
3634     jni_SetShortArrayRegion,
3635     jni_SetIntArrayRegion,
3636     jni_SetLongArrayRegion,
3637     jni_SetFloatArrayRegion,
3638     jni_SetDoubleArrayRegion,
3639 
3640     jni_RegisterNatives,
3641     jni_UnregisterNatives,
3642 
3643     jni_MonitorEnter,
3644     jni_MonitorExit,
3645 
3646     jni_GetJavaVM,
3647 
3648     jni_GetStringRegion,
3649     jni_GetStringUTFRegion,
3650 
3651     jni_GetPrimitiveArrayCritical,
3652     jni_ReleasePrimitiveArrayCritical,
3653 
3654     jni_GetStringCritical,
3655     jni_ReleaseStringCritical,
3656 
3657     jni_NewWeakGlobalRef,
3658     jni_DeleteWeakGlobalRef,
3659 
3660     jni_ExceptionCheck,
3661 
3662     jni_NewDirectByteBuffer,
3663     jni_GetDirectBufferAddress,
3664     jni_GetDirectBufferCapacity,
3665 
3666     // New 1_6 features
3667 
3668     jni_GetObjectRefType,
3669 
3670     // Module features
3671 
3672     jni_GetModule
3673 };
3674 
3675 
3676 // For jvmti use to modify jni function table.
3677 // Java threads in native contiues to run until it is transitioned
3678 // to VM at safepoint. Before the transition or before it is blocked
3679 // for safepoint it may access jni function table. VM could crash if
3680 // any java thread access the jni function table in the middle of memcpy.
3681 // To avoid this each function pointers are copied automically.
3682 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3683   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3684   intptr_t *a = (intptr_t *) jni_functions();
3685   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3686   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3687     Atomic::store(a++, *b++);
3688   }
3689 }
3690 
3691 void quicken_jni_functions() {
3692   // Replace Get&lt;Primitive&gt;Field with fast versions
3693   if (UseFastJNIAccessors &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {
3694     address func;
3695     func = JNI_FastGetField::generate_fast_get_boolean_field();
3696     if (func != (address)-1) {
3697       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
3698     }
3699     func = JNI_FastGetField::generate_fast_get_byte_field();
3700     if (func != (address)-1) {
3701       jni_NativeInterface.GetByteField = (GetByteField_t)func;
3702     }
3703     func = JNI_FastGetField::generate_fast_get_char_field();
3704     if (func != (address)-1) {
3705       jni_NativeInterface.GetCharField = (GetCharField_t)func;
3706     }
3707     func = JNI_FastGetField::generate_fast_get_short_field();
3708     if (func != (address)-1) {
3709       jni_NativeInterface.GetShortField = (GetShortField_t)func;
3710     }
3711     func = JNI_FastGetField::generate_fast_get_int_field();
3712     if (func != (address)-1) {
3713       jni_NativeInterface.GetIntField = (GetIntField_t)func;
3714     }
3715     func = JNI_FastGetField::generate_fast_get_long_field();
3716     if (func != (address)-1) {
3717       jni_NativeInterface.GetLongField = (GetLongField_t)func;
3718     }
3719     func = JNI_FastGetField::generate_fast_get_float_field();
3720     if (func != (address)-1) {
3721       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
3722     }
3723     func = JNI_FastGetField::generate_fast_get_double_field();
3724     if (func != (address)-1) {
3725       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
3726     }
3727   }
3728 }
3729 
3730 // Returns the function structure
3731 struct JNINativeInterface_* jni_functions() {
3732 #if INCLUDE_JNI_CHECK
3733   if (CheckJNICalls) return jni_functions_check();
3734 #endif // INCLUDE_JNI_CHECK
3735   return &amp;jni_NativeInterface;
3736 }
3737 
3738 // Returns the function structure
3739 struct JNINativeInterface_* jni_functions_nocheck() {
3740   return &amp;jni_NativeInterface;
3741 }
3742 
3743 static void post_thread_start_event(const JavaThread* jt) {
3744   assert(jt != NULL, &quot;invariant&quot;);
3745   EventThreadStart event;
3746   if (event.should_commit()) {
3747     event.set_thread(JFR_THREAD_ID(jt));
3748     event.commit();
3749   }
3750 }
3751 
3752 // Invocation API
3753 
3754 
3755 // Forward declaration
3756 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
3757 
3758 // Global invocation API vars
3759 volatile int vm_created = 0;
3760 // Indicate whether it is safe to recreate VM
3761 volatile int safe_to_recreate_vm = 1;
3762 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
3763 
3764 
3765 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
3766 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
3767 
3768 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
3769                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
3770 
3771 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
3772   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
3773   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
3774   jint ret = JNI_ERR;
3775   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
3776 
3777   if (Threads::is_supported_jni_version(args-&gt;version)) {
3778     ret = JNI_OK;
3779   }
3780   // 1.1 style no longer supported in hotspot.
3781   // According the JNI spec, we should update args-&gt;version on return.
3782   // We also use the structure to communicate with launcher about default
3783   // stack size.
3784   if (args-&gt;version == JNI_VERSION_1_1) {
3785     args-&gt;version = JNI_VERSION_1_2;
3786     // javaStackSize is int in arguments structure
3787     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, &quot;integer overflow&quot;);
3788     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
3789   }
3790   return ret;
3791 }
3792 
3793 DT_RETURN_MARK_DECL(CreateJavaVM, jint
3794                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
3795 
3796 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
3797   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
3798 
3799   jint result = JNI_ERR;
3800   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
3801 
3802   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
3803   // platforms use the GCC builtin __sync_lock_test_and_set for this,
3804   // but __sync_lock_test_and_set is not guaranteed to do what we want
3805   // on all architectures.  So we check it works before relying on it.
3806 #if defined(ZERO) &amp;&amp; defined(ASSERT)
3807   {
3808     jint a = 0xcafebabe;
3809     jint b = Atomic::xchg(&amp;a, (jint) 0xdeadbeef);
3810     void *c = &amp;a;
3811     void *d = Atomic::xchg(&amp;c, &amp;b);
3812     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
3813     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
3814   }
3815 #endif // ZERO &amp;&amp; ASSERT
3816 
3817   // At the moment it&#39;s only possible to have one Java VM,
3818   // since some of the runtime state is in global variables.
3819 
3820   // We cannot use our mutex locks here, since they only work on
3821   // Threads. We do an atomic compare and exchange to ensure only
3822   // one thread can call this method at a time
3823 
3824   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3825   // the add/dec implementations are dependent on whether we are running
3826   // on a multiprocessor Atomic::xchg does not have this problem.
3827   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
3828     return JNI_EEXIST;   // already created, or create attempt in progress
3829   }
3830   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
3831     return JNI_ERR;  // someone tried and failed and retry not allowed.
3832   }
3833 
3834   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
3835 
3836   /**
3837    * Certain errors during initialization are recoverable and do not
3838    * prevent this method from being called again at a later time
3839    * (perhaps with different arguments).  However, at a certain
3840    * point during initialization if an error occurs we cannot allow
3841    * this function to be called again (or it will crash).  In those
3842    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
3843    * sets safe_to_recreate_vm to 1, such that any new call to
3844    * JNI_CreateJavaVM will immediately fail using the above logic.
3845    */
3846   bool can_try_again = true;
3847 
3848   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3849   if (result == JNI_OK) {
3850     JavaThread *thread = JavaThread::current();
3851     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
3852     /* thread is thread_in_vm here */
3853     *vm = (JavaVM *)(&amp;main_vm);
3854     *(JNIEnv**)penv = thread-&gt;jni_environment();
3855 
3856 #if INCLUDE_JVMCI
3857     if (EnableJVMCI) {
3858       if (UseJVMCICompiler) {
3859         // JVMCI is initialized on a CompilerThread
3860         if (BootstrapJVMCI) {
3861           JavaThread* THREAD = thread;
3862           JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
3863           compiler-&gt;bootstrap(THREAD);
3864           if (HAS_PENDING_EXCEPTION) {
3865             HandleMark hm;
3866             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3867           }
3868         }
3869       }
3870     }
3871 #endif
3872 
3873     // Notify JVMTI
3874     if (JvmtiExport::should_post_thread_life()) {
3875        JvmtiExport::post_thread_start(thread);
3876     }
3877 
3878     post_thread_start_event(thread);
3879 
3880 #ifndef PRODUCT
3881     if (ReplayCompiles) ciReplay::replay(thread);
3882 
3883     // Some platforms (like Win*) need a wrapper around these test
3884     // functions in order to properly handle error conditions.
3885     VMError::test_error_handler();
3886 #endif
3887 
3888     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
3889     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
3890   } else {
3891     // If create_vm exits because of a pending exception, exit with that
3892     // exception.  In the future when we figure out how to reclaim memory,
3893     // we may be able to exit with JNI_ERR and allow the calling application
3894     // to continue.
3895     if (Universe::is_fully_initialized()) {
3896       // otherwise no pending exception possible - VM will already have aborted
3897       JavaThread* THREAD = JavaThread::current();
3898       if (HAS_PENDING_EXCEPTION) {
3899         HandleMark hm;
3900         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3901       }
3902     }
3903 
3904     if (can_try_again) {
3905       // reset safe_to_recreate_vm to 1 so that retrial would be possible
3906       safe_to_recreate_vm = 1;
3907     }
3908 
3909     // Creation failed. We must reset vm_created
3910     *vm = 0;
3911     *(JNIEnv**)penv = 0;
3912     // reset vm_created last to avoid race condition. Use OrderAccess to
3913     // control both compiler and architectural-based reordering.
3914     Atomic::release_store(&amp;vm_created, 0);
3915   }
3916 
3917   // Flush stdout and stderr before exit.
3918   fflush(stdout);
3919   fflush(stderr);
3920 
3921   return result;
3922 
3923 }
3924 
3925 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
3926   // See bug 4367188, the wrapper can sometimes cause VM crashes
3927   // JNIWrapper(&quot;GetCreatedJavaVMs&quot;);
3928 
3929   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
3930 
3931   if (vm_created == 1) {
3932     if (numVMs != NULL) *numVMs = 1;
3933     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
3934   } else {
3935     if (numVMs != NULL) *numVMs = 0;
3936   }
3937   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
3938   return JNI_OK;
3939 }
3940 
3941 extern &quot;C&quot; {
3942 
3943 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
3944                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
3945 
3946 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
3947   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
3948   jint res = JNI_ERR;
3949   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
3950 
3951   if (vm_created == 0) {
3952     res = JNI_ERR;
3953     return res;
3954   }
3955 
3956   JNIWrapper(&quot;DestroyJavaVM&quot;);
3957   JNIEnv *env;
3958   JavaVMAttachArgs destroyargs;
3959   destroyargs.version = CurrentVersion;
3960   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
3961   destroyargs.group = NULL;
3962   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
3963   if (res != JNI_OK) {
3964     return res;
3965   }
3966 
3967   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
3968   JavaThread* thread = JavaThread::current();
3969   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
3970   if (Threads::destroy_vm()) {
3971     // Should not change thread state, VM is gone
3972     vm_created = 0;
3973     res = JNI_OK;
3974     return res;
3975   } else {
3976     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
3977     res = JNI_ERR;
3978     return res;
3979   }
3980 }
3981 
3982 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
3983   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
3984 
3985   // Check below commented out from JDK1.2fcs as well
3986   /*
3987   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
3988     return JNI_EVERSION;
3989   }
3990   */
3991 
3992   Thread* t = Thread::current_or_null();
3993   if (t != NULL) {
3994     // If the thread has been attached this operation is a no-op
3995     *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();
3996     return JNI_OK;
3997   }
3998 
3999   // Create a thread and mark it as attaching so it will be skipped by the
4000   // ThreadsListEnumerator - see CR 6404306
4001   JavaThread* thread = new JavaThread(true);
4002 
4003   // Set correct safepoint info. The thread is going to call into Java when
4004   // initializing the Java level thread object. Hence, the correct state must
4005   // be set in order for the Safepoint code to deal with it correctly.
4006   thread-&gt;set_thread_state(_thread_in_vm);
4007   thread-&gt;record_stack_base_and_size();
4008   thread-&gt;register_thread_stack_with_NMT();
4009   thread-&gt;initialize_thread_current();
4010 
4011   if (!os::create_attached_thread(thread)) {
4012     thread-&gt;smr_delete();
4013     return JNI_ERR;
4014   }
4015   // Enable stack overflow checks
4016   thread-&gt;create_stack_guard_pages();
4017 
4018   thread-&gt;initialize_tlab();
4019 
4020   thread-&gt;cache_global_variables();
4021 
4022   // This thread will not do a safepoint check, since it has
4023   // not been added to the Thread list yet.
4024   { MutexLocker ml(Threads_lock);
4025     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4026     // avoid this thread trying to do a GC before it is added to the thread-list
4027     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4028     Threads::add(thread, daemon);
4029   }
4030   // Create thread group and name info from attach arguments
4031   oop group = NULL;
4032   char* thread_name = NULL;
4033   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4034     group = JNIHandles::resolve(args-&gt;group);
4035     thread_name = args-&gt;name; // may be NULL
4036   }
4037   if (group == NULL) group = Universe::main_thread_group();
4038 
4039   // Create Java level thread object and attach it to this thread
4040   bool attach_failed = false;
4041   {
4042     EXCEPTION_MARK;
4043     HandleMark hm(THREAD);
4044     Handle thread_group(THREAD, group);
4045     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4046     if (HAS_PENDING_EXCEPTION) {
4047       CLEAR_PENDING_EXCEPTION;
4048       // cleanup outside the handle mark.
4049       attach_failed = true;
4050     }
4051   }
4052 
4053   if (attach_failed) {
4054     // Added missing cleanup
4055     thread-&gt;cleanup_failed_attach_current_thread(daemon);
4056     return JNI_ERR;
4057   }
4058 
4059   // mark the thread as no longer attaching
4060   // this uses a fence to push the change through so we don&#39;t have
4061   // to regrab the threads_lock
4062   thread-&gt;set_done_attaching_via_jni();
4063 
4064   // Set java thread status.
4065   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4066               java_lang_Thread::RUNNABLE);
4067 
4068   // Notify the debugger
4069   if (JvmtiExport::should_post_thread_life()) {
4070     JvmtiExport::post_thread_start(thread);
4071   }
4072 
4073   post_thread_start_event(thread);
4074 
4075   *(JNIEnv**)penv = thread-&gt;jni_environment();
4076 
4077   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4078   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4079   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4080   // needed.
4081 
4082   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4083 
4084   // Perform any platform dependent FPU setup
4085   os::setup_fpu();
4086 
4087   return JNI_OK;
4088 }
4089 
4090 
4091 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4092   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4093   if (vm_created == 0) {
4094   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4095     return JNI_ERR;
4096   }
4097 
4098   JNIWrapper(&quot;AttachCurrentThread&quot;);
4099   jint ret = attach_current_thread(vm, penv, _args, false);
4100   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4101   return ret;
4102 }
4103 
4104 
4105 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4106   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
4107 
4108   JNIWrapper(&quot;DetachCurrentThread&quot;);
4109 
4110   // If the thread has already been detached the operation is a no-op
4111   if (Thread::current_or_null() == NULL) {
4112     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4113     return JNI_OK;
4114   }
4115 
4116   VM_Exit::block_if_vm_exited();
4117 
4118   JavaThread* thread = JavaThread::current();
4119   if (thread-&gt;has_last_Java_frame()) {
4120     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4121     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4122     return JNI_ERR;
4123   }
4124 
4125   // Safepoint support. Have to do call-back to safepoint code, if in the
4126   // middle of a safepoint operation
4127   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4128 
4129   // XXX: Note that JavaThread::exit() call below removes the guards on the
4130   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4131   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4132   // of the guards is visible in jni_AttachCurrentThread above,
4133   // the removal of the guards is buried below in JavaThread::exit()
4134   // here. The abstraction should be more symmetrically either exposed
4135   // or hidden (e.g. it could probably be hidden in the same
4136   // (platform-dependent) methods where we do alternate stack
4137   // maintenance work?)
4138   thread-&gt;exit(false, JavaThread::jni_detach);
4139   thread-&gt;smr_delete();
4140 
4141   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4142   return JNI_OK;
4143 }
4144 
4145 DT_RETURN_MARK_DECL(GetEnv, jint
4146                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4147 
4148 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4149   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4150   jint ret = JNI_ERR;
4151   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4152 
4153   if (vm_created == 0) {
4154     *penv = NULL;
4155     ret = JNI_EDETACHED;
4156     return ret;
4157   }
4158 
4159   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4160     return ret;
4161   }
4162 
4163 #ifndef JVMPI_VERSION_1
4164 // need these in order to be polite about older agents
4165 #define JVMPI_VERSION_1   ((jint)0x10000001)
4166 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4167 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4168 #endif // !JVMPI_VERSION_1
4169 
4170   Thread* thread = Thread::current_or_null();
4171   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4172     if (Threads::is_supported_jni_version_including_1_1(version)) {
4173       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4174       ret = JNI_OK;
4175       return ret;
4176 
4177     } else if (version == JVMPI_VERSION_1 ||
4178                version == JVMPI_VERSION_1_1 ||
4179                version == JVMPI_VERSION_1_2) {
4180       tty-&gt;print_cr(&quot;ERROR: JVMPI, an experimental interface, is no longer supported.&quot;);
4181       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4182       ret = JNI_EVERSION;
4183       return ret;
4184     } else if (JvmtiExport::is_jvmdi_version(version)) {
4185       tty-&gt;print_cr(&quot;FATAL ERROR: JVMDI is no longer supported.&quot;);
4186       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4187       ret = JNI_EVERSION;
4188       return ret;
4189     } else {
4190       *penv = NULL;
4191       ret = JNI_EVERSION;
4192       return ret;
4193     }
4194   } else {
4195     *penv = NULL;
4196     ret = JNI_EDETACHED;
4197     return ret;
4198   }
4199 }
4200 
4201 
4202 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4203   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4204   if (vm_created == 0) {
4205   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4206     return JNI_ERR;
4207   }
4208 
4209   JNIWrapper(&quot;AttachCurrentThreadAsDaemon&quot;);
4210   jint ret = attach_current_thread(vm, penv, _args, true);
4211   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4212   return ret;
4213 }
4214 
4215 
4216 } // End extern &quot;C&quot;
4217 
4218 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4219     NULL,
4220     NULL,
4221     NULL,
4222 
4223     jni_DestroyJavaVM,
4224     jni_AttachCurrentThread,
4225     jni_DetachCurrentThread,
4226     jni_GetEnv,
4227     jni_AttachCurrentThreadAsDaemon
4228 };
    </pre>
  </body>
</html>