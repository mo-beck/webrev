<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src\hotspot\cpu\aarch64\immediate_aarch64.hpp</title>
    <link rel="stylesheet" href="..\..\..\..\style.css" />
  </head>
<body>
<center><a href="immediate_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="..\..\..\..\index.html" target="_top">index</a> <a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src\hotspot\cpu\aarch64\immediate_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
29 
30 /*
31  * functions to map backwards and forwards between logical or floating
32  * point immediates and their corresponding encodings. the mapping
33  * from encoding to immediate is required by the simulator. the reverse
34  * mapping is required by the OpenJDK assembler.
35  *
36  * a logical immediate value supplied to or returned from a map lookup
37  * is always 64 bits. this is sufficient for looking up 32 bit
38  * immediates or their encodings since a 32 bit immediate has the same
39  * encoding as the 64 bit immediate produced by concatenating the
40  * immediate with itself.
41  *
42  * a logical immediate encoding is 13 bits N:immr:imms (3 fields of
43  * widths 1:6:6 -- see the arm spec). they appear as bits [22:10] of a
44  * logical immediate instruction. encodings are supplied and returned
45  * as 32 bit values. if a given 13 bit immediate has no corresponding
46  * encoding then a map lookup will return 0xffffffff.
47  */
48 
<span class="line-modified">49 u_int64_t logical_immediate_for_encoding(u_int32_t encoding);</span>
<span class="line-modified">50 u_int32_t encoding_for_logical_immediate(u_int64_t immediate);</span>
<span class="line-modified">51 u_int64_t fp_immediate_for_encoding(u_int32_t imm8, int is_dp);</span>
<span class="line-modified">52 u_int32_t encoding_for_fp_immediate(float immediate);</span>
53 
54 #endif // _IMMEDIATE_H
</pre>
</td>
<td>
<hr />
<pre>
29 
30 /*
31  * functions to map backwards and forwards between logical or floating
32  * point immediates and their corresponding encodings. the mapping
33  * from encoding to immediate is required by the simulator. the reverse
34  * mapping is required by the OpenJDK assembler.
35  *
36  * a logical immediate value supplied to or returned from a map lookup
37  * is always 64 bits. this is sufficient for looking up 32 bit
38  * immediates or their encodings since a 32 bit immediate has the same
39  * encoding as the 64 bit immediate produced by concatenating the
40  * immediate with itself.
41  *
42  * a logical immediate encoding is 13 bits N:immr:imms (3 fields of
43  * widths 1:6:6 -- see the arm spec). they appear as bits [22:10] of a
44  * logical immediate instruction. encodings are supplied and returned
45  * as 32 bit values. if a given 13 bit immediate has no corresponding
46  * encoding then a map lookup will return 0xffffffff.
47  */
48 
<span class="line-modified">49 uint64_t logical_immediate_for_encoding(uint32_t encoding);</span>
<span class="line-modified">50 uint32_t encoding_for_logical_immediate(uint64_t immediate);</span>
<span class="line-modified">51 uint64_t fp_immediate_for_encoding(uint32_t imm8, int is_dp);</span>
<span class="line-modified">52 uint32_t encoding_for_fp_immediate(float immediate);</span>
53 
54 #endif // _IMMEDIATE_H
</pre>
</td>
</tr>
</table>
<center><a href="immediate_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="..\..\..\..\index.html" target="_top">index</a> <a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>